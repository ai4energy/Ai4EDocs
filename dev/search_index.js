var documenterSearchIndex = {"docs":
[{"location":"CSBase/9-dll生成与调用实操/#动态链接库(DLL)的生成与调用实操","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"tip: Tip\nContents：Julia调用DllContributor: 杨月宝Email:812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#问题的产生与解决过程概述","page":"动态链接库(DLL)的生成与调用实操","title":"问题的产生与解决过程概述","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我们试图使用Julia来调用热流问题数值计算课程的代码。这些代码是在2003年重新整理的Fortran代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第一步：我们生成了Fortran动态链接库（dll），并尝试使用C语言调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第二步：接着，我们尝试使用C++来调用该dll，并试图使用Julia来调用它。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第三步：我们配置了VS2013，生成了64位的dll，并使用64位的Julia来调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#工作环境","page":"动态链接库(DLL)的生成与调用实操","title":"工作环境","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia版本：Julia 1.7.0-beta2\n使用的Fortran编译器：Intel.Visual.Fortran.Composer.XE.2013-SP1，这是在VS2013中的Fortran编译器。\n开发环境：VSCode（Visual Studio Code）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#实践过程","page":"动态链接库(DLL)的生成与调用实操","title":"实践过程","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"<!–  1.使用Fortran生成dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"2.使用VS2013开发人员命令提示查看dll位数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"3.使用C++调用dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"4.使用Julia调用dll –>","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Fortran生成dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Fortran生成dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"新建一个Fortran动态链接库项目","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Resource Files中添加一个f90文件，并输入如下内容","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"SUBROUTINE OUTPUT(a, b, sum)\n    !MS$ ATTRIBUTES DLLEXPORT::OUTPUT\n    !声明本函数为输出函数\n    IMPLICIT NONE\n    INTEGER a, b, sum\n    sum = a + b\nEND SUBROUTINE OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段Fortran代码定义了一个名为\"OUTPUT\"的子程序（SUBROUTINE），它接受三个参数：a、b和sum。代码的解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT：这是一个特定于编译器的注释（directive），用于指示将该函数声明为输出函数（export function），以便其他程序或语言可以调用它。\nIMPLICIT NONE：这是一个编译器指令，用于禁用隐式类型声明。它要求所有变量都必须显式地声明其类型。\nINTEGER a, b, sum：这是变量声明的部分，它指定了a、b和sum都是整数类型的变量。\nsum = a + b：这一行将a和b的值相加，并将结果赋给变量sum。这行代码的作用是计算a和b的和，并将结果存储在sum变量中。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"因此，这段代码定义了一个名为\"OUTPUT\"的子程序，它接受两个整数参数a和b，并计算它们的和，并将结果存储在sum变量中。通过!MS$ ATTRIBUTES DLLEXPORT::OUTPUT的声明，该子程序可以被导出为一个可供其他程序或语言调用的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Fortran通过下句表示dll输出函数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"配置编译器属性，选择64位的编译器来生成64位的dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1) (Image: 1) (Image: 1) (Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"编译文件后生成项目，就可以在.\\x64\\Debug文件夹下找到生成的dll文件","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用VS2013开发人员命令提示查看dll位数","page":"动态链接库(DLL)的生成与调用实操","title":"使用VS2013开发人员命令提示查看dll位数","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"VS2013的工具路径在安装目录下","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":".\\Microsoft Visual Studio 12.0\\Common7\\Tools\\Shortcuts","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"选择VS2013开发人员命令提示，可以使用dumpbit命令获得dll信息","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"dumpbin /headers 路径","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"读取上段生成dll，部分结果：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是更多的参考：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Windows下，可以使用以下方法来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开文件资源管理器（Windows资源管理器）。\n导航到包含所需DLL文件的目录。\n右键单击DLL文件，然后选择\"属性\"。\n在属性对话框中，切换到\"详细信息\"选项卡。\n在\"属性\"部分中，查找\"位数\"或\"架构\"相关的信息。通常会显示为\"32位\"或\"64位\"。\n查看该信息以确定DLL文件的位数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"另外，您还可以使用命令行来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开命令提示符（CMD）或PowerShell。\n使用cd命令导航到包含DLL文件的目录。\n运行以下命令来查看DLL文件的位数：\ndumpbin /headers <DLL文件名>\n将 <DLL文件名> 替换为实际的DLL文件名。\n在输出中查找 \"x86\" 表示32位，\"x64\" 表示64位。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"通过这些方法，您可以方便地查看DLL文件的位数，以确定其兼容性和与其他程序的配合情况。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用C调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用C++调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里采用动态调用方法，根据网上找到的资料和Fortran程序设计课程讲义，我重新整理了C++代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这部分代码把那几个冒号去了就是C的代码（就是说实质是c语言代码）。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"调试或启动exe文件前，请将dll文件放于EXE文件所在的Debug文件夹内。我的是在E:\\Programs\\program VS2013\\HF_first\\ForDllCreat\\x64\\Debug","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我的解决方案名和Fortran生成dll的方案同名了，请不要混淆。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>\n#include <windows.h> // 调用 WINDOWS API 函数所需的头文件\n\ntypedef void(*Func)(int *, int *, int *);//定义一个函数指针类型，这个指针类型与被调用函数的输入类型要一一对应\n\nint main()\n{\n int a = 1, b = 2, sum;\n\n //宏定义函数指针类型\n HMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\"); //加载动态库文件，dll名前不加L会报错\n if (hLibrary == NULL)\n {\n  printf(\"No DLL file exist!\\n\");\n  return -1;\n }\n Func dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");\n //获得 Fortran 导出函数的地址\n if (dllPro == NULL)\n {\n  printf(\"Can not fine the address of the function!\\n\");\n  return -2;\n }\n dllPro(&a, &b, &sum);\n printf(\"%d + %d = %d\\n\", a, b, sum);\n FreeLibrary(hLibrary); //卸载动态库文件\n return 0;\n}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段代码是一个使用C语言调用动态链接库（DLL）中函数的示例代码，其解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>：包含了标准输入输出函数的头文件。\n#include <windows.h>：包含了调用Windows API函数所需的头文件。\ntypedef void(*Func)(int *, int *, int *);：定义了一个函数指针类型Func，该指针类型与被调用函数的输入类型一一对应，即接受三个int型指针作为参数且没有返回值。\nint main()：主函数的入口。\nint a = 1, b = 2, sum;：声明整型变量a、b和sum，并分别初始化a和b的值。\nHMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\");：加载名为\"ForDLLCreat.dll\"的动态库文件。LoadLibrary函数返回一个句柄（HMODULE），用于后续操作。\nif (hLibrary == NULL)：检查动态库文件是否加载成功，如果返回的句柄为空，则说明加载失败，打印错误信息并退出程序。\nFunc dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");：通过GetProcAddress函数获取动态库中名为\"OUTPUT\"的函数的地址，并将其赋给函数指针变量dllPro。\nif (dllPro == NULL)：检查函数地址是否获取成功，如果返回的地址为空，则说明获取失败，打印错误信息并退出程序。\ndllPro(&a, &b, &sum);：通过函数指针调用函数，将a、b和sum的地址作为参数传递给被调用函数。\nprintf(\"%d + %d = %d\\n\", a, b, sum);：打印计算结果。\nFreeLibrary(hLibrary);：卸载动态库文件，释放资源。\nreturn 0;：程序正常结束返回值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"总体而言，该代码加载了一个名为\"ForDLLCreat.dll\"的动态库文件，并通过函数指针调用了其中的\"OUTPUT\"函数，将a和b的值作为输入，计算它们的和并将结果存储在sum中，最后打印出计算结果。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Julia调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Julia调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia官方文档地址：Calling C and Fortran Code","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在开始前，请务必确认Julia的位数与所用dll位数相同，否则会报错dll不是一个可用的Win32应用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ForDllCreate.dll与ForDllCreate.64.dll内部包含和前文相同的函数，区别是前者是32位，后者是64位。 在64位REPL上载入32位dll会报错。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ERROR: LoadError: could not load library \"e:\\yyb\\HF_first\\ForDllCreat.dll\"\n%1 is not a valid Win32 application.\nStacktrace:\n [1] top-level scope\n   @ e:\\yyb\\HF_first\\test.jl:15\nin expression starting at e:\\yyb\\HF_first\\test.jl:15","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"如果你想在Julia中使用ccall函数来调用DLL中的函数，你可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"假设你有一个名为\"example.dll\"的DLL文件，其中包含一个名为\"add_numbers\"的函数，用于将两个整数相加。\n在Julia中，使用ccall函数来加载和调用DLL中的函数。以下是一个示例：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"# 调用ccall函数加载DLL文件\nconst lib = \"example.dll\"\nconst handle = ccall((:LoadLibraryA, lib), Ptr{Cvoid}, (Cstring,), lib)\n\n# 定义要调用的函数的签名\nconst add_numbers = ccall((:add_numbers, lib), Cint, (Cint, Cint))\n\n# 调用函数并获取结果\nresult = add_numbers(5, 3)\nprintln(result)  # 输出 8\n\n# 卸载DLL\nccall((:FreeLibrary, lib), Cint, (Ptr{Cvoid},), handle)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在上面的示例中，我们首先使用ccall函数加载名为\"example.dll\"的DLL文件。通过指定函数名称和DLL文件的句柄，我们可以获取要调用的函数的指针。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"然后，我们定义了一个名为add_numbers的Julia函数，并使用ccall函数将其与DLL中的add_numbers函数关联起来。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们调用add_numbers函数，并将参数5和3传递给它。返回的结果存储在result变量中，并打印到控制台。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们使用ccall函数卸载DLL文件，以释放资源。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，示例中的函数签名和参数类型可能需要根据DLL中的实际函数进行调整。确保使用正确的参数类型和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"使用ccall函数直接调用DLL函数时，需要小心处理内存管理和类型匹配，确保传递正确的参数和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是我们针对自己生成的dll的调用的例子：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#error\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_(a), pointer(b), pointer(c))\nprint(c)\n\n#work\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat64.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_from_objref(a) + 0x40, pointer_from_objref(b) + 0x40, pointer_from_objref(c) + 0x40)\nprint(c)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"解释：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在第一段代码中，使用了名为ForDllCreat.dll的 DLL 文件来执行函数调用。函数名称为OUTPUT，该函数接受三个整型指针作为参数，并将结果存储在指针c指向的位置。通过ccall函数来调用 DLL 中的函数，并传递指针参数。最后打印出指针c所指向的值。\n在第二段代码中，使用了名为ForDllCreat64.dll的 DLL 文件来执行函数调用。其他部分与第一段代码类似，但是在传递指针参数时，对每个指针都进行了偏移，即将指针从对象引用中提取后加上0x40的偏移量。最后同样打印出指针c所指向的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，这段代码中的部分函数和对象引用是特定于编程语言的，并且需要正确配置和具备相应的 DLL 文件才能正常运行。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia可用通过ccall函数调用C和Fortran编译的dll文件，输入格式为","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"  ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n  ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)  \n  ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里通过第一种调用方法来调用我们编译的ForDllCreat64.dll，","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"function_name是调用的函数名称。引用时即可以用:OUTPUT表示，也可以用\"OUTPUT\"表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"C语言与Fortran输出dll时函数名不变，C++输出函数有命名粉碎，自制dll尽量采用C输出，一定要确定被调用函数的名字才能成功引用。可看此视频","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"library是被调用dll的路径，用字符串表示。调用C标准库中的函数时，library可以略去。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#调用C标准库函数，不用写引用\nt = ccall(:clock, Int32, ())","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"returntype是被调函数的返回类型。Fortran的subroutine返回类型是空，即void，在Julia中表示为Cvoid。数据类型对应的表格可以参考下文表格，也可以查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(argtype1, ...)是一个tuple，与被调函数的输入变量类型要一一对应，类似在C++中定义一个与被调函数输入变量类型一一对应的函数原型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"argvalue1, ...  这部分是输入变量，类型要与(argtype1, ...)一一对应，并与被调函数对应。输入变量不用tuple表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"不同语言间调用dll，最重要的就是数据类型的匹配。下表是从Julia官方文档中复制的数据类型对应表。更多细节请查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 图 1)  ","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#更多julia的信息","page":"动态链接库(DLL)的生成与调用实操","title":"更多julia的信息","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中指针的用法 （以下内容暂时不用那么细，先忽略，需用到时查julia的官方文档。）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"数组类型基本上通过指针传递。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中，指针有两种，Ptr{T}与Ref{T}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ptr表示的是从变量获得的地址，这类地址是否被销毁不由Julia管理，一般是“危险的”（unsafe)。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ref是由Julia分配的地址，这类地址的任何更改都由Julia进行，因此是“安全的”。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"但是Ref能用的方法似乎不多，目前为止我没学明白这个怎么用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中获得变量地址的函数有pointer和pointerformobjref，他们获得的指针都是Ptr型的 pointer获得的地址被标明了数据类型，并且总比pointerformobjref的返回值多出一个数据类型的bit数；pointerformobjref获得的地址是无数据类型的。 在官方文档中，pointerfromobjref是对C提供接口的方法(C_Interface)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=\"大家好\"\nb=pointer(a)\nc=pointer_from_objref(a)\nprintln(b)\nprintln(c)\nprintln(b-c)\n\nprintln(\"a[1]的字节数是\",sizeof(typeof(a[1])))#UInt8的字节数是1,但是Char类型的字节数是4","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"由地址获得值的方法是unsafepointerto_objref，这个函数也是官方文档中C接口的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"对一个Ptr指针，用pointer获得的指针要减去一个数据类型的bit数才能获得指针内的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=[1.23]\n\nb=pointer(a)\nc=pointer_from_objref(a)\n\nd=unsafe_pointer_to_objref(b-0x40)\ne=unsafe_pointer_to_objref(c)\n\nprintln(\"d=\",d)\nprintln(\"e=\",e)","category":"page"},{"location":"Tools/CSV_jl_use/#CSV.jl使用简介","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\nContents：CSV文本读入Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"note: Note\nCSV.jl是一个快速灵活的纯 Julia包，用于处理带分隔符的文本文件。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在建立模型与模型计算的过程中，可以很好的解决数据导入问题，它能自动辨识文本数据类型，并将数据分隔。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的应用场景是：使用数据之前的输入导入。","category":"page"},{"location":"Tools/CSV_jl_use/#基本实现","page":"CSV.jl使用简介","title":"基本实现","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3,col4,col5,col6,col7,col8\n,1,1.0,1,one,2019-01-01,2019-01-01T00:00:00,true\n,2,2.0,2,two,2019-01-02,2019-01-02T00:00:00,false\n,3,3.0,3.14,three,2019-01-03,2019-01-03T00:00:00,true","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\") #file为文件名，如\"data.csv\"、\"data.txt\"","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"默认情况下，CSV.File会自动检测这个文件的分隔符','，以及每列的类型。默认情况下，它将“空字段”视为missing（本示例中的整个第一列）。它还自动处理提升类型，例如第 4 列，其中前两个值为Int，但第 3 行具有Float64值 ( 3.14)。","category":"page"},{"location":"Tools/CSV_jl_use/#自定义分隔符","page":"CSV.jl使用简介","title":"自定义分隔符","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1::col2\n1::2\n3::4","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; delim=\"::\")","category":"page"},{"location":"Tools/CSV_jl_use/#无标题情况","page":"CSV.jl使用简介","title":"无标题情况","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在没有标题的情况下，会默认把第一行当作标题，可以给定参数取消，使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=false) #取消标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者也可以手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=[\"col1\", \"col2\", \"col3\"]) #手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/#指定数据行数","page":"CSV.jl使用简介","title":"指定数据行数","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\nmetadata1,metadata2,metadata3\nextra1,extra2,extra3\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"假如我们期望的内容是从第四行开始，可以使用以下代码","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4) #从第四行开始","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; datarow=4)","category":"page"},{"location":"Tools/CSV_jl_use/#读取数据段","page":"CSV.jl使用简介","title":"读取数据段","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"只需要读入某一段数据段","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，limit=1) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，footerskip=1) #从第四行开始,除去最后一行","category":"page"},{"location":"Tools/CSV_jl_use/#转置","page":"CSV.jl使用简介","title":"转置","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,1,2,3\ncol2,4,5,6\ncol3,7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; transpose=true) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/#数据操作","page":"CSV.jl使用简介","title":"数据操作","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"我们以一下文件输入为例：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"data = CSV.File(\"data.txt\") ","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在相当于把数据储存到变量data中了，data是CSV.File类型的数据，可以通过typeof函数来查看一下：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在调用某一列的数字：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"println(data.col1) #显示第一列\nprintln(data.col2) #显示第二列\nprintln(data.col3) #显示第三列","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[1, 4, 7, 10, 13, 16, 19]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[2, 5, 8, 11, 14, 17, 20]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[3, 6, 9, 12, 15, 18, 21]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"查看一列的数据类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data.col1)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"Vector{Int64}","category":"page"},{"location":"Tools/CSV_jl_use/#小结","page":"CSV.jl使用简介","title":"小结","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"可以发现，data是CSV.File类型，但是通过data调用的每一列数据是vector类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"说明可以把每一列当作平常的vector来处理，相关的方法都能够匹配。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"比如：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"sum(data.col1)\na = data.col1 .* data.col2","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\n推荐一个好用的数据展示包DataFrames，它一般与CSV.jl结合起来使用在julia的包模式下安装：add DataFrames将data漂亮的输出，只需要：using DataFrames\ndisplay(DataFrame(data))","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装gcc编译器和CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#编译器和集成开发环境简介","page":"Windows下安装gcc编译器和CLion","title":"编译器和集成开发环境简介","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器和集成开发环境（IDE）是软件开发中常用的工具。下面是对它们的概括介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将源代码转换为可执行文件的工具。它接收编写的源代码作为输入，经过一系列的词法分析、语法分析、语义分析和代码优化等过程，生成可执行的目标代码或者字节码。编译器可以将高级编程语言（如C、C++、Java等）转换为机器码或者中间代码，以便计算机能够执行。\n在Windows系统中，GCC（GNU Compiler Collection）是一个非常流行的编译器套件。它支持多种编程语言，包括C、C++、Java等，并且可以在Windows上进行安装和使用。\n集成开发环境（IDE）： 集成开发环境是为了提供一个集成的开发环境，将编码、调试和构建等开发任务整合到一个界面中。IDE通常包括代码编辑器、编译器、调试器和其他开发工具，旨在提高开发效率。\nCLion是JetBrains开发的一款跨平台C/C++集成开发环境。它提供了代码编辑器、自动完成、调试器等功能，使得C和C++开发更加便捷。CLion还集成了CMake构建系统，可以帮助您轻松管理项目的构建过程。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装msys2、gcc以及CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装msys2、gcc以及CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"在Windows系统下，可以通过以下步骤安装GCC和CLion并使用MSYS2：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"安装MSYS2：\n下载MSYS2安装程序并运行它：https://www.msys2.org/\n按照安装向导的指示完成安装过程。\n安装GCC：\n打开MSYS2 Shell（通过开始菜单中的MSYS2程序组找到）。\n运行以下命令来更新MSYS2软件包管理器：\npacman -Syu\n更新完成后，运行以下命令安装GCC：\npacman -S mingw-w64-x86_64-toolchain\n安装CLion：\n下载CLion安装程序并运行它：https://www.jetbrains.com/clion/\n按照安装向导的指示完成安装过程。\n配置CLion：\n打开CLion，并按照提示进行初始化设置。\n在\"Toolchains\"设置中，选择\"MinGW\"作为编译器，并指定MSYS2的安装路径。\n创建或导入您的项目，并开始编写、调试和构建您的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这样，您就可以在Windows系统下使用GCC和CLion进行C和C++的开发了。希望这些信息对您有所帮助！","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#msys2是什么？","page":"Windows下安装gcc编译器和CLion","title":"msys2是什么？","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行开发时，MSYS2是一个常用的工具，它为Windows用户提供了类似于Unix或Linux环境的开发体验。以下是对MSYS2的补充介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MSYS2（Minimal SYStem 2）是一个开源的软件发布和管理工具，旨在为Windows提供类似于GNU/Linux系统的开发环境。它基于Cygwin（Cygwin是一个在Windows上运行的类Unix环境）并扩展了其功能。MSYS2提供了一组工具和软件包，使开发者能够在Windows上使用常见的开发工具和软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"主要特点和功能：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"软件包管理器：MSYS2使用自己的软件包管理器（称为pacman），它允许您轻松地安装、更新和删除开发所需的各种工具和库。通过pacman，您可以方便地安装GCC、CMake、Python等常用的开发工具和库。\n命令行环境：MSYS2提供了一个命令行界面（称为MSYS2 Shell），类似于Linux终端。它使用Bash作为默认的Shell，并提供了一系列的命令和工具，使得在Windows上进行命令行开发变得更加方便。\nGNU工具链支持：MSYS2提供了一组GNU工具，包括GCC编译器、GNU Make构建工具和其他常用的开发工具。这使得您可以在Windows上使用这些工具进行C、C++和其他编程语言的开发。\n环境隔离：MSYS2提供了一个隔离的环境，使得开发所需的工具和库可以与系统环境相互独立。这意味着您可以使用MSYS2提供的工具链，而不会与系统环境中的工具发生冲突。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MSYS2为Windows用户提供了一个方便和强大的开发环境，使得在Windows上进行跨平台开发变得更加容易。通过安装和使用MSYS2，您可以轻松地获取常用的开发工具和库，并在类Unix的环境下进行命令行开发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#再说说mingw和mingw64","page":"Windows下安装gcc编译器和CLion","title":"再说说mingw和mingw64","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行C和C++开发时，MinGW和MinGW-w64是两个常用的工具集，它们提供了在Windows环境下使用GNU工具链进行编译的能力。以下是对MinGW和MinGW-w64的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MinGW（Minimalist GNU for Windows）： MinGW是一个开源的工具集，旨在为Windows系统提供基于GNU工具的编译能力。它包括了一系列的GNU工具，如GCC编译器、GNU Binutils（包含链接器和汇编器）以及其他辅助工具。MinGW使用Windows API来编写原生Windows应用程序。\nMinGW的目标是提供一种轻量级的方式，在Windows上进行C和C++的编译，生成可在Windows环境下运行的可执行文件。它通过使用MinGW提供的工具链，将C和C++代码编译为与Windows操作系统兼容的可执行文件。\nMinGW-w64： MinGW-w64是MinGW的一个分支，它对原始的MinGW进行了扩展和改进。MinGW-w64的主要目标是支持64位Windows系统，并提供更好的兼容性和功能。\nMinGW-w64继承了MinGW的基本功能，同时添加了对64位Windows系统的支持。它提供了一套完整的工具链，包括GCC编译器、GNU Binutils和其他开发工具，用于在64位Windows系统上进行C和C++的编译和构建。\nMinGW-w64不仅支持64位Windows系统，还可以用于开发32位应用程序。它提供了对多种目标平台和架构的支持，包括x86、x86-64、ARM等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MinGW和MinGW-w64是在Windows系统上进行C和C++开发的工具集，它们提供了GNU工具链，包括GCC编译器和其他辅助工具。MinGW主要用于32位Windows系统，而MinGW-w64扩展了对64位系统的支持，并提供更多功能和兼容性。通过使用MinGW或MinGW-w64，开发者可以在Windows环境下进行C和C++代码的编译和构建。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#也许初学者需要Gcc的介绍","page":"Windows下安装gcc编译器和CLion","title":"也许初学者需要Gcc的介绍","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到C和C++编程时，GCC（GNU Compiler Collection）是一个常用且强大的编译器套件，特别适合初学者。下面是对GCC的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC是由GNU开发的自由软件编译器集合，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和其他一些语言。它被广泛用于各种操作系统和架构上，包括Linux、Windows、macOS等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC的主要特点和优势包括：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"开源自由：GCC是自由软件，具有开源的特性。这意味着您可以自由地使用、修改和分发GCC，无需支付费用。\n跨平台支持：GCC可在多个操作系统上使用，包括Linux、Windows、macOS等。这使得您可以使用相同的编译器在不同的平台上进行开发。\n多语言支持：GCC支持多种编程语言，使得您可以在同一个编译器环境下开发不同语言的程序。特别是对于C和C++开发者来说，GCC提供了广泛的语言功能和标准支持。\n优化能力：GCC具有强大的代码优化能力，可以对生成的机器码进行各种优化，提高程序的执行效率和性能。\n标准兼容性：GCC遵循C和C++的标准规范，并不断更新以支持最新的语言标准。这使得您可以编写符合标准的代码，并享受语言提供的新特性和改进。\n开发工具集成：GCC集成了一系列的开发工具，如调试器（GDB）、性能分析工具（gprof）等，使得开发者能够进行调试和性能优化。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"对于初学者来说，GCC是一个非常有价值的工具，因为它易于获取、使用和学习。您可以通过安装GCC，将C和C++源代码编译为可执行文件，从而开始学习和开发自己的程序。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"请注意，对于Windows系统，您可以使用MSYS2或MinGW-w64来安装和使用GCC。这些工具集提供了在Windows环境下使用GCC的能力，并使得在Windows上进行C和C++开发变得更加便捷。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#GNU好像也必须提一下","page":"Windows下安装gcc编译器和CLion","title":"GNU好像也必须提一下","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到GCC时，确实有必要提及GNU（GNU's Not Unix）项目，因为GCC是GNU项目的一部分。以下是对GNU的简要介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU是一个由理查德·斯托曼（Richard Stallman）发起的自由软件运动，旨在创建一个自由、开放和用户可控的操作系统。GNU项目致力于为用户提供自由软件的选择，使他们能够运行、修改、分发和改进软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU项目不仅包括GCC编译器集合，还涵盖了许多其他重要的软件和工具，如GNU核心工具（包括shell、文本编辑器等）、GNU库（提供通用的功能库）以及GNU操作系统（GNU Hurd）等。这些工具和软件都是自由软件，可以免费使用、修改和分发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU的目标是创建一个完全自由的操作系统，以替代传统的专有操作系统。尽管GNU操作系统的核心（GNU Hurd）目前还没有广泛使用，但许多GNU工具和软件被广泛地集成到各种操作系统中，包括Linux、FreeBSD等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"通过GNU项目，许多重要的开源软件和工具得以发展和推广，为开源社区做出了重要贡献。GCC作为GNU项目的一部分，是其中最受欢迎和广泛使用的组件之一。它提供了强大的编译能力，支持多种编程语言，并在开发者社区中广泛使用。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，GNU是一个自由软件项目，旨在为用户提供自由、开放和用户可控的软件。GCC作为GNU项目的一部分，是一个功能强大且广泛使用的编译器套件，为开发者提供了可靠和高效的编译工具。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","page":"Windows下安装gcc编译器和CLion","title":"最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当进行软件开发时，以下是对编译器、连接器、调试器和集成开发环境（IDE）的概述及其相互关系的补充：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将高级编程语言（如C、C++、Java等）编写的源代码转换为机器可执行代码（二进制文件）的工具。它负责将源代码进行词法分析、语法分析、优化和代码生成等步骤，最终生成可供计算机执行的可执行文件。\n连接器： 连接器（或链接器）是将编译后的目标文件（由编译器生成）和其他所需的库文件合并在一起，形成最终的可执行文件的工具。连接器负责解析和解决代码中的符号引用，将不同模块之间的代码进行链接，并处理动态链接库等外部依赖。\n调试器： 调试器是一种开发工具，用于帮助开发者识别和修复程序中的错误（bug）。它提供了诸如断点设置、变量查看、单步执行等功能，允许开发者逐行或逐语句地执行程序，并检查其状态以进行调试和排除故障。\n集成开发环境（IDE）： 集成开发环境是一个综合的开发工具，集成了编译器、连接器、调试器以及其他辅助开发工具。IDE提供了一个统一的界面，使开发者能够在一个环境中进行代码编写、编译、调试和测试等开发活动。它通常具有代码编辑器、项目管理、自动完成、调试器集成和构建系统等功能。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这些工具之间存在着紧密的关联和相互依赖关系。编译器将源代码转换为目标文件，连接器将目标文件和库文件链接为可执行文件，而调试器允许开发者在执行过程中检查和修改代码。IDE则集成了这些工具，并提供了一个方便的开发环境，使开发者能够在一个界面中进行代码编写、编译、调试和测试等开发活动。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"使用IDE可以极大地提高开发效率，因为它们提供了许多辅助功能，如自动代码完成、语法检查、版本控制集成等。此外，IDE还提供了项目管理和构建系统，使开发者能够更好地组织和管理他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，编译器、连接器、调试器和集成开发环境是软件开发中常用的工具和环境。编译器将源代码转换为可执行文件，","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"连接器将目标文件链接为最终的可执行文件，调试器帮助开发者进行代码调试和故障排除，而IDE集成了这些工具，并提供了一个便捷的开发环境。这些工具相互协作，使开发者能够更轻松地编写、构建和调试他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#视频地址","page":"Windows下安装gcc编译器和CLion","title":"视频地址","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"msys2安装","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"CLion安装及Fortran插件设置","category":"page"},{"location":"Modeling/MTK_tips/#MTK常见问题","page":"MTK常见问题","title":"MTK常见问题","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YYBEmail: 812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_tips/#UndefVarError","page":"MTK常见问题","title":"UndefVarError","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"目前官方在此方面可能有bug，可以关注模型边界条件尝试避开问题","category":"page"},{"location":"Modeling/MTK_tips/#key-not-found","page":"MTK常见问题","title":"key not found","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在structural_simplify后，有些等式条件会自动微分，导致变量数没变，但是方程增加，进而导致模型不平衡","category":"page"},{"location":"Modeling/MTK_tips/#xxx-are-missing-from-variables-map","page":"MTK常见问题","title":"xxx are missing from variables map","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"可能是初值没有设置。建议所有模型均设置初值，动态模型初值直接输入至defaults参数。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"@connector function flowPortNode(; name)\n    #通流元件节点，在热力学节点上包装了体积、质量流量 \n    #如果同时需要标记connect类型，还要赋值，那么一定要括起来\n    #initialValue写作Dict或者数组都可以\n    sts = @variables begin\n        p(t)\n        T(t)\n        (qm(t), [connect = Flow])\n        (rho(t), [connect = Stream])\n        (mu(t), [connect = Stream])\n        (qv(t), [connect = Stream])\n    end\n    initialValue = [\n        p => 1.013e5\n        T => 300\n        qm => 0\n        rho => 1.2\n        mu => 1.819e-5\n        qv => 0\n    ]\n    eqs = [\n        0 ~ stateEquation(p, rho, T)\n        mu ~ 1.819e-5\n        #qm ~ rho * qv\n        qv ~ qm / rho\n    ]\n    ODESystem(eqs, t, sts, []; name=name, defaults=initialValue)\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在生成问题前再统一传入初值。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"u01 = [\n    d_temp => 0\n]\n\na = ModelingToolkit.defaults(sys1)\nfor i in keys(a)\n    global u01\n    u01 = [u01; i => a[i]]\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"该问题的产生原因与DAE问题的求解算法有关。将DAE问题降指数为ODE问题后，模型可能需要更多的初始条件作为输入。","category":"page"},{"location":"Control/MTKMPC/#MTK求解MPC问题","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"tip: Tip\nContents：MTK、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"note: Note\nMPC = Model Predict ControlMTK = ModelingToolkit.jlOptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Control/MTKMPC/#MTK中的ControlSystem","page":"MTK求解MPC问题","title":"MTK中的ControlSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"在ModellingToolkit的Optimal Control中，有关于ControlSystem的描述。但经过实验测试，ControlSystem并不能很好地求解“过程控制量”的值。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"因为MTK使用rungekuttadiscretize（龙格库塔离散）函数将问题离散。问题离散后，传入OptimizationSystem，而OptimizationSystem目前有一个缺陷——不能接受问题的约束。所以，即使用龙格库塔离散离散出控制过程中的多个状态量，在变量没有约束时，优化结果没有意义。（离散的概念在微分方程参数辨识中有提及） 在实例过后，这一点会有清晰的体现。","category":"page"},{"location":"Control/MTKMPC/#MTK中的OptimizationSystem","page":"MTK求解MPC问题","title":"MTK中的OptimizationSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"为了简单起见，手动构建一个MPC优化问题，通过OptimizationSystem来求解。通过构建优化目标方程，调用不同优化器求解该优化问题。那么从控制问题到优化问题这一过程可以看成是手动离散。相当于自己实现了rungekuttadiscretize。构建完优化问题，就可以直接把它推给OptimizationProblem求解，这是可以做到的。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"上述过程的核心就是把控制中的状态量手写出来。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可行的做法是，通过MTK符号建模体系建立优化变量，同时构建Loss方程关于优化变量的符号表达。通过OptimizationSystem生成用符号体系构建的优化问题，把构建的OptimizationSystem推给OptimizationProblem，最后选择合适的求解器求解。","category":"page"},{"location":"Control/MTKMPC/#实例：加热器问题","page":"MTK求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/MTKMPC/#问题描述","page":"MTK求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"而Q(t_i)就是未来一段时间域内，不同时间点上的控制量（控制科学中称为状态量）。通过改变这些值，能够控制温度的走势，这是控制的内涵。若使温度达到一个让人满意的状态（这里是维持在58℃，也可以是使温度线性上升等等），这是最优控制的内涵。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，最优控制或者模型预测控制最根本的数学内涵是优化——多变量优化。这也是为什么能用OptimizationProblem来处理控制问题。","category":"page"},{"location":"Control/MTKMPC/#构建问题","page":"MTK求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/MTKMPC/#优化求解","page":"MTK求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Symbolics,ModelingToolkit,GalacticOptim,Optim\nN = 20\nTout = 18.0\nT0 = 20.0\ndt = 4/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\n@variables u[1:N]\nfor i = 1:N\n    global T = T + (α*(Tout - T) + β*u[i])*dt\n    global Loss += (T - 58.0)^2\nend","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为20个变量。通过一个for循环，就可以迭代求解20个点上的温度值并且构建Loss方程。这里的20个变量，就是控制的核心，通过改变这20个不同时间点上的控制量（加热功率）的值，使得被控量（温度）接近“更好、更快”地接近目标——58℃。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可以看到Loss方程的结果：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"有些许复杂，但在情理之中。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"@named sys = OptimizationSystem(Loss,[u[i] for i in 1:N],[],inequality_constraints=inequ)\nu0 = [u[i] => 1.0 for i in 1:N]\nlb = [0.0 for i in 1:N]\nub = [200.0 for i in 1:N]\nprob = OptimizationProblem(sys,u0,[],lb = lb,ub = ub,grad=true,hess=true)\ns = solve(prob,Optim.LBFGS())","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"然后构建System和OptimizationProblem，给定上下限。这里功率上限设为200，最后求解！","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"结果为：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u: 20-element Vector{Float64}:\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999994\n 199.99999999999991\n 199.9999999999999\n 199.99999999999957\n 199.99999999996504\n  82.18673442597857\n  79.99995550035416\n  80.0000502201614\n  79.99991729083732\n  80.00001272875645\n  80.00004827285969\n  79.99999940246633\n  79.99997217751334","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"应该说是非常理想的。和我们设想的一样。先以最大功率加热到58℃附近，然后迅速将到稳态维持58℃的功率80，这样2s就完成了控制过程，而之前以恒定功率80加热，耗费了20s!","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"从图中可以很容易看出局限性，加热功率先猛加，以最高限度200直接加热到58，然后功率在恒定在80维持恒温58摄氏度。这种直上直下的调节，很显然不那么让人满意。可以想象，假如不给变量设置上下限，那么优化的结果一定是：第一个离散的变量加热功率上万，相当于在一瞬间使用超大且精准的功率把温度加到58摄氏度。第二个往后的状态量为80——维持恒温58摄氏度的加热功率。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"这在数学上是合理的，在实际中却没有意义。所以在控制中一般需要加一些约束，比如加热功率上下限、加热功率变化幅度。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，为了处理约束，可以使用JuMP来做MPC。","category":"page"},{"location":"WorkFlow/DocStructure/#文档（docs）编写方法","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"tip: Tip\nContents：文档编写方法介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/DocStructure/#文档结构","page":"文档（docs）编写方法","title":"文档结构","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"在包的根目录下，都有一个/docs文件夹，里面就是文档的所有内容。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/docs结构如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"docs/\n├── src/\n│   ├── index.md\n│   ├── components/   \n│   │   ├──MTKMPC.md\n│   │   └──...\n│   └── MyApp.jl\n├── build/\n│   ├── index.html\n│   └── ...\n├── .gitignore\n├── Project.toml\n└── make.jl","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/src里包含了文档的内容，即很多markdown文件。对应关系如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"(Image: 图 1)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":".gitignore里的内容是在git提交时忽略的内容。例如/build的内容就会全部忽略。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"Project.toml是julia的环境文件，说明了docs环境中需要用到的包。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl是生成的html页面的主文件。运行make.jl，则生成/build文件夹，在默认浏览器中打开/build/index.html就能看到文档，和网页版的一模一样。本质上也是一样的，Github部署也是部署的它。这是本地版，github提交时，会自动运行make.jl生成然后部署。所以/build不用上传。","category":"page"},{"location":"WorkFlow/DocStructure/#编写方法","page":"文档（docs）编写方法","title":"编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"新添加文档只需要两步操作：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"创建新的文档(.md文件)\n在make.jl中链接文档路径","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl中的page链接了全部文档。 (Image: 图 2)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"图中的\"Modeling\"是子目录，在/src里可看到对应文件夹。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"如果没有在make.jl中链接，就不会在html中显示。没链接等于没写🤣🤣🤣。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"note: Note\n某些库会设计自动链接，如果自动链接了就不需要手动添加了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/#Julia换源(更换国内镜像站)","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"","category":"section"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"tip: Tip\nContents：JuliaPkgContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"打开julia的安装路径，找到文件夹 julia-1.x.x(如1.6.1) 如图","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入该文件夹找到etc","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入etc 再进入一个文件夹，有一个startup.jl","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"这个startup.jl就很方便了，在启动julia的时候，会首先自动运行里面的内容。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"所以，打开它，在里面输入一行","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.pku.edu.cn/julia/\"","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"就像这样 (Image: 在这里插入图片描述) 保存就完事了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV是julia的全局环境变量，能够直接在repl中修改环境变量，但不是永久的。所以放在startup.jl里。这样等价于永久改变了，因为每次启动都会repl自动执行它。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"在repl中输入ENV如下： (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"还有一些其它的比如LOADPATH 和DEPOTPATH等等，这些都是环境变量。更多可以看中文文档 (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"PS: 不换也行，最新版的julia好像能自动选取一个最快的源。","category":"page"},{"location":"WorkFlow/vscodePlugin/#VScode开发环境配置","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"tip: Tip\nContents：VScode插件介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/vscodePlugin/#插件位置","page":"VScode开发环境配置","title":"插件位置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"打开插件面板，并搜索。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 13)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#Julia","page":"VScode开发环境配置","title":"Julia","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Julia官方出的Julia插件","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 1) ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Shift+Enter可以运行单行代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Tab键补全代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"如：","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: )","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"体验和jupyter类似。","category":"page"},{"location":"WorkFlow/vscodePlugin/#Mardown","page":"VScode开发环境配置","title":"Mardown","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"轻量级标记语言，文档编写必备，教程官方。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"推荐这个3个插件，都装。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 11)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"点击预览打开markdown预览。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"右键 可导出PDF文件，很方便。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 6)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#markdown辅助贴图插件","page":"VScode开发环境配置","title":"markdown辅助贴图插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 7)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"设置该扩展的图片粘贴位置，如果是Ai4E的相关开发，文档中图片的路径一般为：/docs/src/assets","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 10)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"随后右键，选择粘贴图片，自动生成markdown的图片插入语法。很方便！","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 9)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#语言插件","page":"VScode开发环境配置","title":"语言插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 12)  ","category":"page"},{"location":"Modeling/WathMTKdo/#MTK的\"前世今生\"","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"tip: Tip\nContents：建模、MTK、SymbolicsContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"note: Note\nMTK = ModelingToolkit.jlSymbolics.jl为MTK依赖的符号计算包ModelingToolkit.jl为基于符号系统的建模工具包。DifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"MTK似乎很强大，本篇介绍MTK在建模中承担的角色。","category":"page"},{"location":"Modeling/WathMTKdo/#模块化思想","page":"MTK的\"前世今生\"","title":"模块化思想","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"首先，我们聊一聊程序设计中的模块化思想。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"个人认为，模块化其实不单单是一种软件设计的思想。毫不夸张地说，模块化也是一种组织与架构的哲学。模块化的含义可以用一个词语概括——各司其职。若是在软件开发中，需要加上一个限定词——精细化。即，精细化的各司其职。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"模块化解决问题的核心在于，把问题分成若干个部分，每个部分由特定的对象完成。当每个对象的任务都完成之后，问题也就解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从软件开发到社会的组织架构，都由模块化的影子。课程的小组合作，每个人负责一个小部分；上市公司分为市场部、研发部、财务部...。那么在程序中，这些模块的“对象”就是函数。每个函数完成各的任务，当全部执行完成之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"例如，有一个变量var。问题是：计算10 * var + var * var + 1的结果。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"对于这样一个问题，我们习惯于直接把表达式输入得到结果：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"result = 10 * var + var * var + 1","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"但采用模块化的思想，不会这么做。模块化会把这个活分给三个函数去做——乘法函数、平方函数、求和函数。当这个三个函数完成了各自的事情之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"function mult(a,b)\n    return a * b\nend\nfunction square(a)\n    return a * a\nend\nfunction sum(a...)\n    s = 0\n    for i in 1:length(a)\n        s += a[i]\n    end\n    return s\nend\nresult = sum(mult(10,var),square(var),1) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"当然，对于这样一个问题非要用模块化思想那是闲的。若是针对一个复杂的系统，没有人能完成所有细节的解决方案，那么模块化思想就会变得尤为重要。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"主要有两个方面的好处：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从自上而下的角度。作为上层的调用者，不需要关心底层函数怎样解决问题。只需要知道，传递什么数据能获得什么结果。这对于复杂问题的解决非常重要。大问题分为几个小问题，小问题再分为更小的问题。作为架构师只需要关心核心部分的拆解即可。这是高效的“各司其职”。\n从自下而上的角度。把问题细分到不能再分，那么其会具有解决任何问题的潜力。什么意思呢？如果把一个表达式作为一个整体求解，这是完全没有问题的。但如果把一个表达式拆解成四则运算分别求解，就如上面的例子。由该问题设计的四则运算函数，对它们进行合理组合能够解决任何一个求解表达式问题。孰高孰低，立见高下。也可以说，模块化后的解决方案具有普适性，解决了复杂问题中的基本共性问题（足够细分的情况下）。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"所以在软件设计领域，有这样一种说法——每一个函数编写时只需要解决一个很小的问题。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK在建模仿真中的角色","page":"MTK的\"前世今生\"","title":"MTK在建模仿真中的角色","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在DifferentialEquations建模方法从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"进一步细分有：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"抽象问题\n符号建模\n模型化简\n生成迭代格式\n迭代求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"毫无疑问，第一步由人来完成。剩下的步骤可以由MTK完成。那么新的问题在于，从2-5是否全由MTK从零开始构建呢？答案是否定的！","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"实际上，在建模仿真这样的大问题中，仍然是模块化的思想。具体的分工如下：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"Symbolics.jl：负责符号运算\nModelingToolkit.jl：负责模型化简，生成迭代格式\nDifferentialEquations.jl：负责求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"ModelingToolkit的核心在于各种System，System作为一种数据结构，本质是存储的是变量以及由变量构成的方程。而变量的定义与方程的定义由Symbolics完成。所以说，Symbolics是符号计算的基石，MTK在Symbolics的基础之上进一步处理方程与变量，处理成DE能够求解的形式，传递给DE计算。最终得到结果。它们三者的关系如图：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/WathMTKdo/#Symbolics实例","page":"MTK的\"前世今生\"","title":"Symbolics实例","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t α σ(..) β[1:2]\n@variables w(..) x(t) y z(t, α, x)\n@variables A[1:5, 1:3] b[1:3]","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"方程定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"using Symbolics\n\n@variables x y;\n@variables A[1:3, 1:3] B[1:3, 1:3];\nx ~ y\nx - y ~ 0\nA ~ B\nA .~ 3x","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"微分运算：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t\nD = Differential(t)\nz = t + t^2\nD(z)\nexpand_derivatives(D(z)) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"化简与符号赋值：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"B = simplify.([t + t^2 + t + t^2  2t + 4t\n               x + y + y + 2t     x^2 - x^2 + y^2])\nsimplify.(substitute.(B, (Dict(x => y^2),)))","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"还有计算雅可比矩阵、函数符号化等等符号计算的内容可查看官方文档。","category":"page"},{"location":"Modeling/WathMTKdo/#小结与启示","page":"MTK的\"前世今生\"","title":"小结与启示","text":"","category":"section"},{"location":"Modeling/WathMTKdo/#启示：文档查询","page":"MTK的\"前世今生\"","title":"启示：文档查询","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从模块化的角度看待MTK，我们就能知道。MTK能做什么与不能做什么。又或者说，遇到了问题，应该找谁。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型一：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号数组应该如何使用与计算？\nRegister如何使用？\n如何批量处理符号？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看Symbolics.jl的文档。因为MTK就是在它的基础上构建的。它不支持的，MTK也没办法使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型二：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"求解的结果如何处理？\n如何确定精度？\nCallback如何使用？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看DifferentialEquations.jl的文档。因为真正的求解工作是DE完成的。solution的结果也从DE中来（MTK会提供关于符号与solution的接口，但DE中solution handling能用的功能，MTK中也一定能用）。","category":"page"},{"location":"Modeling/WathMTKdo/#启示：函数使用","page":"MTK的\"前世今生\"","title":"启示：函数使用","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在MTK文档没有写上的功能，但DE与Symbolics的文档中有。一般而言都能使用。例如，符号数组的矩阵运算，MTK中一定能用（某些特殊功能不一定）。DE中关于Problem类型的一些参数调用，MTK也可以使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"每个包有每个包的特性，包与包之间的依赖关系不是功能的交集，而是功能的并集。底层依赖包的功能在上层调用包一般都能使用。只要有了这一点认识。就能够将SCIML生态的功能充分利用起来。这是贯通的其生态的关键。","category":"page"},{"location":"Simulation/steadyRC/#MTK稳态系统仿真实例","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/steadyRC/#动态与瞬态","page":"MTK稳态系统仿真实例","title":"动态与瞬态","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从内涵来说，稳态问题是动态问题的子集。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"对于稳态动态问题，当微分代数方程中对时间项的微分为0时，则由动态问题过渡为稳态问题。也就是说，稳态问题是动态问题的特殊形式，动态问题是问题的一般形式。微分在实际中代表着“变化”，当该“变化”项为0时，意味着“变化”停止，此时则进入了稳态阶段。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"例如，对于这样一个问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdxdt = 1-xx_0=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从物理演化的角度看，初始时刻，x的变化率为1，x将会不断增大。系统发展到最后，当x增大到1的时候。fracdxdt=0，此时此刻变化就停止了。所以x将进入稳态，即x=1。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这是因为，从物理的角度理解，微分代表一种变化趋势！上述方程的走势如下图，与分析的情况一致。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/#MTK的稳态求解技巧","page":"MTK稳态系统仿真实例","title":"MTK的稳态求解技巧","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"求解以下稳态电路问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"该问题的电路状态是确定值，不随时间而改变。而DE和MTK处理的是关于时间的微分方程，单纯的代数方程无法求解。对于这样稳态问题，应该怎样求解呢？","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这里主要运用一个技巧——设定一个变化为0的量加入到方程中。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"什么意思呢？问题必须含有关于时间微分的微分方程，在这一基础之上，让fracdxdt=0不就实现了一种稳态么?x可以代表任何变量，电阻值、电源电压值、电流源值等等。于是，微分变为一种形式，只是让问题能够被求解器求解，对于问题的内涵并没有任何改变。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction GroundDIFF(; name)\n    @named g = Pin()\n    sts = @variables v(t)\n    D = Differential(t)\n    eqs = [\n        g.v ~ 0,\n        D(v) ~ 0\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantCurrent(; name, I=1.0)\n    @named oneport = OnePort()\n    @unpack i = oneport\n    ps = @parameters I = I\n    # D = Differential(t)\n    eqs = [\n        i ~ I\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\n\n@named resistor1 = Resistor(R=5.0)\n@named resistor2 = Resistor(R=5.0)\n@named resistor3 = Resistor(R=30.0)\n@named resistor4 = Resistor(R=20.0)\n@named Isource = ConstantCurrent()\n@named Vsource1 = ConstantVoltage(V=30.0)\n@named Vsource2 = ConstantVoltage(V=5.0)\n@named ground = GroundDIFF()\n\n\nrc_eqs = [\n    connect(Vsource1.p, resistor1.p)\n    connect(resistor1.n, resistor2.p, Isource.p)\n    connect(resistor2.n, resistor3.p, resistor4.p)\n    connect(resistor4.n, Isource.n, Vsource2.p)\n    connect(Vsource1.n, Vsource2.n, resistor3.n, ground.g)\n]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor1, resistor2, resistor3, resistor4,\n        Isource, Vsource1, Vsource2, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\n\nu0 = [\n    ground.v => 0.0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nobserved(sys)\nplot(sol[resistor4.n.i])\n","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"代码中的关键在于函数GroundDIFF()，这个函数中添加的微分项为电势变化为0，即","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdVdt=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"并且这个V没有任何意义，既不是接地的电势，也没有和电路中的任何变量产生关联。它只是为了让问题能够被求解而存在。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"最后求解的结果为：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"可以看到，求解的结果在时间轴上是不变的。随然问题看似是一个动态问题，本质上其实是稳态。因为其没有任何改变，时间轴上的任何状态与其前后状态都一样。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"思想的核心其实就是——稳态是动态的一个子集，当动态过程中状态不再改变则进入稳态。这里不过是将问题设置为状态不发生变化的动态，其本质就是稳态。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\n稳态电路本质是代数方程组，若加上了微分方程，则变成了微分代数方程组。代码中定义的问题是ODAEProblem而不是ODEProblem。DE只有求解微分代数方程的接口而没有求解代数方程的接口。所以需要构造成微分代数问题。","category":"page"},{"location":"Modeling/MTK_intro/#ModelingToolkit建模方法","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tip: Tip\nContents：建模、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_intro/#符号计算内涵","page":"ModelingToolkit建模方法","title":"符号计算内涵","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"符号计算的内涵很简单，其本质就是处理、简化方程的未知数。例如: (x+y)z = xy + yz 又例如: $\\frac{dy}{dt} = 2t => y = t^2 + C $ 它们本质上都是数学符号的推演，而没有涉及到数字的计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"一般的情况下，可以计算问题都是人为地把计算推演到数字计算的层面，中间的符号推演、化简的过程都不由计算机处理。随着计算机能力的日益强大，以及计算理论的发展。计算机也能开始进行符号计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"例如，(x+y)z = xy + yz就完全能由计算机计算并得到结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK，就是这样一种符号计算包。在DE中，我们构建的是方程（function），通过方程来建立模型。而在MTK中，我们构建的是符号，通过符号建立模型。","category":"page"},{"location":"Modeling/MTK_intro/#MTK符号计算实例","page":"ModelingToolkit建模方法","title":"MTK符号计算实例","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"考虑洛伦兹方程：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t u(t)[1:3]\n@parameters p[1:3]\n\nD = Differential(t)\neqs =[\n    D(u[1]) ~ p[1]*(u[2]-u[1])\n    D(u[2]) ~ u[1]*(p[2]-u[3]) - u[2]\n    D(u[3]) ~ u[1]*u[2] - p[3]*u[3]\n]\n@named Sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"其中：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"t是时间变量\nu是关于时间的依赖变量向量\n参数向量p\n微分符号D\neqs本质是一个描述符号方程的数组","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"@variables定义了符号变量，@parameters p[1:3]定义了参数。方程由ODESystem结构体储存，可以看到其中描述“=”的符号为“~”。这些表明，上述代码在处理符号，这是一套符号描述体系！","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"因为是处理符号时，当然也可以更加具象，将符号定义为xyz","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"由于符号运算的展现形式更加贴近自然语言，我们几乎可以不加处理地建立与原数学方程几乎一样的符号方程描述，这是符号计算的优势之一。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"在明确MTK的系统构建之后，与DifferentialEquations一样，最后需要明确定义的问题以及初值等要素。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"与DE不同是，MTK传值时需要指定具体变量（参数的值）。 最后能得到与DE计算同样的结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)\ntspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())\nusing Plots\nplot(sol, idxs=(x,y,z))","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/#DE与MTK的对比","page":"ModelingToolkit建模方法","title":"DE与MTK的对比","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"同一问题，可用MTK与DE来求解。但它们并不完全等价，异同是客观存在的：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"不同之处：   ModelingToolkit基于符号体系描述问题，等价于在DifferentialEquations问题描述的上层添加了一层符号系统，通过求解符号系统之后，能得到真正的微分方程问题。\n相同之处：   它们最终得到的问题形式是一样的，比如说最终都会生成ODEProblem，也就是说它们可以通过同一个求解器求解。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK凭借着符号计算，在模型建立时会更加方便，更加友好。符号推演功能相当于减轻了模型构造时的工作量，即在数学模型到计算机可计算的模型这个过程中，计算机又往前前进了一步。所以，MTK从某种程度上来说会比DE好用很多。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"从另一个角度来看，DE是MTK的底层求解器，意味着其比MTK更加直接，速度更快。MTK在DE基础之上构建了符号计算系统，其形式与功能上让人惊叹。但要明白的是，这种提供便捷的符号计算系统是要使用资源的，MTK需要花费更多资源去计算、化简符号。好用意味着大量的资源消耗在用户友好方面，效率高意味着资源消耗在真正的问题解决上。这是软件发展过程中始终存在的矛盾。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\n就像Linux与Windows一样。大家在开发环境中都愿意用Windows，但在服务器端都用的是Linux。也像是Python与C之间的矛盾。Python代码易用，但运行效率却远远比不上C代码。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"关于DE与MTK的取舍，根据问题的特性选择即可。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"此外，MTK的符号系统还有更大的妙用，在后面的章节中会逐渐展开。","category":"page"},{"location":"WorkFlow/julia-call-c7fortran/#julia调用dll中的函数","page":"julia调用dll中的函数","title":"julia调用dll中的函数","text":"","category":"section"},{"location":"Tools/CoolProp/#CoolProp使用介绍","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"tip: Tip\nContents：CoolPropContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"note: Note\nCoolProp为开源物性包。 Unitful.jl为计算单位的包","category":"page"},{"location":"Tools/CoolProp/#CoolProp是什么","page":"CoolProp使用介绍","title":"CoolProp是什么","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"这是一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性，对于需要进行工程计算的小伙伴很有帮助！因为使用这个包之后，就可以可以省去大量查表的麻烦！","category":"page"},{"location":"Tools/CoolProp/#Python使用CoolProp","page":"CoolProp使用介绍","title":"Python使用CoolProp","text":"","category":"section"},{"location":"Tools/CoolProp/#.CoolProp安装","page":"CoolProp使用介绍","title":"1.CoolProp安装","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"打开cmd命令行，输入","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"pip install CoolProp","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"即可安装完成 (Image: 图1)","category":"page"},{"location":"Tools/CoolProp/#.-使用示例","page":"CoolProp使用介绍","title":"2. 使用示例","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"import CoolProp.CoolProp as CP\n\na = CP.PropsSI('H','P',1.0E6,'T',500,'Water')\n\n#H代表输出的需要查找的参数，H为焓\n#P为压强，T为温度，第二个和第四个参数就是状态\n#这个例子就是查询1MPa气压与500K的温度下，水蒸气的焓（如果是液体的话就是液体性质）\n\nprint(a)\n","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"查询时，输入任意两个参数，就能够查询第三个参数。 具体的属性为可以看下表","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"状态量 参数名称 单位\n比焓 H J/kg\n比熵 S J/mol/K\n压强 P Pa\n温度 T K\n密度 D kg/m^3","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"更多参数，可以查看官网文档。","category":"page"},{"location":"Tools/CoolProp/#Julia使用Coolprop","page":"CoolProp使用介绍","title":"Julia使用Coolprop","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在2022的2月，Coolprop完成了Julia包的更新。可以直接在Julia中调用，而不需要通过python了！","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using Pkg\nPkg.add(\"CoolProp\")\n\nusing CoolProp\nPropsSI(\"T\", \"P\", 101325.0, \"Q\", 0.0, \"Water\")\n373.1242958476844","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在Julia中支持单位处理包——Unitful","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using CoolProp\nusing Unitful: °C, Pa\n\nPropsSI(\"P\", \"T\", 100°C, \"Q\", 0.0, \"Water\")\n101417.99665788244 Pa","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#MTK非线性参数辨识实例","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"note: Note\nMTK = ModelingToolkit.jlNLP = NonlinearnProblem，非线性问题OptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#参数辨识概念","page":"MTK非线性参数辨识实例","title":"参数辨识概念","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"系统中的参数作为优化变量，找到一组参数，使得通过模型计算结果与实际值误差最小，实际值一般为一系列数值。参数辨识本质为回归问题。数学表达如下：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = f(ab)\nmin (y_real - y)^2","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#实例","page":"MTK非线性参数辨识实例","title":"实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"考虑下面的模型：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"采用生成数据的方法构造真实的数据y_real。 方法为通过模型计算出准确值并加上随机误差。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"因为测试数据集y_real本身即来自模型，同时添加的扰动范围不大，可以认为数据集的内涵就是模型y = ax^2+sin(bx) 接下来构建问题并且求解：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"# 计算损失Loss\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\n\n# 计算方差和，采用均方差亦可\nLoss = sum(errors)\n\n# 构建问题并求解\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1,0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"最后的结果为:","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"u: 2-element Vector{Float64}:\n 1.502064883762093\n 0.7908724806965902","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"和我们的真实值a=15b=08比较接近。 优化成功！","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\n影响优化效果的因素有初值\n生成扰动大小可以尝试修改它们并查看求解效果。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"using ModelingToolkit, OptimizationOptimJL\n\nLoss = 0.0\n#number of samples\nypre = 0\n#y-predict\nx = collect(-1:0.01:1)\nN = length(x)\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\n\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\nLoss = sum(errors)\n\n#Opt\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1, 0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#julia-的-REPL","page":"julia 的 REPL","title":"julia 的 REPL","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"命令 julia 为我们提供了一个简易但足够强大的编程环境。这就是 REPL 环境。REPL就是Read-Eval-Print Loop，就是“读取-求值-输出-循环”，也就是julia跟我们打交道的交互式对话界面。我们启动julia后，面对的就是julia的REPL。像Python、Ruby这类现代的动态编程语言大都具备REPL环境。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Julia 的 REPL 环境非常有用，尤其是在我们进行试验性编程的时候。我们可以在其中试着执行一些代码片段，并在确认无误之后把这些片段在源码文件中组装起来，形成真正的程序。因此，REPL 环境绝对算得上一个优秀的编程学习助手。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia的REPL中共有四种模式，分别是正常（交互）模式、package模式、help模式和shell模式。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（1）help模式","page":"julia 的 REPL","title":"（1）help模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“？”键进入help模式，该模式下可用来查询操作用法。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（2）shell模式","page":"julia 的 REPL","title":"（2）shell模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“;”键进入shell模式，可以在此模式下执行shell命令。linux下是执行shell命令，windows下则是执行对应的命令提示符下的命令。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"因此，可以在该模式下使用如下代码，运行该文件夹下的“.jl”文件：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"julia hello_julia.jl","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以执行如下的代码显示当前目录下的文件列表：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（3）package模式","page":"julia 的 REPL","title":"（3）package模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“]”键进入package模式，在该模式下进行安装包和卸载包的操作。此模式是用来管理程序包的。比如，在该模式下输入add <程序包的名称>就可以安装某个新的程序包。又比如，输入update <程序包的名称>就可以更新某个已安装的程序包。还比如，仅输入up并回车就可以更新所有已安装的程序包。输入rm <程序包的名称>则可以删除某个程序包。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（4）正常（交互）模式","page":"julia 的 REPL","title":"（4）正常（交互）模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在以上三种模式中，按“backspace”键回到正常模式。julia>是 Julia 的 REPL 环境下的提示符。在这种模式下，我们可以输入 Julia 语言的任何表达式，并让它帮我们计算结果。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在正常模式下，我们可以尝试运行一下如下代码看看系统的反应：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"a = 5 * 8; println(a)","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以使用“Pkg”这个包查看安装使用了哪些包，代码如下：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"using Pkg\nPkg.status()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"可以使用以下代码升级安装的库：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Pkg.update()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"使用以下代码查看所在的文件路径，并且切换文件路径","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd()\ncd(\"c:\\\\Users\\\\mingt\\\\Desktop\")","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP非线性参数辨识实例","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、JuMPContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"note: Note\nJuMP = JuMP.jlNLP = NonlinearnProblem，非线性问题JuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP介绍","page":"JuMP非线性参数辨识实例","title":"JuMP介绍","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP是一种特定领域的建模语言，用于嵌入Julia中的数学优化。可以用于解决各类优化问题。JuMP的指南中列出了可用的求解器，以及能够求解问题的类型。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP建模的思路主要分为3步：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"定义求解器\n明确问题\n求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"使用MTK非线性参数辨识实例中的参数优化问题作为求解实例展开介绍","category":"page"},{"location":"Optimization/JuMP参数辨识/#求解实例","page":"JuMP非线性参数辨识实例","title":"求解实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"为了优化下面模型中的参数ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"人为生成数据，","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"##### 生成真实数据 #####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP优化：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"首先，定义求解器：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义求解器 #######\nmodel = Model(Ipopt.Optimizer)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"随后，定义优化变量，在参数辨识问题中，被优化的参数为ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义变量 #######\n@variable(model, para[1:2])","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"其次，构建优化问题的数学表达，需要用@NLexpression生成非线性优化中的中间表达Loss。使用@NLobjective，从Loss中构建最小化优化问题。参数优化问题没有变量约束，也可以说是全局优化问题。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\n@NLobjective、@NLexpression与非线性优化问题有关，在线性优化问题中，使用@expression。不同问题类型使用不同的宏，是JuMP问题构建的特点。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 构建问题 #######\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"最后求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 赋初值 #######\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n###### 求解 #######\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"结果：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"2-element Vector{Float64}:\n 1.4989653389675912\n 0.8133014851045581","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"warning: Warning\n优化的求解器不是万能的，当一个参数辨识问题无法求解时有很多原因，例如：用来描述系统的数学模型不精确上述例子中，优化数据集本身就来自于模型，所以可以肯定数据的本质一定是我们选定的模型。在实际中，面对大量的数据，数学模型准不准确往往是未知的。优化问题较为复杂多变量的复合函数，以及多优化目标的优化问题。在数学上可能有多个局部最优解。有些结果往往不太理想，典型的表现上是不同的初值获得不同的结果。或表现为初值敏感，当初值有微小改变，也能引起结果的巨大不同。面对这些数学上的难点，需要采取一些其它的策略。优化模型或者采取更加强大的求解器......","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"using JuMP, Ipopt\n\n##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\nmodel = Model(Ipopt.Optimizer)\n@variable(model, para[1:2])\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"Control/JuMPMPC/#JuMP求解MPC问题","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"tip: Tip\nContents：JuMP、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"note: Note\nJuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Control/JuMPMPC/#MTK中的OptimizationSystem、ControlSystem","page":"JuMP求解MPC问题","title":"MTK中的OptimizationSystem、ControlSystem","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"通过MTK中的OptimizationSystem、ControlSystem构建MPC问题都是可行的，但是其一个致命的问题是，System会忽略约束！换一句话说，System只接受Loss方程。这是MTK优化体系不完善的地方。那么，Julia中较为成熟的优化包是JuMP、Optim和NLopt。JuMP的集成度比较好，在JuMP中可以根据不同的优化问题使用不同的求解器。所以尝试用JuMP解决。","category":"page"},{"location":"Control/JuMPMPC/#实例：加热器问题","page":"JuMP求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/JuMPMPC/#问题描述","page":"JuMP求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/JuMPMPC/#构建问题","page":"JuMP求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/JuMPMPC/#优化求解","page":"JuMP求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using JuMP,Ipopt\nN = 40\nTout = 18.0\nT0 = 20.0\ndt = 8/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\nmodel = Model(Ipopt.Optimizer)\n@variable(model, 0 <= u[1:N] <= 200)\nfor i in 1:N\n    global T = @expression(model,T + (α*(Tout - T) + β*u[i])*dt)\n    global Loss += @expression(model,(T - 58.0)^2)\nend\nfor i = 1:N-1\n    @constraint(model,-5 <= u[i]-u[i+1] <= 5)\nend\n@objective(model, Min, Loss)\noptimize!(model)\nJuMP.value.(u)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为40个变量。通过一个for循环，就可以迭代求解40个点上的温度值并且构建Loss方程。同时添加约束，约束的物理含义是控制加热器功率的改变幅度不能太大，这里设置为（-5，5）。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"PS：这里的离散方法，对微分方程求解来说实际上是最简单的欧拉法，精度有待提高，后退欧拉法，亚当斯方法，龙格库塔方法等等方法都可以用来构建Loss方程，只不过方程表达式会很复杂。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"最后我们可以看到整个定义的问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"print(model)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"表达式非常复杂，就不放图了。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/JuMPMPC/#调节约束","page":"JuMP求解MPC问题","title":"调节约束","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"结果有些许波动，调一下功率变化的幅度限制，把约束范围调成（-10，10）","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"比刚刚好多了！","category":"page"},{"location":"Tools/vscode_git/#VScode中使用Git","page":"VScode中使用Git","title":"VScode中使用Git","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"tip: Tip\nContents：VScode,GitContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"本篇介绍在vscode中使用git的方法(以码云为例，githup是同样的操作)","category":"page"},{"location":"Tools/vscode_git/#初始化仓库","page":"VScode中使用Git","title":"初始化仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"如图所示，等价于git init","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#生成公钥","page":"VScode中使用Git","title":"生成公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"ssh-keygen -t rsa -C \"xxxxxx@qq.com\"","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一路回车，有y/n则y。在红框中的文件夹中去找公钥文件。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"idrsa是私钥，idrsa.pub是公钥","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"使用公钥私钥匹配就可以免去登录验证","category":"page"},{"location":"Tools/vscode_git/#配置公钥","page":"VScode中使用Git","title":"配置公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"githup与gitee是同样的方式，将id_rsa.pub的乱码复制到下图的地方。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#VScode中添加远程仓库","page":"VScode中使用Git","title":"VScode中添加远程仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"首先复制地址，选ssh","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在框中输入复制过来的ssh地址，点击从URL添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"输入仓库名字，指的是在vscode的仓库名字，随意填 (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#提交与推送","page":"VScode中使用Git","title":"提交与推送","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"先暂存更改","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在...中可以进行一系列操作，本质上就是有一个图形化的git操作界面，","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一般选择拉取自，或推送到","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Modeling/MTK_register/#ModelingToolkit调用外部函数","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_register/#提出问题","page":"ModelingToolkit调用外部函数","title":"提出问题","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"在前面的ModelingToolkit建模方法中提到，符号系统是MTK的基石。那么，如果想加入一个外部函数，应该怎么解决？例如方程：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"f(xy) + x + y = 1","category":"page"},{"location":"Modeling/MTK_register/#解决方案","page":"ModelingToolkit调用外部函数","title":"解决方案","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"把函数的调用符号化——@register_symbolic，一切问题就解决了！","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"也就是说，把函数名称放入符号系统中去。和定义符号变量类型，对相关函数进行声明，声明该函数纳入符号系统，即可完成操作。","category":"page"},{"location":"Modeling/MTK_register/#实例","page":"ModelingToolkit调用外部函数","title":"实例","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"考虑一个简单系统：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"fracdydt  = u(y)  u(y)= leftbeginaligned\n10  y10 \n-10  y geq 100\nendalignedright ","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"这里函数u在编程时，需要用ifelse函数来定义， 也可以用@register_symbolic来注册一个符号函数。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,DifferentialEquations\n@variables t y(t)\nD = Differential(t)\nu(y) = ifelse(y>100.0, -10.0, 10.0)\n\n# u(y) = y>100.0 ? -10.0 : 10.0\n# @register_symbolic u(y)\n\neqs = [\n    D(y) ~ u(y)\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到得到的方程中，u被视为函数，它的参数为y(t)。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"求解问题：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"sys = structural_simplify(sys)\nu0=[y => 50.0]\ntspan = (0.0,20.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到成功求解，并且y在100附近波动。这是我们期望的结果。","category":"page"},{"location":"Modeling/MTK_register/#实例——CoolProp","page":"ModelingToolkit调用外部函数","title":"实例——CoolProp","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"CoolProp一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性。如何在符号系统中使用Coolprop函数调用物性呢？同样，也是使用外部函数，在外部函数中封装物性查询，将函数符号化即可。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"测试问题：在1MPa下，求温度从300K-400K的水蒸气焓值累加和。（虽然这样做很没有意义，但是这是一种测试外部函数的有效并且简单的方法）","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,CoolProp,DifferentialEquations\n@variables t T(t)\nD = Differential(t)\nfunction u(t)\n    PropsSI(\"H\",\"P\",1.0E6,\"T\",t,\"Water\")\nend\n@register_symbolic u(t)\neqs = [\n    D(T) ~ u(t+300.0)\n]\n@named sys = ODESystem(eqs)\nsys = structural_simplify(sys)\nu0=[\n    T => 0.0\n]\ntspan = (0.0,100.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"程序可以运行并且得到了结果，","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"MTK符号运算系统加上外部调用函数符号化，基本上可以解决各类仿真问题。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\n个人观点：从仿真层面来说，MTK具有了作为一个仿真引擎的所有功能。从程序开发层面来说，MTK具备搭建一个巨型系统的潜力。","category":"page"},{"location":"Modeling/DE_intro/#DifferentialEquations建模方法","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nContents：建模、DEContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"note: Note\nDE = DifferentialEquations.jlDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/DE_intro/#浅谈建模内涵","page":"DifferentialEquations建模方法","title":"浅谈建模内涵","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在研究各类系统时（上至电力、能源系统、交通系统，下至RC电路、水利管网系统），当我们需要对系统进行处理时，我们都会一件相同的事情——把系统抽象成我们能够处理的对象！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在这个过程中，大脑在这个过程充当了“解释器”的角色。把实际的问题层层抽象，最后让问题变得可计算。不得不感叹，人类“编译”能力之强大。也许人类在计算速度上远远不及计算机。但在深度与广度层面，远远超过计算机。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从前牛顿等巨人的时代开始，科学家研究的主体内容，主要是是第一步的内容。近40年，计算机科学技术呈爆炸式增长。依托于计算机，社会生产的智能化日益提高。于是基于第2步的问题也发展出许多学科分支，作为科研领域重要的方向之一。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"这是一件很奇妙的事情，巨量1与0的加减运算产生了无穷的能力！就好像神经元虽然简单，只要数量够，也能组合成产生无数想法的大脑！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"言归正传，在第一步中，描述对象的数学形式有微分方程（组）、代数方程（组）、图等等。针对对象进行计算的数学形式有求解方程问题、寻优问题、计算图等等。DifferentialEquations.jl就是处理基于时间微分的微分方程（组）求解软件包！","category":"page"},{"location":"Modeling/DE_intro/#DE使用实例","page":"DifferentialEquations建模方法","title":"DE使用实例","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"现有洛伦兹方程为例：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"微分方程在DifferentialEquations.jl中含有5个要素：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"方程描述\n求解时间域\n初值（边界条件）\n方程参数\n问题类型","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在方程定义中，有4个参数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function lorenz!(du,u,p,t)\n    du[1] = p[1]*(u[2]-u[1])\n    du[2] = u[1]*(p[2]-u[3]) - u[2]\n    du[3] = u[1]*u[2] - p[3]*u[3]\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"du为微分变量向量\nu为变量向量\np为参数\nt为时间变量","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"剩下要素的定义：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p为参数\nu0变量的初始值\ntspan为求解时间域\nprob为通过方法ODEProblem()定义的ODE问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nODEProblem = Ordinary Differential Equations Problem(常微分方程)beginarrayl\nfracd xd t=sigma(y-x) \nfracd yd t=x(rho-z)-y \nfracd zd t=x y-beta z\nendarray除此之外，还有：DAEProblem = Differential Algebraic Equations Problem（微分代数方程）beginalignedfracd y_1d t =-004 y_1+10^4 y_2 y_3 fracd y_2d t =004 y_1-10^4 y_2 y_3-3 * 10^7 y_2^2 1 =y_1+y_2+y_3endalignedDDEProblem = Delay Differential Equations Problem（随机微分）beginaligned\nd x_0 =fracv_01+beta_0left(x_2(t-tau)right)^2left(p_0-q_0right) x_0(t)-d_0 x_0(t) d x_1 =fracv_01+beta_0left(x_2(t-tau)right)^2left(1-p_0+q_0right) x_0(t) +fracv_11+beta_1left(x_2(t-tau)right)^2left(p_1-q_1right) x_1(t)-d_1 x_1(t) d x_2 =fracv_11+beta_1left(x_2(t-tau)right)^2left(1-p_1+q_1right) x_1(t)-d_2 x_2(t)endaligned更多方程种类可查官方文档。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"求解并画图","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"sol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 4)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction lorenz!(du,u,p,t)\n        du[1] = p[1]*(u[2]-u[1])\n        du[2] = u[1]*(p[2]-u[3]) - u[2]\n        du[3] = u[1]*u[2] - p[3]*u[3]\nend\np = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/#DE的Callback特性","page":"DifferentialEquations建模方法","title":"DE的Callback特性","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"Callback的含义为，当系统运行到某个状态时，人为介入改变系统参量的值，随后继续求解。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"下面以弹球系统为例，介绍Callback的用法。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"弹球系统的特点是，当弹球碰到地面时，需要弹起。所以在模拟弹球系统时，需要考虑求解过程中速度的方法变化，这时候就用到callback。碰地的数学的描述为，弹球速度变量变为它的相反数。也就是说当弹球高度x变为0时，速度u需要变成-u。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其数学表达为：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"x = v  v = -g","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"DE问题构建：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function f(du,u,p,t)\n    du[1] = u[2]\n    du[2] = -p\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u1为x，即弹球高度\nu2为v，即弹球速度","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"建立Callback函数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function condition(u,t,integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\nintegrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition,affect!)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"condition为系统调用callback时应该满足的条件，默认为函数返回值为0（false）时的情况。即u[1]=0。 affect!为系统调用callback时的处理动作，这里为将速度变负。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"定义剩余要素并求解，在solve中需要传递callback。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = 9.8\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"可以得到如下结果：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 5)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"如果考虑反弹损失（每次反弹速度损失20%）：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function affect!(integrator)\nintegrator.u[2] = -integrator.u[2]*0.8\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"也能够得到相应的结果，妙啊！！！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\nend\nfunction condition(u, t, integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition, affect!)\nu0 = [50.0, 0.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nDE中有许多特性，例如求解结果的处理（Solution Handle）、回调函数（Callback）等等。更多特性可以在官方文档中查看。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile介绍","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接","page":"make和Makefile介绍","title":"程序的编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接过程","page":"make和Makefile介绍","title":"程序的编译和链接过程","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当编写C语言程序时，需要将源代码转换为可执行程序的过程包括编译和链接两个主要阶段。下面是以GCC编译器为例的程序的编译和链接过程：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"预处理（Preprocessing）： 在编译过程开始之前，预处理器会处理源代码文件（以.c为扩展名）。它执行包括宏展开、头文件包含、条件编译等任务。预处理器会根据包含的头文件和宏定义进行文本替换，生成一个被称为预处理后的源代码文件（通常以.i或.ii为扩展名）。\n编译（Compilation）： 在这一阶段，编译器会将预处理后的源代码文件转换为汇编语言代码文件（以.s为扩展名），即将C语言代码转化为特定机器平台上的汇编指令。编译器负责检查语法错误和类型错误，并进行相应的优化。\n汇编（Assembly）： 汇编器（如GNU as）将汇编语言代码文件转换为目标文件（以.o为扩展名），其中包含了机器指令和数据。目标文件是二进制文件，仍然是机器相关的。\n链接（Linking）： 在链接阶段，链接器（如GNU ld）将目标文件与所需的库文件进行合并，生成最终的可执行程序。链接器解决了符号引用的问题，它将不同目标文件中引用的函数和变量的定义连接在一起，生成一个可执行程序文件。链接器还负责处理库的链接，包括静态库和动态库。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接过程中，可能会涉及两种类型的链接：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"静态链接（Static Linking）： 在静态链接中，链接器会将所有被引用的库文件的代码和数据复制到最终的可执行文件中。这样，可执行文件就包含了所有所需的库的代码，可以独立运行，而不依赖于系统上是否存在相应的库文件。\n动态链接（Dynamic Linking）： 在动态链接中，可执行文件只包含对库函数的引用，而实际的库代码和数据存储在共享库文件中。在程序运行时，操作系统的动态链接器将库文件加载到内存，并将引用与实际地址进行关联，以完成链接。这样可以实现代码的共享，减小可执行文件的大小，并允许共享库的更新和替换。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"GCC编译器将上述过程整合在一起，可以直接将源代码编译成最终的可执行程序。你可以使用GCC命令来进行整个编译和链接过程，例如：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc main.c -o program","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"其中，main.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"是源代码文件，program是生成的可执行程序的名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"了解程序的编译和链接过程对于理解make和makefile的工作原理非常重要，因为make工具主要用于自动化构建过程，根据源代码的变化和依赖关系进行编译和链接。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#分步编译和链接","page":"make和Makefile介绍","title":"分步编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当使用GCC编译器进行程序编译和链接时，可以将编译和链接过程分为两步来演示。我们将使用一个简单的C语言程序来进行示例，包含两个源代码文件：main.c和helper.c。main.c文件包含程序的入口函数，helper.c文件包含一个辅助函数。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"以下是演示编译和链接的步骤：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"编译（Compilation）： 首先，我们使用GCC编译器将每个源代码文件编译为目标文件（.o文件），并生成对应的汇编代码（.s文件）。\n编译main.c文件：\ngcc -c main.c -o main.o\n编译helper.c文件：\ngcc -c helper.c -o helper.o\n这将生成main.o和helper.o两个目标文件。\n链接（Linking）： 接下来，我们使用GCC编译器将目标文件链接在一起，生成最终的可执行程序。\n链接目标文件生成可执行程序：\ngcc main.o helper.o -o program\n这将生成名为program的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"完成上述步骤后，你将得到一个名为program的可执行程序，可以通过执行./program来运行它。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，上述示例中的程序较简单，只包含两个源文件。对于更复杂的项目，可能涉及多个源文件和库文件，并可能需要更复杂的编译和链接规则。在这种情况下，使用make和makefile来自动化构建过程会更加方便和灵活。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#小结一下","page":"make和Makefile介绍","title":"小结一下","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不论是C还是C++，通常我们首先将源文件编译成中间代码文件，Windows下为.obj文件，UNIX下为.o文件，也被称为目标文件（Object File）。这个过程称为编译（compile）。然后，我们将大量的目标文件链接在一起，生成可执行文件，这个过程称为链接（link）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在编译阶段，编译器需要确保语法的正确性以及函数和变量的声明正确。对于后者，通常需要告诉编译器头文件的位置（头文件中应该只包含声明，而定义应放在C/C++文件中）。只要所有语法正确，编译器就能生成中间目标文件。一般来说，每个源文件对应一个中间目标文件（.o文件或.obj文件）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接阶段，主要是链接函数和全局变量。因此，我们可以使用这些中间目标文件（.o文件或.obj文件）来链接我们的应用程序。链接器不关心函数所在的源文件，只关心函数的中间目标文件（Object File）。通常情况下，由于源文件较多，编译生成的中间目标文件也很多，而在链接时需要明确指出中间目标文件的名称，这对编译非常不方便。因此，我们需要将中间目标文件打包。在Windows下，这种打包方式称为“库文件”（Library File），即.lib文件；而在UNIX下，称为Archive File，即.a文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总结一下，源文件首先会生成中间目标文件，然后使用这些中间目标文件生成可执行文件。在编译阶段，编译器只检查程序的语法和函数、变量的声明。如果函数未被声明，编译器会给出警告，但仍可以生成Object File。而在链接阶段，链接器会在所有的Object File中寻找函数的实现。如果找不到，就会报告链接错误（Linker Error）。在VC（Visual C++）下，这种错误通常为Link 2001错误，表示链接器无法找到函数的实现。你需要指定函数的Object File。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile","page":"make和Makefile介绍","title":"make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#为什么需要make和Makefile","page":"make和Makefile介绍","title":"为什么需要make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"如果我们的程序依赖成千上万的源代码，而且分布在不同的目录，我们能不能自动化的进行我们程序的构建？我们修改了某个文件，依赖这个文件的所有文件都应该重新编译，而不依赖它的文件应该不需要重新编译。有没有工具实现这一点？","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然有了。Makefile是一个用于自动化构建过程的文件，它定义了源代码文件的编译规则和依赖关系。尽管Windows的集成开发环境（IDE）通常会为程序员处理这些工作，但了解Makefile对于成为一名优秀和专业的程序员仍然很重要，就像了解HTML标签对于成为一名专业的前端开发人员一样。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"特别是在Unix系统下的软件编译过程中，你不能不自己编写Makefile。会不会编写Makefile从某种程度上反映了一个人是否具备完成大型工程的能力，因为Makefile涉及整个工程的编译规则。在一个工程中，源文件数量众多，按照类型、功能和模块分别存放在多个目录中。Makefile定义了一系列规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至可以执行更复杂的功能操作，因为Makefile就像一个Shell脚本，可以执行操作系统命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile的好处在于实现了\"自动化编译\"。一旦编写完成，只需要运行一个make命令，整个工程将完全自动编译，大大提高了软件开发的效率。make是一个命令工具，用于解释Makefile中的指令。通常情况下，大多数集成开发环境都提供了make命令，例如Delphi的make、Visual C++的nmake，以及Linux下的GNU make。因此，Makefile已成为工程编译的一种常用方法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不同厂商的make工具语法各有不同，但它们的本质都是在处理\"文件依赖性\"。下面将主要介绍GNU make，因为它是应用最广泛、使用最多的make工具，并且符合IEEE 1003.2-1992标准（POSIX.2）。我们将以C/C++源码为基础，涉及一些与C/C++编译相关的知识。关于这方面的内容，请参考相关编译器的文档。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile定义就是依赖关系和生成规则。为什么我们没有采用上文的编译规则。因为Makefile定义的是更广泛的生成规则，例如文件A从它所依赖的文件B如何生成出来，而不仅仅是程序源文件的编译。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#Makefile的一个例子","page":"make和Makefile介绍","title":"Makefile的一个例子","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当涉及到分步编译和链接的过程时，Makefile可以帮助我们自动化这个过程。下面是一个简单的Makefile示例，展示了如何使用Makefile来编译和链接一个简单的C程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"# 定义编译器和编译选项\nCC = gcc\nCFLAGS = -Wall -g\n\n# 定义目标文件和依赖关系\nTARGET = myprogram\nOBJS = main.o utils.o\n\n# 默认目标，即执行make命令时的默认动作\nall: $(TARGET)\n\n# 链接目标文件生成可执行文件\n$(TARGET): $(OBJS)\n\t$(CC) $(CFLAGS) $^ -o $@\n\n# 编译每个源文件生成目标文件\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 清理生成的目标文件和可执行文件\nclean:\n\trm -f $(OBJS) $(TARGET)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在这个示例中，我们定义了以下几个内容：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CC：编译器的名称，这里使用gcc。\nCFLAGS：编译选项，这里使用-Wall和-g，表示开启所有警告并生成调试信息。\nTARGET：目标可执行文件的名称，这里设为myprogram。\nOBJS：目标文件的名称列表，这里包括main.o和utils.o。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile中的规则包括：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"all：默认目标，执行make命令时的默认动作，依赖于TARGET。\n$(TARGET)：链接目标文件生成可执行文件，依赖于OBJS。\n$(OBJS)：编译每个源文件生成目标文件，依赖于对应的.c文件。\n%.o：通配符规则，用于编译每个源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，Makefile还包括了一个清理规则：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"clean：用于删除生成的目标文件和可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要使用这个Makefile，将其保存为名为\"Makefile\"（注意大小写）的文件，并将其与源文件放在同一目录下。然后在命令行中运行make命令即可自动编译和链接程序。如果需要清理生成的文件，可以运行make clean命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请注意，该示例中的Makefile只是一个简单的示例，实际项目中可能需要更复杂的Makefile来处理更多的源文件和依赖关系。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#时间戳是Make和Makefile决定哪些文件需要重新构建的依据","page":"make和Makefile介绍","title":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据之一。Make工具会比较目标文件和依赖文件的时间戳，根据时间戳的差异确定是否需要重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在Makefile中，每个目标都有一组依赖文件，表示生成该目标所需要的源文件或其他中间文件。当执行make命令时，Make会检查目标文件和依赖文件的时间戳，如果依赖文件的时间戳比目标文件的时间戳更新，或者目标文件不存在，那么Make就会执行相应的规则重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过比较时间戳，Make可以避免无需重新构建的部分，从而提高编译的效率。只有在源文件或依赖文件发生了变化，或者目标文件不存在时，Make才会重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，时间戳并不是唯一的依据，Make还会根据文件的依赖关系、规则和命令等进行判断。但时间戳是其中一个重要的判断因素，用于确定哪些文件需要重新构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make的一些变种","page":"make和Makefile介绍","title":"make的一些变种","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"除了传统的Makefile，还有一些Makefile的变种工具，每个工具都有自己的特点和使用场景。下面是一些常见的Makefile变种工具：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"QMake：QMake是Qt框架提供的一个构建工具。它使用一种简化的语法来描述项目的构建过程，并能够自动生成传统Makefile。QMake主要用于Qt项目的构建，可以跨平台使用。\nNMake：NMake是微软提供的用于Windows平台的构建工具。它使用一种类似于Makefile的语法，并支持Windows平台上的命令和工具。NMake通常与Microsoft Visual Studio一起使用，用于构建Windows平台上的C/C++项目。\nWmake：WMake是OpenFOAM（开源计算流体力学软件）项目中自定义的构建工具，用于管理和构建OpenFOAM的源代码和应用程序。OpenFOAM是一个开源的数值计算软件库，用于模拟流体动力学问题。\nCMake：CMake是一个跨平台的构建工具，它可以生成不同平台上的原生构建脚本（如Makefile、Visual Studio项目等）。CMake使用一种类似于脚本的语法描述项目的构建过程，并具有很高的可移植性和灵活性。CMake广泛应用于C/C++项目的构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这些变种工具都是为了简化和自动化项目的构建过程，并提供特定平台或框架的支持。根据项目的需求和开发环境的不同，可以选择合适的构建工具来管理和构建项目。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#关于cmake再多说一点","page":"make和Makefile介绍","title":"关于cmake再多说一点","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMake是一个跨平台的开源构建工具，用于管理和自动生成用于构建项目的原生构建脚本，例如Makefile、Visual Studio项目等。它旨在简化跨平台项目的构建过程，提供高度可移植性和灵活性。CMake使用一种名为CMakeLists.txt的文本文件来描述项目的构建规则。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt是CMake的配置文件，其中包含了项目的构建规则和指令。下面是一个简单的CMakeLists.txt示例：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"cmake_minimum_required(VERSION 3.12)  # 指定所需的最低CMake版本\n\nproject(MyProject)  # 设置项目名称\n\n# 添加源文件\nset(SOURCES\n    src/main.cpp\n    src/foo.cpp\n    src/bar.cpp\n)\n\n# 添加可执行目标\nadd_executable(myapp ${SOURCES})\n\n# 添加头文件搜索路径\ninclude_directories(include)\n\n# 添加链接库\ntarget_link_libraries(myapp mylib)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在CMakeLists.txt中，首先使用cmake_minimum_required指令指定所需的最低CMake版本。然后使用project指令设置项目名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，通过使用set指令定义一个变量（这里是SOURCES），用于存储源文件的路径。可以根据项目的实际情况添加更多的源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用add_executable指令创建一个可执行目标，将变量SOURCES中的源文件编译为可执行文件（这里是myapp）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用include_directories指令添加头文件搜索路径，以便编译器能够找到所需的头文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，使用target_link_libraries指令添加链接库（这里是mylib）到目标可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt还支持其他各种指令和选项，可以根据项目的需求进行配置。CMake具有丰富的文档和社区支持，可以更深入地了解其功能和用法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要构建项目，可以在命令行中使用CMake来生成适用于特定构建系统的构建文件（例如Makefile或Visual Studio项目），然后使用生成的构建文件来进行编译和构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总的来说，CMake提供了一种简洁而强大的方式来管理项目的构建过程，使得在不同平台和构建系统上的项目构建变得更加灵活和可维护。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"注意：CMake可以根据CMakeLists.txt生成Makefile或者Visual studio的项目文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"关于make和Makefile可以参考这里获得更多的信息。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#以CoolProp为例的实操","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#引言","page":"以CoolProp为例的实操","title":"引言","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"热力学图表是所有能动学生都会要用到的工具。通常是在学习工程热力学时发的热力学图表。图表主要是用来查水的物性，焓、熵等。水会发生相变。热力学图表的知识参考工程热力学教材。现在学生们都用纸本的，远远落后于时代。我们要是能做个网页，可以在网页上查看不同的图多酷啊，要是还能导出相应的数值就更好了，而且提供api调用就完美了。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"理解从背后计算到前台漂亮的页面是如何实现的，这是我们此篇文档的目的。至于物性到底如何计算，那则是能动学院科研工作之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp是什么","page":"以CoolProp为例的实操","title":"RefProp是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一个流体物性计算程序，用于计算和估算各种流体的热力学和传输性质。它由美国国家标准技术研究所（NIST）开发，旨在提供精确和可靠的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 可以计算多种流体的性质，包括气体、液体和超临界流体。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。这些性质对于工程领域中的设计和分析非常重要，特别是在化学工程、能源系统和制冷空调等领域。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 使用的基础是经过验证和广泛接受的热力学模型和实验数据。它包含了大量的流体物性数据，可以用于估算各种温度、压力和组分条件下的性质。用户可以通过输入流体的组分、温度和压力等参数，获得所需的物性计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 还提供了一个用户友好的界面，使用户能够轻松地进行输入和输出。它支持多种编程语言，如Fortran、C++、Python等，可以与其他软件和模拟工具集成使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"需要注意的是，Refprop 是一款商业软件，需要购买和许可才能使用。NIST 提供了关于 Refprop 的详细文档和支持，帮助用户正确使用和理解软件的功能和限制。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总而言之，Refprop 是一款流体物性计算程序，可用于计算和估算各种流体的热力学和传输性质。它是工程领域中重要的工具，用于设计和分析化学工程、能源系统和制冷空调等领域的应用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#CoolProp又是什么","page":"以CoolProp为例的实操","title":"CoolProp又是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 是一个开源的流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它由一组开发者在多个国家合作开发，旨在提供高精度、可靠且易于使用的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"与 Refprop 不同，CoolProp 是一个免费的开源软件，可以在各种操作系统上使用，包括 Windows、Linux 和 macOS。它支持多种编程语言，如Python、C++、Matlab 等，可以与其他软件和模拟工具进行集成。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 提供了广泛的流体物性计算功能，可以计算包括气体、液体、超临界流体在内的多种流体的性质。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。除了常见的单组分流体，CoolProp 还支持混合物和多组分流体的计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的优势之一是它提供了多种流体物性模型和方程式，以适应不同流体和应用的需求。它包括了广泛验证的热力学模型和实验数据，以提供准确的计算结果。此外，CoolProp 还提供了适用于不同工程领域的专用函数和接口，简化了复杂流体系统的建模和分析过程。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的开源特性使得用户可以自由地使用、修改和分享代码。同时，它也有一个活跃的社区，用户可以通过论坛和邮件列表获取支持和交流。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总结起来，CoolProp 是一个免费的开源流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它提供了广泛的计算功能和模型选择，并支持多种编程语言和操作系统。CoolProp 在工程领域中被广泛应用于化学工程、能源系统、制冷空调等领域的设计和分析。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#Step-by-Step","page":"以CoolProp为例的实操","title":"Step by Step","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"找本工程热力学书看一看，找一本热力学图表看一看，理解一下热力学图表。\n看一看这里, 看看网页形式如何呈现。\n看一看CoolProp的在线接口https://ibell.pythonanywhere.com/， 了解如何通过网页查取相应的数据。\n编译RefProp，生成相应的dll。（此篇覆盖）\n使用julia安装一下CoolProp，使用一下其julia界面。（此篇不覆盖）\n使用http.jl把coolprop封装成一个服务。（此篇不覆盖）\n用JavaScript做个前端页面。（此篇不覆盖）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#编译RefProp生成dll","page":"以CoolProp为例的实操","title":"编译RefProp生成dll","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#获取RefProp安装包","page":"以CoolProp为例的实操","title":"获取RefProp安装包","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"获取RefProp的安装包。（通过baidu搜索）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一款商业软件，需要购买和许可才能获取安装包。您可以通过以下步骤获取 Refprop 的安装包：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"访问美国国家标准技术研究所（NIST）的网站：https://www.nist.gov/srd/refprop\n在 NIST 网站上，您可以找到关于 Refprop 的详细信息和文档。阅读相关信息，了解软件的功能、价格和许可方式。\n在 NIST 网站上选择 \"Order Refprop\" 或类似的选项，该选项将引导您到购买页面。\n根据您的需求选择合适的许可类型（例如个人、教育或商业许可）和版本（例如 Windows 或 Linux），然后点击 \"Add to Cart\"（添加到购物车）。\n跟随购买流程，提供所需的信息，并完成支付。购买后，您将收到许可证和相关的安装文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，购买 Refprop 是需要支付费用的，具体费用和许可方式可能因版本和许可类型而有所不同。建议在购买前仔细阅读 NIST 网站上的相关信息，确保了解软件的使用限制和许可条款。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您需要更详细的购买指南或有其他问题，建议直接与 NIST 或 Refprop 的官方联系，以获取准确的购买信息和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#安装RefProp","page":"以CoolProp为例的实操","title":"安装RefProp","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装 Refprop 需要购买该商业软件并获得许可证。一旦您购买了 Refprop 的许可证，并收到了安装文件，可以按照以下步骤安装 Refprop：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"下载安装文件：从获得许可证的来源（通常是 NIST）下载 Refprop 的安装文件。确保下载与您的操作系统兼容的版本。\n解压安装文件：将下载的安装文件解压缩到您选择的目标位置。这将创建一个包含 Refprop 安装所需文件的文件夹。\n运行安装程序：进入解压后的文件夹，并找到安装程序。根据您的操作系统，可能是一个可执行文件（.exe）或脚本文件。双击运行该程序。\n跟随安装向导：安装程序会启动一个安装向导，引导您完成安装过程。按照屏幕上的指示逐步进行，选择安装选项、目标文件夹和其他配置选项。\n完成安装：安装程序将复制所需的文件并配置系统设置。完成安装后，您将收到安装成功的确认消息。\n激活许可证：根据您的许可证要求，可能需要在安装过程中或安装完成后激活许可证。按照提供的指南和说明进行操作，确保许可证被正确激活。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop 是一款专业的流体物性计算软件，使用前需要购买合法的许可证。确保遵守相关许可协议和使用条款。如果您在安装过程中遇到问题或需要更多支持，请联系 Refprop 的官方渠道或与购买许可证的机构进行联系。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp如何使用？","page":"以CoolProp为例的实操","title":"RefProp如何使用？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop提供了基于图形用户界面（GUI）的安装程序，用于在Windows系统上使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"以下是使用Refprop GUI界面的一般步骤：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装Refprop：按照之前提到的步骤购买和安装Refprop软件。确保您选择了适合您操作系统的版本。\n启动Refprop GUI：安装完成后，在您的计算机上找到Refprop安装目录。在该目录中，您应该能够找到一个可执行文件（.exe），通常命名为Refprop.exe。双击运行该文件以启动Refprop GUI。\n导入或输入数据：在Refprop GUI中，您可以通过导入数据文件或手动输入数据来定义要计算的流体和条件。根据Refprop的界面设计，提供相关的输入框、下拉菜单和按钮等，以便您输入组分、温度、压力等参数。\n运行计算：配置完输入数据后，通过点击运行按钮或相关选项启动计算。Refprop将使用您提供的输入数据进行流体物性计算。\n查看和分析结果：一旦计算完成，Refprop GUI将提供计算结果的可视化和分析选项。您可以查看计算得到的物性数据、图表或其他结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop GUI的界面和操作方式可能会因不同版本和更新而有所不同。确保参考Refprop的文档、帮助文件或相关指南，以了解如何使用特定版本的GUI界面。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您在使用Refprop GUI过程中遇到任何问题，我建议您查阅Refprop的文档、联系Refprop的支持团队或查找相关的用户社区和论坛，以获取更详细的指导和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编程语言调用接口","page":"以CoolProp为例的实操","title":"RefProp的编程语言调用接口","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 提供了几种编程语言的调用接口，使开发者能够在自己的程序中集成和调用 Refprop 的功能。以下是一些常用的编程语言调用接口：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"C/C++ 接口：Refprop 提供了 C/C++ 的接口，允许开发者使用 C/C++ 语言调用 Refprop 的函数和子程序。这种接口允许直接的编程访问和控制 Refprop 的计算过程。\nFortran 接口：Refprop 还提供了 Fortran 的接口，允许开发者使用 Fortran 语言调用 Refprop 的子程序。这个接口与 Fortran 语言的特性和调用约定相匹配，方便 Fortran 开发者集成 Refprop。\nMATLAB 接口：Refprop 还提供了用于 MATLAB 的接口。这个接口允许 MATLAB 用户在 MATLAB 环境中直接调用 Refprop 的函数和计算物性。\nPython 接口：Refprop 提供了用于 Python 的接口，允许开发者使用 Python 调用 Refprop。这个接口使用了 Python 的 C API，并提供了 Pythonic 的接口风格，方便 Python 开发者进行流体物性计算。\nExcel 接口：Refprop 还提供了用于 Excel 的接口，使用户能够在 Excel 中使用自定义的函数和公式来调用 Refprop 进行计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这些接口提供了调用 Refprop 功能的便捷方式，使开发者能够在自己的程序中利用 Refprop 的流体物性计算能力。通过使用这些接口，开发者可以按照自己的需要调用 Refprop 的函数，传递输入参数并获取计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"具体使用每种编程语言的接口时，需要参考 Refprop 的官方文档和相关的编程指南，以了解接口的具体用法和调用方法。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，不同的编程语言接口可能有所不同，并且在使用这些接口之前，您需要确保正确配置和连接 Refprop 的库和头文件，并遵循相应的调用约定和接口规范。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编译","page":"以CoolProp为例的实操","title":"RefProp的编译","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"官方的说明在这里。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们进入REFPROP安装目录，可以看到有个FORTRAN文件夹， 这里就是RefProp的源代码。看到有个REFPROP.EXE，这就是RefProp的可执行文件。还有个refprop.dll，这就是计算内核，是一个动态链接库。还有个REFPRP64.DLL是64位的动态链接库。我们编译RefProp就是从fortran源文件生成这个dll。至于想学它的fortran代码是如何写的，可以打开FORTRAN 文件夹中的文件，研究一下。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"RefProp的编译流程如下：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"克隆 REFPROP-cmake 仓库：通过执行以下命令来克隆 REFPROP-cmake 仓库到本地：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"git clone --recursive https://github.com/usnistgov/REFPROP-cmake.git","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"复制 REFPROP 安装目录下的 FORTRAN 文件夹：将 REFPROP 安装目录下的 FORTRAN 文件夹复制到克隆的代码库的根目录中。\n打开命令行终端：在克隆的代码库根目录下打开命令行终端。\n创建 build 目录：执行以下命令创建一个名为 build 的目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"mkdir build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"进入 build 目录：执行以下命令进入 build 目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cd build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"配置 CMake 构建系统：执行以下命令配置 CMake 构建系统：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake .. -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将使用 Release 模式配置 CMake 构建系统，生成 Release 版本的库。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"构建 RefProp：执行以下命令开始构建 RefProp 库：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake --build .","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将根据 CMake 配置文件开始构建 RefProp，并生成相应的库文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"完成上述步骤后，将生成的共享库文件放置在操作系统能够找到的位置。在 Windows 上，可以将库文件添加到 PATH 环境变量中。在 macOS 上，可以放置在默认的共享库位置之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，在不同的操作系统上可能会有一些特定的配置步骤和注意事项。如果遇到问题，建议查阅 RefProp 的官方文档和相关的编译指南，以获取更详细的指导和解决方案。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#到底如何调用呢？","page":"以CoolProp为例的实操","title":"到底如何调用呢？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们写的文档已经说过了如何调用dll，这个问题逻辑上已经解决。而且RefProp官方提供了不同的语言调用的例子。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"再说一次，参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#最后再多说一句","page":"以CoolProp为例的实操","title":"最后再多说一句","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们发现好多东西都在github上啊。请自行学习github是啥，如何使用。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#Windows的命令提示符简介","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/#命令提示符初接触","page":"Windows的命令提示符简介","title":"命令提示符初接触","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"很多同学计算机方面一上来接触的就是Windows系统，很容易认为计算机就是拿鼠标点点点。即使学了编程入门的一些课程（如C语言、Fortran语言等），也只是在集成开发环境（IDE，Integrated Development Environment）上点点鼠标，难以理解系统是如何工作的。那我们就非常简要的介绍一下命令行界面（Command Line Interface，CLI）和图形用户界面（Graphical User Interface，GUI）。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们刚接触计算机那会儿，微软的操作系统还是DOS系统，就是命令行界面。就是要做什么事都通过打一条命令告诉电脑。后来微软进一步开发了图形用户界面系统（Windows），此时看起来就很友好，并且很多事情可以通过鼠标点击来完成。实际上，Windows系统保留了对命令行界面的兼容，可以在开始菜单找到命令提示符（本质就是cmd.exe）。我们打开命令提示行程序，可以看到它长这样：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"(Image: 图 1)","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们可以在这个界面里头输入dir回车，就会显示当前目录下的内容列表。我们可以用cd切换目录。我们可以用copy进行文件复制。具体这些都是DOS的基本命令，可以查看相应的手册获得更多的认识。在DOS时代，我们会区分内部命令和外部命令。内部命令常驻内存，而外部命令是一条单独的可执行文件。这样说来可能有点抽象。我们可以以一个例子来说明。我们平时使用的浏览器如Edge, 它本质是一个命令msedge.exe，这是一个文件提供的，在我的系统里是\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"。这可以认为是一个外部命令。而之前提到的dir、cd等可以认为是内部命令，就是有命令提示符自己就提供了的。那我们的外部写的程序实际上都可以通过命令行启动。如上面提到的msedge.exe，我们在命令提示符下输入msedge.exe回车。系统会提示找不到'msedge.exe'不是内部或外部命令。这是因为系统找不到msedge.exe这个文件。那我们可以给全路径，输入C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe 这个来定位，这里因为路径中有空格，我们再使用\"\"把它包起来，输入\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"回车就启动了Edge浏览器。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们的桌面上或者开始菜单里头有很多的快捷方式，供我们点它的时候启动对应的程序。实际上我们在这些快捷方式上右键，选择属性，在“目标”那里就可以看到具体的启动命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#CMD简介","page":"Windows的命令提示符简介","title":"CMD简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"Windows 的命令提示符（Command Prompt，简称 CMD）是一种在 Windows 操作系统上使用的命令行界面。它允许用户通过键入特定命令来与计算机进行交互和执行各种任务。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"CMD 提供了一种以文本形式输入和执行命令的方式，可以控制文件和文件夹的操作，管理系统设置，运行脚本和程序等。下面是一些 CMD 命令的常见用途和示例：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"目录操作：\ncd：改变当前目录。例如，cd Documents 将当前目录更改为 \"Documents\"。\ndir：列出当前目录中的文件和文件夹。\nmkdir：创建新文件夹。例如，mkdir MyFolder 将创建名为 \"MyFolder\" 的文件夹。\n文件操作：\ncopy：复制文件。例如，copy file1.txt file2.txt 将文件 \"file1.txt\" 复制到 \"file2.txt\"。\ndel：删除文件。例如，del file.txt 将删除名为 \"file.txt\" 的文件。\nrename：重命名文件。例如，rename old.txt new.txt 将文件名从 \"old.txt\" 改为 \"new.txt\"。\n系统信息：\nsysteminfo：显示关于计算机系统的详细信息，如操作系统版本、安装日期等。\nipconfig：显示网络配置信息，如 IP 地址、子网掩码等。\ntasklist：列出当前正在运行的进程。\n网络操作：\nping：测试与特定 IP 地址的连接。例如，ping www.example.com 将向 \"www.example.com\" 发送网络请求并显示响应时间。\ntracert：跟踪数据包的路径，显示从源到目的地经过的网络节点。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"这只是 CMD 命令的一小部分，还有许多其他命令可用于不同的任务。您可以在命令提示符窗口中键入 help 或 /? 来获取关于特定命令的更多帮助信息。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请记住，在使用 CMD 时要小心，确保您了解您要执行的命令的含义和影响，以免意外删除或更改了重要文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何进入CMD","page":"Windows的命令提示符简介","title":"如何进入CMD","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"您可以按照以下步骤在 Windows 中进入 CMD（命令提示符）：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"打开开始菜单：单击桌面左下角的 Windows 图标或按下键盘上的 Windows 键。\n打开 CMD：在开始菜单的搜索栏中，键入 \"cmd\"（不包括引号）。\nWindows 10 及更高版本：在搜索结果中，点击 \"命令提示符\" 或 \"Command Prompt\"。\nWindows 8 和 8.1：在开始菜单中，直接输入 \"cmd\"，然后点击 \"命令提示符\"。\nWindows 7：在开始菜单中，点击 \"所有程序\"，找到 \"附件\" 文件夹，然后点击 \"命令提示符\"。\n运行 CMD：点击打开的 \"命令提示符\" 程序，将打开一个新的命令提示符窗口。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"另外，还有一种快捷方式是使用键盘快捷键：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"cmd\"（不包括引号）并按下回车键。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"无论您使用哪种方式，都将打开一个命令提示符窗口，您可以在其中输入和执行各种命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#快捷方式与命令行启动程序的关系","page":"Windows的命令提示符简介","title":"快捷方式与命令行启动程序的关系","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式和命令行启动程序是两种不同的方式来打开应用程序或执行命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式是一个指向特定应用程序或文件的快速访问方式。它通常是一个图标，您可以在桌面、开始菜单、任务栏或文件夹中找到。通过点击快捷方式，您可以快速启动相应的应用程序或打开文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令行启动程序是通过在命令提示符（CMD）或终端窗口中输入特定命令来启动应用程序或执行命令的过程。通过在命令提示符中键入应用程序的可执行文件的路径和参数，您可以直接启动应用程序，而无需依赖图形界面中的快捷方式。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"虽然快捷方式提供了一种图形化的、可视化的方式来打开应用程序，但命令行启动程序提供了更灵活和精确的控制。通过命令行，您可以指定特定的参数、选项和路径，从而自定义应用程序的行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"例如，在快捷方式上，您可以单击图标来启动文本编辑器应用程序并打开一个文件。而通过命令行，您可以在命令提示符中输入编辑器的可执行文件路径以及文件的路径和名称，实现同样的效果。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"总而言之，快捷方式提供了一种直观、可视化的方式来访问应用程序，而命令行启动程序则提供了一种更直接、可自定义的方式来控制应用程序的启动和行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何查看快捷方式的实质？","page":"Windows的命令提示符简介","title":"如何查看快捷方式的实质？","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"要查看快捷方式的实质（即指向的目标），您可以执行以下步骤：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"找到要查看的快捷方式。它可能位于桌面、开始菜单、任务栏或文件夹中。\n右键单击该快捷方式，然后从弹出菜单中选择 \"属性\"（或类似的选项）。这将打开快捷方式属性对话框。\n在属性对话框的 \"快捷方式\" 选项卡中，您将看到一些关于该快捷方式的信息。\n\"目标\" 字段显示了快捷方式指向的实际目标文件或应用程序的路径。例如，对于一个指向 \"C:\\Program Files\\Example\\app.exe\" 的快捷方式，\"目标\" 字段将显示该路径。\n\"起始位置\" 字段指示快捷方式所在的文件夹路径。\n\"快捷键\" 字段显示了为快捷方式设置的热键组合（如果有的话）。\n\"运行\" 字段允许您选择以何种方式运行该快捷方式，如普通窗口、最大化、最小化等。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"通过查看 \"目标\" 字段，您可以确定快捷方式实际指向的文件或应用程序的位置。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请注意，某些快捷方式可能指向其他快捷方式，而不是直接指向目标文件。在这种情况下，您可以重复上述步骤来查看目标快捷方式的属性，直到找到最终的目标文件或应用程序。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"此外，您还可以直接右键单击快捷方式，然后选择 \"打开文件位置\" 或类似的选项，以在资源管理器中打开快捷方式所在的文件夹。从文件夹中，您可以进一步探索目标文件或应用程序的位置和属性。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#视频地址","page":"Windows的命令提示符简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令提示符和环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境变量简介","page":"环境变量简介","title":"环境变量简介","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/#环境变量初接触","page":"环境变量简介","title":"环境变量初接触","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们都听过环境、环境变量等等名词。那么，它的本质到底是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/#命名","page":"环境变量简介","title":"命名","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"假设现在有一个程序对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"akdhihei","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你知道这是个什么高级语法吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"对的，这就是我胡乱打的，我也不知道它是什么。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么再看一个对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"path","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这可能就有些熟悉了，配置过环境的同学都知道，path是我们的环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"再看：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a又是什么呢？与上面的path类比，那么a就是一个变量呗！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个变量有什么含义吗？没有！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在再反问，上面的path有意义吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能说：有！它是环境变量！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"但是上面那个path是谁的环境变量，它又指向了谁！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能有一点点明白了！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这些变量：akdhihei、path、a他们都是变量，本质可以说是容器可以存放值，也可以说是一个程序的对象，它本身没有意义！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"它就是一个名称罢了，我们称之为命名。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境","page":"环境变量简介","title":"环境","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，怎样才能让命名有意义呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"没错，就是给他赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"也可以说，没有值的变量并没有存在的意义","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"（你是不是联想到了，你写Python，Java的时候，当你没有使用某个变量，没有赋值，只是定义的时候，编辑器会有小波浪，向你提出warnings！）","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"现在你应该明白了，定而不用，就是没有意义，没有价值，浪费内存资源。因为这个内存（地址）就被占了。用一句话概括就是，占着茅坑不拉屎！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"为了让它有意义，应该干嘛？赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"比如:","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"#define a 5\n\n#define akdhihei 8","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在可以说，这些被命名的对象们有了意义。它们和某一个具体的值联系起来了，后面的程序中，你看到a就知道它代表5！看到akdhihei就知道它代表8！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"print(a + 1)","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你一定知道这个程序的结果是什么。而在a被赋值之前，你并不知道！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个操作的本质是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"是值与符号进行关联，关联之后，又可以通过符号提取数值。那么这是怎么做到的呢？解释器会维护着这样一种储存能力，以便保持着有关的名字-值对偶的关联！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而这种存储，就被称之为环境，（更加准确是，全局环境），那么局部变量，和其它不同作用域，就是不同的环境！这就是环境的本质！","category":"page"},{"location":"CSBase/3-环境变量及其设置/#path环境变量","page":"环境变量简介","title":"path环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"刚刚所说的是广义的环境。那么以path代表的环境变量是环境概念下的子集。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以python环境为例，在没有配置python环境之前，你在CMD终端中输入python，会显示","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而你把python环境配置一下之后，就可以了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那其中到底干了什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"其本质就是，path是一个变量，里面储存着一些文件的路径。在CMD命令行中输入命令的时候，系统会去path里面找相应的程序（或者在写程序的时候对调用path的路径等等）。比如说你的python.exe 路径为\"E:/\"，你把\"E:/\"加入到环境变量path中，那么就可以找到了，就可以在终端中运行了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，这个概念依旧是名字-值的关联。path是名字，文件路径是\"E:/\"，环境变量这个狭义概念的赋予是因为，在windows系统中，CMD会通过path中提供的路径去搜寻，如果没有在path中配置（把路径赋值给path），就找不到，就可以通过CMD执行（你手动进入那个文件夹，鼠标点击运行是一点问题也没有的！）。这相当于在Windows下的一个CMD运行环境path，CMD是系统级别的，所以这个环境比较高级。上面的a=5这个环境就很不重要了！但他们的本质都是一样的——","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那就是字符（名称）-值的关联。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"配置环境=把变量（path）和值（文件路径）关联上这一行为过程","category":"page"},{"location":"CSBase/3-环境变量及其设置/#再解释一下","page":"环境变量简介","title":"再解释一下","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们在命令提示符下输入msedge.exe时提示不是内部或者外部命令，而输入全路径（目录）的时候就没有问题。实际上，我们输入命令的时候，系统会在一些目录里去寻找是否有对应的命令。如果有就执行它，如果没有就冒出上面的提示。而如果输入全路径，则在给定的路径（目录）里去寻找对应的命令。这里说到的“一些目录”就是有系统的一个环境变量（PATH）所记录的目录。Windows下的PATH环境变量是以\";\"分割的若干个值，每个值是一个目录。Windows下的PATH环境变量可以通过\"此电脑\"->\"属性\"->\"高级系统设置\"->\"环境变量\"打开，选中Path，再点\"编辑\"就可以修改Path环境变量了。如果我们新建一条，把msedge.exe所在的目录加进去，然后确认退出。那再在命令提示符下就可以直接以msedge.exe启动浏览器了，而不需要再输入全路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"Linux下的PATH环境变量是以\":\"分割的若干个值，每个值就是一个目录。如果使用的是bash，可以以export PATH=/new/directory:\\$PATH命令临时修改PATH环境变量。也可以放在~/.bashrc里使得每次登录Linux的时候对PATH的修改都是有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"linux下最重要的几个环境变量是PATH、INCLUDE_PATH 和 LD_LIBRARY_PATH。PATH决定命令到哪里去找（目录间有优先级哦，越靠近前面优先级越高），INCLUDE_PATH 决定编译程序的时候系统到哪里去找那些被包含的头文件，LD_LIBRARY_PATH 决定系统到哪里去找加载的共享链接库。Windows下类似。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#到底什么是环境变量","page":"环境变量简介","title":"到底什么是环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量是操作系统中存储和管理配置信息的一种机制。它们是在操作系统中定义的命名值对，用于指定应用程序、脚本和系统组件之间的通信和交互。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows和Linux系统中，环境变量包含一些重要的配置信息，如系统路径、程序的安装路径、临时文件夹路径等。这些变量可以在系统的任何位置被访问和使用，而不需要硬编码在应用程序或脚本中。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量在操作系统和应用程序之间起到了桥梁的作用。它们提供了一种标准化的方法，使不同的程序能够共享配置信息，而不必直接修改源代码。通过使用环境变量，可以轻松地更改系统的配置，而无需重新编译或重新安装应用程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，可以使用图形界面或命令行工具（如系统属性、控制面板或set命令）来管理环境变量。在Linux系统中，可以通过命令行工具（如export、setenv等）来设置和修改环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"一些常见的环境变量包括：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径，当我们在命令行中输入命令时，操作系统会按照PATH变量指定的路径搜索可执行程序。\nHOME：指定当前用户的主目录路径。\nJAVA_HOME：指定Java开发环境的安装路径。\nTEMP（或TMP）：指定用于存储临时文件的目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过设置环境变量，可以方便地配置系统和应用程序的行为，提高应用程序的灵活性和可移植性，并简化系统管理和部署的过程。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Windows下如何设置环境变量","page":"环境变量简介","title":"Windows下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，有多种方法可以设置环境变量。下面我将介绍两种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法一：使用系统属性设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"右键点击计算机（或此电脑）图标，选择\"属性\"。\n在打开的窗口中，点击\"高级系统设置\"。\n在\"系统属性\"窗口中，点击\"环境变量\"按钮。\n在\"用户变量\"或\"系统变量\"部分，可以分别对当前用户或整个系统设置环境变量。选择对应的部分，点击\"新建\"按钮。\n输入环境变量的名称和值，然后点击\"确定\"。\n完成后，点击\"确定\"关闭所有打开的窗口。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法二：使用命令行设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开命令提示符（按Win+R，输入\"cmd\"，然后点击\"确定\"）或者使用PowerShell。\n使用以下命令设置用户级环境变量：\nsetx 变量名 \"变量值\"\n例如，要设置名为\"JAVA_HOME\"的环境变量，可以使用以下命令：\nsetx JAVA_HOME \"C:\\Java\\jdk\"\n如果要设置系统级环境变量，需要使用管理员权限运行命令提示符或PowerShell。\n执行命令后，将显示一个成功的消息。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，使用第一种方法设置的环境变量不会立即在已经打开的命令提示符或PowerShell窗口中生效。需要重新启动窗口或打开新的窗口才能使用新设置的环境变量。使用第二种方法设置的环境变量只会在当前回话中有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Linux下如何设置环境变量","page":"环境变量简介","title":"Linux下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Linux系统中，可以通过在bash shell的配置文件中设置环境变量。以bash为例，下面是一种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开终端，进入到当前用户的主目录。\n使用文本编辑器（如vi、nano等）打开.bashrc文件，这是bash的配置文件之一。\nvi ~/.bashrc\n在文件的末尾添加你想要设置的环境变量，例如：\nexport JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64\n这里将JAVA_HOME环境变量设置为Java安装路径。\n保存并关闭文件。\n在终端中执行以下命令，使配置生效：\nsource ~/.bashrc\n或者直接注销并重新登录。\n验证环境变量是否设置成功，可以使用以下命令：\necho $JAVA_HOME\n如果显示了设置的路径，则说明环境变量设置成功。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过在.bashrc文件中设置环境变量，每次打开新的终端窗口时，bash shell都会自动加载这些变量。这样，你就可以在终端中使用这些环境变量，或者在脚本中引用它们。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，如果你需要在系统级别设置环境变量，可以编辑/etc/environment文件或在/etc/profile.d/目录下创建一个.sh文件，并在其中设置环境变量。但这些操作可能需要管理员权限。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#有哪些重要的环境变量","page":"环境变量简介","title":"有哪些重要的环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以下是其中一些常见的重要环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径。当你在终端中输入命令时，系统会按照PATH变量指定的路径搜索可执行程序。\nINCLUDE_PATH: 指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。\nLDLIBRARYPATH：指定动态链接库（shared libraries）的搜索路径。当你运行依赖于动态链接库的可执行程序时，系统会在该路径下查找所需的库文件。\nHOME：指定当前用户的主目录路径。通常在命令行中使用波浪符（~）表示该路径。\nUSER：当前登录用户的用户名。\nSHELL：指定当前用户所使用的Shell程序的路径。\nPS1：定义命令行提示符的格式。你可以自定义命令行提示符的外观，例如设置为显示当前目录或用户名。\nLANG：指定系统默认的语言环境。\nLCALL：指定所有区域设置（Locale）的设置。它会覆盖其他与区域设置相关的环境变量，如LCCOLLATE、LC_TIME等。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这只是一小部分常见的重要环境变量。实际上，系统和应用程序可以定义和使用许多其他环境变量，以满足特定的需求和配置要求。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#PATH","page":"环境变量简介","title":"PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH是一个非常重要的环境变量，用于指定可执行程序的搜索路径。当你在终端或命令提示符中输入命令时，系统会按照PATH变量指定的路径来查找可执行程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"操作系统会按照PATH环境变量中指定的路径顺序逐个搜索命令，直到找到匹配的可执行程序或搜索完所有路径。如果找到匹配的可执行程序，系统将执行该程序；如果没有找到匹配的程序，系统将显示\"命令未找到\"（Command not found）的错误。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在PATH环境变量中，不同的路径由冒号（Linux、Unix系统）或分号（Windows系统）分隔开。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"示例：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"上述示例中的PATH环境变量包含了5个路径，每个路径都是可执行程序的搜索路径。当你在终端中输入一个命令时，系统会按照这些路径的顺序依次搜索命令。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"可以通过修改PATH环境变量来添加或修改可执行程序的搜索路径。这对于安装新的软件、使用自定义的脚本或工具以及管理系统的执行环境非常有用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"注意，为了避免安全风险，应小心管理PATH环境变量，确保只包含可信任的路径，并避免在PATH中包含当前目录（.）或不受信任的目录。这可以减少恶意软件或攻击者利用恶意程序替代系统命令的风险。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#INCLUDE_PATH","page":"环境变量简介","title":"INCLUDE_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"INCLUDE_PATH是一个常见的环境变量，用于指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当编译源代码时，编译器需要访问相关的头文件来了解函数和数据结构的定义。如果头文件位于非标准位置，编译器默认不会自动查找它们。这时，可以通过设置INCLUDE_PATH环境变量告诉编译器额外的头文件搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式因编译器而异。在常见的C/C++编译器中，如GCC（GNU Compiler Collection）或Clang，可以通过以下方式设置INCLUDE_PATH环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export INCLUDE_PATH=/path/to/include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set INCLUDE_PATH=C:\\path\\to\\include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/include或C:\\path\\to\\include应替换为实际的头文件所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了INCLUDE_PATH环境变量后，编译器将在指定的路径下搜索头文件，使其可被源代码正确引用。这样可以更方便地组织头文件的位置，特别是在项目中使用了自定义的头文件或第三方库的头文件时。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#LD_LIBRARY_PATH","page":"环境变量简介","title":"LD_LIBRARY_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"LD_LIBRARY_PATH是一个用于指定动态链接库（shared libraries）搜索路径的环境变量。在Linux系统中，可执行程序在运行时可能需要依赖某些共享库，而LD_LIBRARY_PATH变量可以告诉系统在哪些目录中搜索这些共享库。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当你运行一个可执行程序时，操作系统会使用预定义的默认路径搜索共享库。然而，有时共享库可能位于非标准位置，或者你希望在运行时使用其他版本的共享库。这时，可以通过设置LD_LIBRARY_PATH环境变量来指定额外的共享库搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式如下：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export LD_LIBRARY_PATH=/path/to/lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set LD_LIBRARY_PATH=C:\\path\\to\\lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/lib或C:\\path\\to\\lib应替换为实际的共享库所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了LD_LIBRARY_PATH环境变量后，可执行程序在运行时将在指定的路径下搜索共享库。这样可以方便地使用自定义的共享库或指定特定版本的共享库，而不必将其放置在默认的系统库路径下。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"需要注意的是，LD_LIBRARY_PATH是一个影响系统范围的环境变量，所以在设置时要谨慎。错误的设置可能导致系统出现问题或安全风险。一般建议仅在特定需求下使用LD_LIBRARY_PATH，并避免滥用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#视频地址","page":"环境变量简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"命令提示符和环境变量","category":"page"},{"location":"Simulation/MTK_heattran/#MTK手动空间离散求解PDE","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nContents：MTK、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\nMTK = ModelingToolkit.jlPDE = Partial Differential EquationModelingToolkit.jl 符号建模包","category":"page"},{"location":"Simulation/MTK_heattran/#MTK的PDE求解技巧","page":"MTK手动空间离散求解PDE","title":"MTK的PDE求解技巧","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"在之前介绍的例子中，所有的微分都是基于时间的微分。从数学的角度来说，微分变量只有一个。而对于有多个微分变量的PDE问题，能否通过MTK手动求解呢？例如，对时间对空间微分的PDE问题。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"答案是肯定的。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解PDE的数值方法有这么几步：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"建立数学描述方程\n对变量进行离散\n迭代求解","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK用法中，提供了基于时间的一条龙求解。至于多变量的PDE，也有对应的PDESystem。但是目前来说，PDESystem还不是很完善。其离散方法涉及NeuralPDE.jl的相关内容。就MTK.jl本身来说，没有打通PDE的建模与求解过程。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"所以，使用MTK求解PDE的缺口在于，没有针对其它变量的离散——空间离散。那么，如果我们能够手动完成空间离散，这个问题就解决了。事实上，手动空间离散是可行的。","category":"page"},{"location":"Simulation/MTK_heattran/#数值传热学实例","page":"MTK手动空间离散求解PDE","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"考虑一个正方形铸件的散热过程，正方形铸件初始温度1000℃，环境温度为0℃。如图","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"传热的控制方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho c_p fracpartial Tpartial t=lambda(fracpartial^2 Tpartial x^2 +fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将参数统一在等式右端，即","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=a(fracpartial^2 Tpartial x^2+fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"其中，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho密度单位为frackgm^3","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"c_p物体热容单位为fracJkgcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"lambda导热系数单位为fracWmcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"a热扩散系数单位为fracm^2s","category":"page"},{"location":"Simulation/MTK_heattran/#内部节点空间离散","page":"MTK手动空间离散求解PDE","title":"内部节点空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对方程进行空间离散，采用二阶中心差分，有：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_ijpartial t=a (fracT_i+1 j^n- 2 T_i j^n+T_i-1 j^nDelta x^2+fracT_i j+1^n- 2 T_i j^n+T_i j-1^nDelta y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"若使用化简表达，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"Delta x = Delta y = deltaT_i j=T_PT_i+1 j=T_WT_i-1 j=T_ET_i j-1=T_NT_i j+1=T_S","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"则有内部节点的空间离散：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=fracadelta^2(T_W^n+T_E^n+T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/#边边界空间离散","page":"MTK手动空间离散求解PDE","title":"边边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"下面考虑边界条件。以W边为例。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边界条件使用第三类边界条件。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"delta h(T_f-T_W^n)=delta lambda fracT_W^n-T_P^nfracdelta2","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"为了消去T_W^n，考虑该式子的等比式：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"frac(T_f-T_W^n)frac1h=fracT_W^n-T_P^nfracdelta2 lambda=frac(T_f-T_P^n)frac1h+fracdelta2 lambda taga","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当对流散热系数h足够大时，frac2lambdadelta happrox0，即T_W approx T_f。第三类边界条件可以近似为第一类边界条件——壁温恒定为环境温度，如下式推导：T_W=frach T_f+frac2 lambdadelta T_P^nh+frac2 lambdadelta=fracT_f+frac2 lambdadelta h T_P^n1+frac2 lambdadelta h approx T_f这是从数学上的一种理解，后面并没使用到该近似。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对边界采用附加源法进行分析。T_W为边界点温度，T_P节点的能量守恒方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycdelta lambda fracT_E^n-T_P^ndelta+delta lambda fracT_N^n-T_P^ndelta+delta lambda fracT_S^n-T_P^ndelta+delta lambda fracT_W^n-T_P^nfracdelta2=rho c delta^2 fracpartial T_Ppartial tendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将式(a)的第三项代入上式中的T_W-T_P项并化简，最终能得到边边界的边界方程：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycfracpartial T_Ppartial t=fraca delta^2(T_E^n+T_N^n + T_S^n)-(fracafraclambda deltah+fracdelta^22+frac3 a delta^2) T_P^n+fraca fraclambda deltah+fracdelta^22 T_fendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"同理可得其它3个边的边边界方程。","category":"page"},{"location":"Simulation/MTK_heattran/#角边界空间离散","page":"MTK手动空间离散求解PDE","title":"角边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后考虑角边界。以铸件左上角为例进行分析，下如图所示的角边界。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 3)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"分析方法同边边界的分析方法，最后可得：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=fracadelta^2(T_E^n+T_N^n+T_S^n)-(fracafraclambda deltah+fracdelta^22+frac2adelta^2) T_P^n+frac2afraclambda deltah+fracdelta^22 T_f","category":"page"},{"location":"Simulation/MTK_heattran/#离散方程汇总","page":"MTK手动空间离散求解PDE","title":"离散方程汇总","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"经过以上推导，得到了内节点表达式、边边界表达式和角边界表达式。为了方便程序表达，对方程的系数进行化简，令，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"A = fracadelta^2B = fracafraclambdadeltah+fracdelta^22","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当h很大时，fraclambda deltahapprox 0，所以B approx 2A。和前面边界条件的理解相似。同样的，这只是一种理解方式，并没有使用。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"内节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"角边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/MTK_heattran/#求解实例","page":"MTK手动空间离散求解PDE","title":"求解实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"using ModelingToolkit, DifferentialEquations\n\n# 参数设定\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\n\n@variables t (T(t))[1:n, 1:n]\n\nD = Differential(t)\n\n# 内节点代码\ninsides = [\n    D(T[i, j]) ~ A * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - 4 * T[i, j])\n    for i in 2:n-1 for j in 2:n-1]\n\n# 边边界代码\nWb = [\n    D(T[i, 1]) ~ A * (T[i+1, 1] + T[i-1, 1] + T[i, 2]) - (3B + A) * T[i, 1] + B * Tf\n    for i in 2:n-1\n]\nEb = [\n    D(T[i, n]) ~ A * (T[i+1, n] + T[i-1, n] + T[i, n-1]) - (3B + A) * T[i, n] + B * Tf\n    for i in 2:n-1\n]\nNb = [\n    D(T[1, i]) ~ A * (T[1, i+1] + T[1, i-1] + T[2, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\nSb = [\n    D(T[n, i]) ~ A * (T[n, i+1] + T[n, i-1] + T[n-1, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\n\n# 4 corner boundary\ncorner = [\n    D(T[1, 1]) ~ A * (T[2, 1] + T[1, 2]) - (2B + 2A) * T[1, 1] + 2B * Tf,\n    D(T[n, n]) ~ A * (T[n-1, n] + T[n, n-1]) - (2B + 2A) * T[n, n] + 2B * Tf,\n    D(T[n, 1]) ~ A * (T[n, 2] + T[n-1, 1]) - (2B + 2A) * T[n, 1] + 2B * Tf,\n    D(T[1, n]) ~ A * (T[2, n] + T[1, n-1]) - (2B + 2A) * T[1, n] + 2B * Tf\n]\n\neqs = append!(insides, Wb, Eb, Nb, Sb, corner)\n\n@named sys = ODESystem(eqs, t)\n\nsys = structural_simplify(sys)\n\n# u0 = [1000.0 for i in 1:n for j in 1:n]\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)\nprob = ODEProblem(sys, u0, (0, 100), [], saveat=0.1)\nsol = solve(prob, Tsit5())\n","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"值得一提的是：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK变量定义:","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"这是有效的变量数组（矩阵）的定义方式，也就是说MTK支持变量数运算。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@variables t (T(t))[1:n, 1:n]","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义时，既没有传递变量，也没有传递参数，甚至连t也可以不用传递，这都是可行的。ODESystem定义时能够自动检查（check）方程结构，从方程中获得变量信息。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@named sys = ODESystem(eqs, t)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nODESystem定义时，若传递变量数组或者参数数组，check时不能通过。目前来说这是一个bug，所以可以不写。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK初值设定","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"初值或者参数传递时，以下两种方式都可以。但也有区别。在符号计算中，符号在数组中的位置是不确定的。假如以数组的形式传递进去，那么就不知道哪个初值传递给了哪个变量（如果初值或参数都相同那就无所谓）。所以，初值传递需要精确到变量时，最好使用Dict。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"\nu0 = [1000.0 for i in 1:n for j in 1:n]\n\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat是solution handle中的内容。其作用是使sol中结果存储结果的时间步长为给定步长。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"当然，也可以使用sol()获得任意时刻的值。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"sol(2.5)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"但是这样会丢失变量的顺序，就是无法得知变量与数值的对应关系了。能否解决这个问题，这里还有许多可测试与探索的空间。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/#可视化","page":"MTK手动空间离散求解PDE","title":"可视化","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nJulia生态中，可视化也是很强的！Plots.ji远比想象的强大！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后，动画走你！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"an_len= length(sol[T[1,1]])\nusing Plots, GR\nres = rand(n,n,an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i,j,t] = sol[T[i,j]][t]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\ncontourf!(xs, ys, res[:,:,10])\nanim = @animate for i ∈ 1:50\n    contourf!(xs, ys, res[:,:,i])\nend\ngif(anim, \"anim.gif\", fps = 24)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: )","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"物体温度是下降的，在不断散热。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/#julia对外部程序的加壳","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"","category":"section"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"上面我们讲了julia可以很方便的调用外部的动态链接库中的函数。有很多的外部的库都可以编译成动态链接库，然后写个julia函数去调用。但是编译这些外部库，在不同的环境下还是要做很多的设置的。julia的JuliaBinaryWrappers组织做了很多基础的工作，维护很多外部程序编译的要求。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"比如https://github.com/JuliaBinaryWrappers/CoolPropjll.jl，在其src/wrappers目录中是不用的平台（linux、windows、macosx）和不同的编译器组合对应的编译规则文件。实际上我们不用管那么多，只需要知道我们如果add CoolPropjll包就会调用合适脚本去抓取源码，然后编译成对应的动态链接库。实际上这些代码也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"进一步的则可以写一个wrapper把所要的函数写个接口暴露出来。如https://github.com/CoolProp/CoolProp.jl，就是依赖了CoolProp_jll，把libcoolprop给加载了，然后写好了函数的接口。仅此而已。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"类似的做法还有很多， 比如SCIP、Ipopt等等。他们的编译设置文件也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"核心要义是理解这个工作方式和流程。","category":"page"},{"location":"#Ai4EDocs","page":"Home","title":"Ai4EDocs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: 图 4)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\n智慧能源：从概念到实践 \nOptControl.jl 对MTK中ODESystem的最优控制支持包。\nAi4ELab 虚拟仿真实验室\nAi4EComponentLib.jl 组件库\nAi4EMetaPSE.jl 微分方程的Json文件解析器\nAi4Server 基于Genie.jl架构的Ai4E后端服务框架。","category":"page"},{"location":"#Ai4EDocs简介","page":"Home","title":"Ai4EDocs简介","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ai4EDocs是Ai4E小组在学习中整理的一些可操作案例。案例的核心主要与建模仿真优化控制相关。文档主要特点为：","category":"page"},{"location":"","page":"Home","title":"Home","text":"既有数学层面的探究，也包含了应用层面的案例。\n包含大量Julia生态中软件包的使用\n兼顾建模仿真优化控制核心与拓展\n分享对理论抽象问题的认识\n分享软件使用过程中的技巧\n分享学习的心路历程与对库使用的理解\nAi4Energy组的合作开发流程","category":"page"},{"location":"","page":"Home","title":"Home","text":"供学习参考。","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"","page":"Home","title":"Home","text":"欢迎贡献文档！","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"#Julia资源传送门","page":"Home","title":"Julia资源传送门","text":"","category":"section"},{"location":"#基础文档","page":"Home","title":"基础文档","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia中文文档\nJulia官方文档\nSciml总站","category":"page"},{"location":"#数值计算","page":"Home","title":"数值计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl（常微分方程求解包）\nNeuralPDE.jl（偏微分方程求解包）\nJuMP.jl（优化求解器包）\nDiffEqParamEstim.jl（基于DE的参数辨识包）\nFlux.jl Julia机器学习包(The Julia Machine Learning Library)\nEquationsSolver 自制的小型方程（组）求解器\nOptimization.jl(Sciml优化包)","category":"page"},{"location":"#符号计算","page":"Home","title":"符号计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl（符号建模包）\nSymbolics.jl（MTK依赖的符号求解包）\nSymPy.jl 符号计算包（可求方程解析解），与Matlab中的符号工具包类似","category":"page"},{"location":"#计算图形学","page":"Home","title":"计算图形学","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl 纯Julia的CGAL（计算图形学算法库）实现\nGmsh.jl gmsh的Julia接口","category":"page"},{"location":"#数据处理","page":"Home","title":"数据处理","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO.jl Julia中不同类型文件读入的统一接口（包括MeshIO）\nCSV.jl\nDataFrames.jl（大规模数据批量处理包）\nUnitful（单位计算包）\nJSON3.jl JSON到类型的读入\nJSON.jl","category":"page"},{"location":"#可视化","page":"Home","title":"可视化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots.ji（可视化包）\nPkg.jl 包管理\nMakie.jl 高性能绘图包。\nPlotlyJS.jl 网页绘图，图可拖动。","category":"page"},{"location":"#WEB框架","page":"Home","title":"WEB框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Geine.jl and Stipple.jl Julia Web 框架Geine和Stipple的文档\nHTTP.jl","category":"page"},{"location":"#其它资源传送门","page":"Home","title":"其它资源传送门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoolProp\nAPMonitor-github\nAPMonitor\nGreet\nMqtt系列教程\nMixed Integer Distributed Ant Colony Optimization(midaco-solver)\nPython的GUI开发工具PYQT\nMathematica","category":"page"},{"location":"#文档内容","page":"Home","title":"文档内容","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dirs = [\"Frameworks\",\"Modeling\",\"Simulation\",\"Optimization\",\"Control\",\"CSBase\",\"Tools\",\"WorkFlow\"]\n\n\"总篇数：$(sum(map(file -> length(readdir(joinpath(@__DIR__,\"..\",\"src\",file))), dirs)))\"","category":"page"},{"location":"#基础入门知识","page":"Home","title":"基础入门知识","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CSBase\", file), readdir(\"CSBase\"))","category":"page"},{"location":"#工具准备","page":"Home","title":"工具准备","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Tools\", file), readdir(\"Tools\"))","category":"page"},{"location":"#建模","page":"Home","title":"建模","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Modeling\", file), readdir(\"Modeling\"))","category":"page"},{"location":"#仿真","page":"Home","title":"仿真","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Simulation\", file), readdir(\"Simulation\"))","category":"page"},{"location":"#优化","page":"Home","title":"优化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Optimization\", file), readdir(\"Optimization\"))","category":"page"},{"location":"#控制","page":"Home","title":"控制","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Control\", file), readdir(\"Control\"))","category":"page"},{"location":"#框架","page":"Home","title":"框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Frameworks\", file), readdir(\"Frameworks\"))","category":"page"},{"location":"#工作流程","page":"Home","title":"工作流程","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"WorkFlow\", file), readdir(\"WorkFlow\"))","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell和Windows-Terminal","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell初印象","page":"PowerShell和Windows Terminal","title":"PowerShell初印象","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"新时代，Windows也在向Linux学习。它现在有了新的强大命令行工具，PowerShell。并且微软现在赋予了它强大的命令行下管理能力。很多修改电脑的设置都可以在PowerShell下使用命令来完成。比如说在Windows下安装WSL（Windows Subsystem for Linux）就可以用管理员打开PowerShell，通过wsl --install命令来完成。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，PowerShell可以 先以管理员执行Set-ExecutionPolicy RemoteSigned，再在配置文件中设置Set-PSReadLineOption -EditMode emacs来开启Emacs键绑定，从而可以使用ctrl+e等命令进行光标快速移动。这一点仅仅是可以提高输入效率，可以先忽略。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell简介","page":"PowerShell和Windows Terminal","title":"PowerShell简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种强大的命令行工具和脚本语言，由 Microsoft 开发并广泛用于管理和自动化 Windows 系统和任务。与传统的命令提示符（CMD）相比，PowerShell 提供了更丰富的功能和更直观的语法，使系统管理员和开发人员能够更高效地管理和操作计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些 PowerShell 的特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"对象导向：PowerShell 基于对象导向的编程模型，可以使用和操作.NET Framework 中的对象。这使得在 PowerShell 中处理数据和执行操作更加灵活和直观。\n强大的命令和模块：PowerShell 提供了大量的内置命令，称为 cmdlet，用于执行各种系统管理任务。这些 cmdlet 具有一致的命名约定和参数结构，使得编写和执行命令更加简单和可预测。此外，PowerShell 还支持模块化，您可以导入和使用其他人编写的模块来扩展其功能。\n脚本和自动化：PowerShell 是一种脚本语言，可以编写和执行脚本文件以自动化重复的任务或进行批量操作。使用 PowerShell 脚本，您可以创建复杂的工作流程，处理和转换数据，访问系统资源，管理用户和权限等。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。您可以在本地计算机上使用 PowerShell 命令来执行远程计算机上的任务，访问远程计算机的文件和注册表，或者执行远程会话。\n跨平台支持：除了 Windows 系统外，PowerShell 还提供了跨平台支持，可以在 macOS、Linux 和其他操作系统上运行。这使得使用 PowerShell 进行系统管理和自动化成为跨平台环境中的一种强大工具。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一项功能强大且灵活的技术，可以用于各种任务，从简单的命令执行到复杂的系统管理和自动化。它是系统管理员、开发人员和 IT 专业人员的重要工具之一，提供了更高效、一致和可编程的方式来管理计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何打开PowerShell","page":"PowerShell和Windows Terminal","title":"如何打开PowerShell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows 操作系统中，有几种方式可以打开 PowerShell。以下是其中一些常见的方法：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"使用开始菜单：\n单击桌面左下角的 Windows 图标来打开开始菜单。\n在开始菜单中，找到 \"Windows PowerShell\" 或 \"PowerShell\" 的文件夹。在该文件夹中，您将找到不同版本的 PowerShell，如 PowerShell、PowerShell 7、PowerShell 5.1 等。\n点击所需的 PowerShell 版本，将打开 PowerShell 窗口。\n使用快捷键：\n按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"powershell\"（不包括引号）并按下回车键，将打开 PowerShell 窗口。\n使用 CMD 启动 PowerShell：\n打开命令提示符（CMD）窗口。您可以按下 Windows 键 + R，然后键入 \"cmd\"（不包括引号）并按下回车键，或者按照我之前所述的步骤在开始菜单中找到并打开命令提示符。\n在命令提示符窗口中，键入 \"powershell\"（不包括引号）并按下回车键，将从 CMD 切换到 PowerShell。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"无论您选择哪种方法，都将打开一个 PowerShell 窗口，您可以在其中输入和执行 PowerShell 命令、编写和运行 PowerShell 脚本，以及进行系统管理和自动化任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell可以执行Windows管理任务吗？","page":"PowerShell和Windows Terminal","title":"PowerShell可以执行Windows管理任务吗？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种功能强大的工具，可以执行大部分 Windows 系统管理任务，但并不是所有任务都可以完全由 PowerShell 完成。大多数 Windows 管理任务都可以通过 PowerShell 来实现，因为它提供了广泛的系统管理 cmdlet 和功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是 PowerShell 可以执行的常见任务：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"文件和文件夹操作：PowerShell 可以创建、复制、移动和删除文件和文件夹，以及管理文件和文件夹的权限和属性。\n进程和服务管理：PowerShell 可以列出、启动、停止和监控正在运行的进程和服务。\n注册表操作：PowerShell 可以读取、修改和删除 Windows 注册表中的键值。\n网络配置和管理：PowerShell 可以配置网络适配器、查看和修改网络设置，以及执行网络诊断任务。\n用户和组管理：PowerShell 可以创建、修改和删除用户账户和组，管理用户权限和访问控制。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。\n脚本编写和自动化：PowerShell 是一种脚本语言，可以编写脚本来自动化重复的任务，批量操作和工作流程。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"尽管 PowerShell 能够处理大多数 Windows 管理任务，但仍有一些特定任务可能需要使用其他工具或界面。一些特定的系统配置、管理工具或应用程序可能具有自己的命令行界面或API，需要使用专门的工具或命令来执行相关任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"综上所述，PowerShell 是一个非常强大和全面的工具，能够执行大部分 Windows 系统管理任务。但对于某些特定的任务，您可能需要使用其他工具或结合多种工具来实现所需的功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Windows-Terminal简介","page":"PowerShell和Windows Terminal","title":"Windows Terminal简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Windows Terminal 是一款新一代的命令行工具，由 Microsoft 开发并在 Windows 操作系统中提供。它为用户提供了一个现代化、高度可定制的命令行界面，使得同时使用多个命令行工具和 Shell 变得更加方便和强大。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是 Windows Terminal 的一些特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"多标签和分屏：Windows Terminal 支持多个标签页和分屏布局，您可以在同一个窗口中同时打开多个命令行会话，方便同时进行多个任务或操作。\n支持多种 Shell：Windows Terminal 可以同时运行多个不同的 Shell，如 PowerShell、命令提示符（CMD）、Windows Subsystem for Linux (WSL)、Azure Cloud Shell 等。这使得用户可以根据需要选择不同的 Shell，而无需切换窗口或应用程序。\n高度可定制：Windows Terminal 允许用户自定义外观、颜色主题、字体、快捷键等，以满足个人偏好和风格需求。用户可以根据自己的喜好创建和应用自定义配置文件，定制 Terminal 的外观和行为。\n支持 Unicode 和 Emoji：Windows Terminal 全面支持 Unicode 字符和 Emoji 表情符号，使得在命令行界面中可以正确显示和处理各种语言字符和图形符号。\nGPU 加速和图形效果：Windows Terminal 基于 Windows 的 Universal Windows Platform (UWP) 技术，可以利用 GPU 加速和硬件加速，提供流畅的滚动、动画效果和图形渲染。\n快速启动和分层渲染：Windows Terminal 采用了快速启动机制和分层渲染技术，使得打开和切换会话更加迅速和高效。\n扩展性和开放性：Windows Terminal 是开源项目，允许开发人员通过扩展来增加新的功能和定制选项。用户可以从社区贡献的插件和扩展中获益，或者自己开发和分享自定义的扩展。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"总体而言，Windows Terminal 是一个现代化、可定制化和功能丰富的命令行工具，为用户提供了更好的命令行体验和更高效的工作环境。它是 Windows 平台上命令行操作的新选择，可以满足开发人员、系统管理员和技术爱好者对于命令行工具的需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何安装Windows-Terminal","page":"PowerShell和Windows Terminal","title":"如何安装Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要安装 Windows Terminal，您可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"打开 Microsoft Store：在 Windows 10 操作系统中，可以通过点击任务栏上的 \"Microsoft Store\" 图标来打开 Microsoft Store 应用商店。\n搜索 Windows Terminal：在 Microsoft Store 的搜索框中输入 \"Windows Terminal\"，然后按下回车键或点击搜索按钮。\n选择 Windows Terminal 应用：在搜索结果中，找到 Windows Terminal 应用，并点击它的图标以打开应用页面。\n安装 Windows Terminal：在 Windows Terminal 应用页面上，点击 \"获取\"（或 \"安装\"）按钮。系统会开始下载和安装 Windows Terminal 应用。\n启动 Windows Terminal：安装完成后，您可以在开始菜单或任务栏中找到 Windows Terminal 图标。点击图标即可启动 Windows Terminal。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"注意：为了安装 Windows Terminal，您的计算机必须运行 Windows 10 1903 或更高版本。如果您的操作系统版本较旧，请考虑更新到最新版本以获得更好的兼容性和功能支持。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，Windows Terminal 也可以从 GitHub 上的源代码进行构建和安装，这需要更高级的技术知识和步骤。如果您对此感兴趣，可以访问 Windows Terminal 的 GitHub 仓库（https://github.com/microsoft/terminal）获取更多详细信息和指南。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何使用PowerShell的emacs键绑定？","page":"PowerShell和Windows Terminal","title":"如何使用PowerShell的emacs键绑定？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption 是 PowerShell 的一个命令，用于设置和自定义 PowerShell 的交互式命令行编辑器 PSReadLine 的选项。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PSReadLine 是一个用于 PowerShell 的增强型命令行编辑器，提供了更强大的命令行编辑和自动完成功能。Set-PSReadLineOption 命令允许您配置和调整 PSReadLine 的各种选项，以适应个人偏好和需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常用的 Set-PSReadLineOption 命令的选项和用法示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"更改提示符样式：\nSet-PSReadLineOption -Prompt 'PS> '\n这将将 PowerShell 的提示符更改为 'PS> '。\n启用语法高亮显示：\nSet-PSReadLineOption -Colors @{Command = 'Green'}\n这将启用命令的绿色语法高亮显示。\n启用自动完成：\nSet-PSReadLineOption -PredictionSource HistoryAndFileSystem\n这将启用从历史记录和文件系统中自动完成命令和路径的功能。\n修改键绑定：\nSet-PSReadLineKeyHandler -Key Tab -Function Complete\n这将将 Tab 键绑定到自动完成功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一些 Set-PSReadLineOption 命令的示例，您可以根据需要使用其他选项来自定义和配置 PSReadLine。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，Set-PSReadLineOption 命令只会影响当前 PowerShell 会话中的 PSReadLine 设置。如果您希望在每次启动 PowerShell 时自动应用这些设置，可以将它们添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption -EditMode 是用于设置 PowerShell PSReadLine 编辑模式的命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 PowerShell 中，PSReadLine 提供了多种编辑模式，用于自定义命令行的编辑行为。通过 Set-PSReadLineOption -EditMode 命令，您可以指定所需的编辑模式。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常见的 PSReadLine 编辑模式：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 模式：这是默认的 PSReadLine 编辑模式，它基于 Emacs 文本编辑器的键绑定方式。\nWindows 模式：该模式模仿了 Windows 命令行的键绑定方式，类似于 CMD 的编辑行为。\nVi 模式：该模式模仿了 Vi/Vim 文本编辑器的键绑定方式，允许您使用 Vi 风格的编辑命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要设置 PSReadLine 的编辑模式，请使用以下命令示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"# 设置为 Emacs 模式\nSet-PSReadLineOption -EditMode Emacs\n\n# 设置为 Windows 模式\nSet-PSReadLineOption -EditMode Windows\n\n# 设置为 Vi 模式\nSet-PSReadLineOption -EditMode Vi","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过运行上述命令中的任何一个，您可以在当前 PowerShell 会话中设置 PSReadLine 的编辑模式。请注意，这只会影响当前会话，不会在其他会话中生效。如果您希望每次启动 PowerShell 时都使用特定的编辑模式，请将相应的命令添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#我碰到了执行策略不允许的错误","page":"PowerShell和Windows Terminal","title":"我碰到了执行策略不允许的错误","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-ExecutionPolicy 命令用于设置 PowerShell 脚本的执行策略。执行策略是一种安全措施，用于限制 PowerShell 脚本的执行，以防止恶意脚本的运行。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"具体而言，Set-ExecutionPolicy 命令中的参数 RemoteSigned 是一种执行策略级别。当执行策略设置为 RemoteSigned 时，意味着在本地计算机上的脚本必须由信任的发布者签名，但在远程计算机上执行的脚本不需要签名。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"设置执行策略为 RemoteSigned 的目的是增加 PowerShell 脚本的安全性，确保只有经过签名的脚本或本地编写的脚本可以在本地计算机上执行。这样可以减少潜在的恶意脚本或未经授权的脚本对系统的影响。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"需要注意的是，执行策略是一个系统级别的设置，适用于整个计算机。因此，更改执行策略可能需要管理员权限。在执行 Set-ExecutionPolicy RemoteSigned 命令之前，您需要以管理员权限运行 PowerShell 会话。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，执行策略仅提供了一层基本的安全保护，并不能完全阻止所有潜在的安全风险。在运行任何脚本之前，仍然需要审查和确保脚本的来源和内容是可信的。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#EditMode的emacs键绑定有什么好处？","page":"PowerShell和Windows Terminal","title":"EditMode的emacs键绑定有什么好处？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows Terminal 中，EditMode 是一个配置选项，用于设置 PowerShell 的 PSReadLine 编辑模式。当 EditMode 设置为 \"emacs\" 时，Windows Terminal 将使用 Emacs 键绑定来提供编辑功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 键绑定是基于 Emacs 文本编辑器的经典键盘快捷键，它提供了丰富的命令和编辑操作，使您可以更高效地编辑和处理文本。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是一些常用的 Emacs 键绑定示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"移动光标：\nCtrl + B：向后移动一个字符（相当于箭头左键）。\nCtrl + F：向前移动一个字符（相当于箭头右键）。\nCtrl + P：向上移动一行（相当于箭头上键）。\nCtrl + N：向下移动一行（相当于箭头下键）。\nCtrl + A：移到行首。\nCtrl + E：移到行尾。\nAlt + B：向后移动一个单词。\nAlt + F：向前移动一个单词。\n编辑操作：\nCtrl + D：删除光标处的字符。\nCtrl + K：删除光标到行尾的内容。\nCtrl + Y：粘贴删除的文本。\nCtrl + W：删除光标前的单词。\nCtrl + T：交换光标前后的字符。\n撤销和重做：\nCtrl + /：撤销上一次操作。\nCtrl + _：撤销上一次操作（类似于撤销）。\nCtrl + Shift + -：重做上一次操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一小部分 Emacs 键绑定的示例，Windows Terminal 中的 Emacs 编辑模式提供了更多的键盘快捷键，以及其他类似于 Emacs 的编辑命令和操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过在 Windows Terminal 中设置 EditMode 为 \"emacs\"，您可以在 PowerShell 会话中使用这些 Emacs 键绑定来进行编辑和操作，提高您的命令行效率和体验。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Linux下的shell","page":"PowerShell和Windows Terminal","title":"Linux下的shell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在linux操作系统下，类似的也有命令行模式，而且是更常用的模式。尽管很多ubuntu用户首先接触到的是其gui界面，但是事实上cli更为常用一些。大多数的系统默认的是bash。操作系统内部管理文件、设备的是kernel。我们用户通过shell来跟kernel打交道。而这个bash就是shell的一种。跟Windows下的命令提示符类似，我们在shell的提示符下可以输入不同的命令来完成一些工作。比如ls是列出当前文件夹下的内容。cp是复制文件的命令。cd是改变目录的命令等等。具体这些内容可以参考linux入门书看一看，或者看一看linux cheatsheet。","category":"page"},{"location":"WorkFlow/gitworkflow/#Ai4E组织合作开发流程","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\nContents：基于Gitkraken的合作开发流程Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\nGitkraken为Git图形化软件。预计实践时间：60min - 120min","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pages = [\"gitworkflow.md\"]","category":"page"},{"location":"WorkFlow/gitworkflow/#开发流程简介","page":"Ai4E组织合作开发流程","title":"开发流程简介","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github是一个非常流行的代码托管平台，上面有许许多多的前辈与“他们的牛逼代码”。为了充分与国际接轨，我们（Ai4Energy）组织也选择Github。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy组织可以视为一个大的代码仓库，每个人都可以向组织中贡献代码。Github基于Git，有完善且高效的多人协作的开发流程（所谓开发流程其实就是如何向Ai4Energy组织中提交代码做贡献）。","category":"page"},{"location":"WorkFlow/gitworkflow/#准备工作","page":"Ai4E组织合作开发流程","title":"准备工作","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github注册账户\n下载Gitkraken\n用Github账户登录Gitkraken（重要），然后建立Gitkraken的profile（个人形象，不重要）\n建立SSH登录验证方式（点击下面的绿色按钮，Gitkraken自动生成并且上传），如下图。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n稳定连接Github，推荐一个免费加速器Watt Toolkit，在微软应用商店。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来是开发的逻辑介绍。","category":"page"},{"location":"WorkFlow/gitworkflow/#开发逻辑","page":"Ai4E组织合作开发流程","title":"开发逻辑","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"应用场景是这样的：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"在某师兄云盘里有一份报告，师兄给2个师弟说你们合作把这份报告改一改（假设两位师弟一个在美国一个在日本，且不认识，只有云盘的地址）。小师弟先改第一版，大师弟改第二版。他们需要干以下的操作：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"小师弟把文件先添加到自己的云盘资源里\n假设云盘没有在线编辑功能，小师弟修改文件只有一种选择：把文件下载到本地修改。\n小师弟修改报告\n小师弟把修改完成的报告上传至自己的云盘。\n修改完成之后，小师弟就可以对师兄说：我改完了，文件在我自己的云盘里，如果可以的话，我就把你的那一份原来的报告覆盖了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来的选择就有两种：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"师兄说：改的不错，覆盖吧。然后大师弟重复1-5步骤\n师兄说：改的不行，重改吧。然后小师弟重复2-5步骤","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上，就是我们工作流程的实际内涵：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"1: 这个行为叫Fork。Fork的意思是在自己的个人账号下建立一个一样的别人的仓库，而且会显示你这个仓库是fork别人的。 (Image: 图 1)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"2: 这个行为叫Pull。一般而言，第一次在本地建仓时，会自动Pull。本地仓库建好了，若云端仓库文件有更新，这个时候本地文件要更新的话，就有相应的Pull操作。 (Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"3: 这个行为叫开发🤣。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"4: 这个行为叫Push。 (Image: 图 3)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"5: 这个行为叫Pull Request（合并到主分支）。为要先推送到自己仓库的副本而不是直接覆盖别人的那个仓库呢？🤣","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"整体的逻辑图如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#操作步骤与方法","page":"Ai4E组织合作开发流程","title":"操作步骤与方法","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"方法对应以上5个步骤。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step1:-Fork","page":"Ai4E组织合作开发流程","title":"Step1: Fork","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#Step2:-Pull","page":"Ai4E组织合作开发流程","title":"Step2: Pull","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"首先是本地建仓：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"拉取之后点击Open Now，我们就能看到操作页面。同时在左侧需要点击Add。GitKraken自动检测到我们Fork了一个包，它会认为你可能需要通过修改别人的代码然后上传到你自己的库里，所以它给了一个添加自己Fork的库的一个选项（如果点上，也可以手动添加远程仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 5)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\n在Step2中，如果是从自己Fork的仓库地址建立本地仓库，也可以，只不过要手动添加Ai4的远程地址了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"中间的蓝色绿色圈是啥呢？是文件修改的记录。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step3:-本地进行内容编辑——开发","page":"Ai4E组织合作开发流程","title":"Step3: 本地进行内容编辑——开发","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/#Step4:-Push","page":"Ai4E组织合作开发流程","title":"Step4: Push","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"编辑完成之后（任何改动都会被检测到）有几个关键步骤：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"给本次修改命名，表示干了什么（例如：add a file）\n右边上方暂存修改\n右边底下提交更改\n在修改的圈那里右键，点击UpStream，修改推送地点。一定要选择自己的库，组织的库没有权限推送上去。\n最后点击Push","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 6)","category":"page"},{"location":"WorkFlow/gitworkflow/#Step5:-Pull-Request（合并到主分支）","page":"Ai4E组织合作开发流程","title":"Step5: Pull Request（合并到主分支）","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Gitkraken有图形化的方式创建Pull Request。如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 7)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pull Request就是申请将你做的修改合并到Ai4的某个仓库（任何别人的仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n为什么能合并呢？因为首先把别人的库给拉取过来了，只是做了一些修改（增加或删减内容），仓库的“根”是一致的所以能合并。就类似，小师弟把师兄的文件复制过来了，在它的基础上改，改完之后把自己的内容复制，在师兄的文件中覆盖粘贴，这是没有问题的。 所以，如果选择两个不同“根”的仓库去Pull Request，那是行不通的。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成之后，就等“师兄审核”吧！","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"这是一套基于Gitkraken的简版Git合作开发流程，如果有兴趣，可以去了解原汁原味的Git。相关的资料很多！","category":"page"},{"location":"WorkFlow/gitworkflow/#实践","page":"Ai4E组织合作开发流程","title":"实践","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy中有一个test.jl。完成以下内容：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成一次上述开发过程，形成具象认知。\n开发内容：在test.jl库中的src文件夹中，添加编辑一个xxx.jl的文件，（xxx为自己的名字，中文，便于\"师兄审核\"）\n文件内容任意。期望针对文档给出改进建议，也可以是一段Julia代码。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上是一个简单的流程，对于Git或Gitkraken来说只是冰山一角。遇到任何疑问与问题，积极思考原因，可以自行查阅相关资料，也可以积极的和Ai4组的同学交流。","category":"page"},{"location":"Control/OptimControl/#最优控制理论与应用","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\nContents：JuMP、Control、EquationsSolverContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\nJuMP是计算优化问题的Julia软件包。Symbolics.jl为符号计算包EquationsSolver自制的小型方程（组）求解器。","category":"page"},{"location":"Control/OptimControl/#问题描述","page":"最优控制理论与应用","title":"1 问题描述","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"本篇通过一个机器人的控制问题，介绍最优控制的相关理论与求解方式。问题如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"题目信息总结如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这是一个含有三个关节的机器人。\n机器人身体的三部分与垂直方向的夹角分别为theta=theta_1theta_2theta_3。\n机器人的三个关节能够提供使机器人运动的扭矩：Q=Q_1Q_2Q_3。\n机器人关节的扭矩与夹角之间的关系（控制方程）为：Jmathbfddottheta=Ktheta+BQ。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"扭矩对夹角的控制方程的推导方法，我们并不关心。知晓它是通过动力学学分析得出即可。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"它最重要的信息是揭示了Q与theta之间的控制关系。通过该方程，我们可以知道，如果控制量Q发生了改变，被控量theta会发生何种变化。控制方程的物理含义是，夹角变化的角加速度与夹角的位置以及关节扭矩相关。具体的系数值见上图所示。","category":"page"},{"location":"Control/OptimControl/#.1-（最优）控制内涵","page":"最优控制理论与应用","title":"1.1 （最优）控制内涵","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"从这个问题中，我们可以抽象出“控制”一般性内涵：通过改变控制量来操作被控量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"那么什么是最优控制的内涵呢？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"假如，机器人初始状态是斜站着（theta=fracpi4fracpi4fracpi4，弧度制单位），现在要让机器人站直（theta=000）。我们可以改变关节扭矩Q。那么问题来了，Q应该：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"是否是一个随时间不变的常数？\n如果是常数，取何值？\n是否是一个随时间变化的函数？\n如果是函数，怎样变化？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"我们从方程中可以发现，假若对Q不加限制。只是要机器人站直，那么我可以通过改变Q，让机器人可以慢慢的站、快快的站、先蹲后站，先躺后站，先俯卧撑再站，先整几个深蹲再站 :)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最优的含义则体现在这些“限制”里。一般而言，若对控制的效果加以限制，使控制的某种指标最大（最小），则是最优控制。例如，让机器人最快的站直，最省力的站直。在这些“最”的限制下，Q就不是任意的了（要最快的站直就不能先做个俯卧撑再站，那样就慢了 :) ），而是仅有一组最符合要求的。在数学上，最符合要求的Q则是这个最优化问题的解。这就是最优化控制的内涵。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"综上，其关键的要素有两点：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"控制方程\n控制过程中的最优化目标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在以上2点关键要素之下，最优控制问题的本质是优化问题：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：控制最优化\n优化约束：控制方程代表的变量约束以及起点终点约束等。","category":"page"},{"location":"Control/OptimControl/#状态方程","page":"最优控制理论与应用","title":"2 状态方程","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"状态空间方程是控制学中非常重要的一个概念。控制学中，把变量视为状态。其本质还是将数学上的变量赋予了物理含义。状态方程的矩阵形式为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotmathbfx=mathbfA(t)mathbfx+mathbfB(t)mathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其特征如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx为状态向量\n上述mathbfu为系统的输入向量（控制量向量）\n上述mathbfAB为系统系数矩阵，描述内部量之间的联系。\n统一以一阶导数的形式描述。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"若把机器人的控制方程写成状态方程，则有：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"leftbeginmatrixdotmathbfx_1=mathbfx_2dotmathbfx_2=mathbfJ^-1Kmathbfx_1+mathbfJ^-1BmathbfuendmatrixrightRightarrow dotmathbfx=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfx+beginbmatrix0mathbfJ^-1Bendbmatrixmathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其中，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"mathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx_1代表角速度向量，有三个角速度分量。\n上述mathbfx_2代表角加速度向量，有三个角加速度分量。\n上述mathbfu代表扭矩向量，有三个扭矩分量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"如此则统一了控制问题的方程描述。状态方程也好，控制方程也好，其本质是描述系统的方程。它们只是形式上的区别，在数学本质上是一致的。统一为状态方程的好处是，能够对控制问题进行普适性的推导与计算，使得状态方程下的数学推论具有普遍意义。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n状态方程的定义为:描述系统状态变量与输入变量之间关系的一阶微分方程组，称为系统的状态方程。状态方程表征了系统由输入量引起的内部状态变量的变化情况。","category":"page"},{"location":"Control/OptimControl/#最优控制问题解析解","page":"最优控制理论与应用","title":"3 最优控制问题解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先，介绍系统一般性数学描述：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统状态方程","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotx(t)=Ax(t)+Bu(t)=fx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由于状态量都是关于时间的因变量，所以都写成关于时间的函数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统始端与终端","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x(t_0)=x_0x(t_f)=x_f ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统性能指标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fLx(t)u(t)tdt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其次，把它写优化问题的数学形式则为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n min int_t_o^t_fLx(t)u(t)tdtsthspace6cmdotx(t)=fx(t)u(t)tx(t_0)=x_0x(t_f)=x_f \nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"一般的优化问题的解是数。不同于一般的优化问题，该优化的问题的解是函数。这就涉及到数学中的变分概念。这里不过多介绍，只给结论。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n一般最优化问题中，是找到相应的数值使得优化目标最小。最优化控制问题中，是找到相应的控制函数，使得优化目标最小。一个是找数值，一个是找函数。相当于自变量变为了函数。这是泛函分析解决的问题。","category":"page"},{"location":"Control/OptimControl/#.1-端点固定问题的解法","page":"最优控制理论与应用","title":"3.1 端点固定问题的解法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"端点固定问题即t_f的数值确定。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"求解析解的方法是拉格朗日乘子法在泛函分析中的体现。首先令，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H = Lx(t)u(t)t + lambda(t)^Tfx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上式中，H称为哈密尔顿函数，lambda(t)为伴随方程。最优控制函数存在的必要条件为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda = -fracpartial Hpartial x\nfracpartial Hpartial u=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"再结合控制方程与边界方程，则可以解得分析解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n最优控制问题中有多种边界条件。端点固定问题只是其中一种。它们分别为：终端时刻t_f固定，终端向量x(t_f)自由\n终端时刻t_f固定，终端向量x(t_f)约束\n终端时刻t_f自由，终端向量x(t_f)约束在约束中，数值确定是也是约束的一种。不同的边界条件，添加不同的边界方程，在此不过多介绍，有兴趣可以翻看《最优控制理论》。","category":"page"},{"location":"Control/OptimControl/#机器人控制问题求解实例","page":"最优控制理论与应用","title":"4 机器人控制问题求解实例","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人问题的状态方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotmathbfx=mathbfAmathbfx+mathbfBmathbfu  \nmathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"设优化目标如下，可以理解为最省力的站直方式。因为其物理含义是时间域上的扭矩平方和最小。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fu^2dt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"可以得到哈密尔顿方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H=u^2+Alambda_2x_1+lambda_1x_2+lambda_2Bu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"代入解析解存在的必要条件：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda_1 = -fracpartial Hpartial x_1=-lambda_2x_2 dotlambda_2 = -fracpartial Hpartial x_2=-lambda_1fracpartial Hpartial u=2u+lambda_2B=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/#.1-SymPy求状态方程解析解","page":"最优控制理论与应用","title":"4.1 SymPy求状态方程解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"化简伴随方程，结合控制方程，可以得到：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n ddotlambda_2 - Alambda_2= 0 u=-05*lambda_2Bddotx_1=Ax_1+Bu\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"为了求得上述问题的解析解，采用SymPy。SymPy是基于python的符号计算包，其开发了julia的调用接口。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using SymPy\n@syms t A B λ() x() #定义函数及符号变量\ndiffeq = Eq(λ(t).diff(t, 2), A * λ(t)) # 定义需要求解的方程\nλt = dsolve(diffeq, λ(t)).__pyobject__.rhs # 求解得到λ\nut = -1//2 * B * λt # 计算得到u\ndiffeq2 = Eq(x(t).diff(t, t), A * x(t) + B * ut)# 定义关于x(t)的微分方程\ndsolve(diffeq2, x(t))  # 求解","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\n在上述代码中，0.5需要用1//2，这样x(t)才能求得解析解，否则会报错。因为0.5是浮点数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"得到结果如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_1(t)=(C_3+C_1fracB^2t4sqrtA)exp^-sqrtAt+(C_4-C_2fracB^2t4sqrtA)exp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"同时，对x_1(t)进行求导，得到x_2(t)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dsolve(diffeq2, x(t)).__pyobject__.rhs.diff(t)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_2(t)=-(sqrtAC_3+C_1fracB^2t4)exp^-sqrtAt+(sqrtAC_4-C_2fracB^2t4)exp^sqrtAt+C_1fracB^2t4sqrtAexp^-sqrtAt-C_2fracB^2t4sqrtAexp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这里一共有4个未知数:C_1C_2C_3C_4，通过4个边界调节确定：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\nx_1(0)=fracpi4fracpi4fracpi4x_1(1)=000x_2(0)=000x_2(1)=000\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"4个边界方程则可解出4个未知数C_1C_2C_3C_4。实际上C_1C_2C_3C_4是4个向量，每个向量分别对应机器人三部分的参数。在求解时，实际上是12个变量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n也可以通过SymPy直接求解微分方程组。能获得同样的结果。using SymPy  \n@syms t A B λ1() x1() λ2() x2()\neqs = [\nEq(λ1(t).diff(t), -A * λ2(t)),\nEq(λ2(t).diff(t), -λ1(t)),\nEq(x1(t).diff(t), x2(t)),\nEq(x2(t).diff(t), A * x1(t) - B^2 / 2 * λ2(t))\n]\ndsolve(eqs)","category":"page"},{"location":"Control/OptimControl/#.2-参数矩阵求解","page":"最优控制理论与应用","title":"4.2 参数矩阵求解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"下面介绍如何在Julia生态高效计算4个未知数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"需要运用符号处理包——Symbolics.jl。该包在MTK的\"前世今生\"已经介绍过。本篇中也会用到。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using Symbolics, EquationsSolver, LinearAlgebra\n# ==========================functions==================== #\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\n\nfunction x1(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = inv(A) * B * B / 4\n    s = -(B * t) .* exp.(A * t) .* C1\n    s = s .+ exp.(A * t) .* M1\n    s = s .+ (B * t) .* exp.(-A * t) .* C2\n    s = s .+ exp.(-A * t) .* M2\n    return s\nend\n\nfunction x2(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = B * B / 4\n    s = (-B * t .* C1 .+ A * M1 .- inv(A) * B * C1) .* exp.(A * t)\n    s = s .+ (-B * t .* C2 .- A * M2 .+ inv(A) * B * C2) .* exp.(-A * t)\n    return s\nend\n\nfunction SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\n\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\n\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend\n\n\n# ==========================main==================== #\nA, B = initPara()\n# 分别为x1(0) x1(t) x2(0) x2(t)的边界值\nθfields = [[π / 3, -π / 4, π / 2], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\ntfields = (fill(0.0, 3, 1), fill(1.0, 3, 1))\nN = 100\nC1, C2, M1, M2 = Problem(A, B, θfields, tfields)\nt = (0, 1)\n\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\nSolvePro()中，fracB^2t4sqrtA等含有除以矩阵A的式子，在编写时都要写为左乘A的逆矩阵。这是由数学含义决定的，否则结果错误。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述代码的核心思想为：将符号计算与数字计算在形式上统一。核心为函数x1()与x2()。其便捷性在于，若把符号矩阵作为传递给x1()，则x1()计算结果为符号矩阵，若传递数值，则计算结果为数值解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"符号计算解参数：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"function SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在Problem()函数中，定义了12个未知数。\n将符号作为参数传递给condition()并通过其构建待求解方程。如果兴趣可以在函数中Print待求解方程结果。\n通过SolvePro()调用EquationsSolver方程求解器求解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最终可得到12个参数的结果","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"数字计算算结果：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在计算出4个参数向量后，SolvePro()经过结果处理返回参数向量值，再调用x1()与x2()时，则能够得到各时间点的数值。具体的操作方式如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"t = (0, 1)\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在调用x1()与x2()时，不过是传递了不同的参数，就能得到不同结果的类型。传递符号就计算符号，传递数值就计算数值。符号与数值本在数学形式上是一致的，在Julia中则完美地实现了这一点！","category":"page"},{"location":"Control/OptimControl/#.3-解析解可视化","page":"最优控制理论与应用","title":"4.3 解析解可视化","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"degrees = real.(degrees)\nvelocity = real.(velocity)\nusing Plots\nfilename = \"./a.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"t=$(i/N*(t[2]-t[1])+t[1])  \"\n    strings *= \"v₁=\" * string(round.(velocity[i][1], digits=2))\n    strings *= \" v₂=\" * string(round.(velocity[i][2], digits=2))\n    strings *= \" v₃=\" * string(round.(velocity[i][3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i][1])\n    ys1 = l .* cos(degrees[i][1])\n    xs2 = l .* sin(degrees[i][2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i][2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i][3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i][3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上面的实例计算的是机器人初态为theta=fracpi3-fracpi4fracpi2的情况。动图如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi3fracpi4fracpi5的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi18fracpi6fracpi4的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/OptimControl/#数值解","page":"最优控制理论与应用","title":"5 数值解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该问题使用数值解则很好解决，优化问题使用JuMP则迎刃而解。","category":"page"},{"location":"Control/OptimControl/#.1-求解方法","page":"最优控制理论与应用","title":"5.1 求解方法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先看一个示例：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using JuMP, LinearAlgebra, Ipopt, Statistics\n\nθ = [π / 3, -π / 4, π / 2]\nθ = [π / 18, π / 6, π / 4]\nθ = [π / 3, π / 4, π / 5]\nN = 100\ntf = 4.0\n\n#---------------------------------------------#\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\nA, B = initPara()\nmodel = Model(Ipopt.Optimizer)\n@variables(model, begin\n    -π / 2 <= x1[1:N, 1:3] <= π / 2\n    x2[1:N, 1:3]\n    -10 <= u[1:N, 1:3] <= 10\nend)\ninitzeros = zeros(3)\nfor j in 1:3\n    @NLconstraint(model, x1[1, j] == θ[j])\n    @NLconstraint(model, x2[1, j] == initzeros[j])\n    @NLconstraint(model, x1[N, j] == initzeros[j])\n    @NLconstraint(model, x2[N, j] == initzeros[j])\nend\nfor i in 1:N-1\n    a1 = x1[i, :] + (x2[i+1, :] + x2[i, :]) * 0.5 * tf / N\n    a2 = x2[i, :] + (A * (x1[i+1, :] + x1[i, :]) + B * (u[i+1, :] + u[i, :])) * 0.5tf / N\n    for j in 1:3\n        @NLconstraint(model, x1[i+1, j] == a1[j])\n        @NLconstraint(model, x2[i+1, j] == a2[j])\n    end\nend\n@NLobjective(model, Min, sum(20 / π * x1[i, j]^2 + u[i, j]^2 for i in 1:N-1 for j in 1:3))\nJuMP.optimize!(model)\ndegrees = JuMP.value.(x1)\nvelocity = JuMP.value.(x2)\n\n\nusing Plots\nfilename = \"./u_x_a4.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"Numerical t=$(i/N*tf)  \"\n    strings *= \"v₁=\" * string(round(velocity[i, 1], digits=2))\n    strings *= \" v₂=\" * string(round(velocity[i, 2], digits=2))\n    strings *= \" v₃=\" * string(round(velocity[i, 3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i, 1])\n    ys1 = l .* cos(degrees[i, 1])\n    xs2 = l .* sin(degrees[i, 2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i, 2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i, 3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i, 3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该示例包含了求解与可视化，有如下特征:","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"时间采样数（离散数）为：N = 100；\n调节时间为：tf = 4；\n优化变量（扭矩、角度）有范围限制；\n终端对速度也有约束；\n状态方程作为优化问题的约束，约束不同时刻的状态量之间的关联（不同时间的角度值为不同优化变量。角度状态，角速度状态，扭矩状态各有3N个）。状态方程变为离散结构，因为一旦涉及到数值解，必定是离散化的。离散的方式是二阶的梯形法；\n优化目标为sum_j=1^3sum_i=1^Nfrac20pix_1(ij)^2+u_(ij)^2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n离散的概念有两种理解，一种为问题性质上的理解，即问题本身具有离散性质。另外一种是方法上的理解，即求解问题的过程中对于连续问题采用了离散化的方式。问题性质的离散，是变量本身的一种状态或特性，如开关状态的0与1是独立的状态，本身具有不连续的特性。而离散化是对于连续问题的求解方式。问题本身是连续的，但是为了使用数值计算方法求得数值解，需要取“连续”中的一些相互间隔的“离散”点来代表“连续”。例如，微分方程的数值解法欧拉法的步长则是具有“连续”性质的离散。微分方程的数值解法，一定是离散化的方法——在时间域上选取一定步长间隔的点求解。这两者都可以认为是离散问题，而离散化的方法决定了数值计算的精度以及求解的计算量。从方法的层面说，数值计算本身就是离散问题，对于使用计算机进行数值求解来说，不存在连续求解方法。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"对于以上6点，先不做说明，可以先看一些结果。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 5)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况二 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度无限制；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 6)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 8)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况四","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 2；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 9)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况五","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2+u_(ij)^2；\n参数：N = 100，tf = 4；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 10)  ","category":"page"},{"location":"Control/OptimControl/#.2-对比分析","page":"最优控制理论与应用","title":"5.2 对比分析","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（站直且速度为零）与情况二（站直速度任意）为不同边界约束的结果。情况一确实不如情况二“迅猛”，情况一的机器人有些拘束，情况二的动作则一气呵成，因为约束少了。同时，情况一的解析解与数值解结果，机器人动作非常神似。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（最省力）、情况三（距离最短）与情况五（省力也要距离短）为不同优化条件的结果。可以看出来情况五综合了情况一个和情况二的优点。同时，情况五x_1前面的系数目的是为了平衡优化的效果——将角度值与速度值置于同一量级，即加大省距离的权重。这类似于机器学习的正则化。其实他们在内涵上有相通之处，通过权重规定了对不同优化目标的“重视程度”！","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三与情况四的不同之处在于控制量的范围约束与调节时间限制。在数学上来说，不管给定何种始终条件，若控制量u不限制，则一定能完成控制任务（优化问题有解）。所以在条件4的控制量约束下，若是设tf=1，则在求解时找不到最优解，唯有把时间放款才能在控制量约束下找到解。这非常符合实际，控制量不能无限大，控制过程也需要时间。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"事实上，也可以通过解析解来验证这些结论，但解析解的代码量太大，不如数值解来得方便 :) 。例如，同时考虑x与u的解析解结果为 :)：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 11)  ","category":"page"},{"location":"Control/OptimControl/#总结","page":"最优控制理论与应用","title":"总结","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由机器人的最优控制问题，介绍最优问题的解析解与数值解。从两方面基本上已经诠释了最优控制的内涵。即，为了某种目标去找到一组最合适的控制量。事实上，这只是控制的第一步，计算结果都是静态的。接下来还需要根据实际的系统反馈进行时间域上的滚动优化，滚动起来后，就能够利用系统的反馈，实现了真正意义上的控制——对反馈的处理与计算。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"另外，从整个机器人问题求解的过程也可以看出Julia生态的强大之处。当问题清楚之后，灵活使用Julia生态的各种软件包，能方便快捷地计算出结果。事实上，最优控制问题的底层数学形式为两种——求解类问题（解析解）与优化类问题（数值解）。同时，符号计算使得编写代码方便快捷。这三者恰恰是Julia计算的长处。所以Julia处理最优控制问题，可以用两个词来形容——丝滑、顺畅。","category":"page"},{"location":"Modeling/ModelingTutorial/#组织方程的艺术——组件化（入门）","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nContents：建模思想Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/ModelingTutorial/#前言","page":"组织方程的艺术——组件化（入门）","title":"前言","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"Ai4Energy开发者总是张口闭口组件化建模，那么组件化建模的内涵到底是什么？为什么要组件化建模？这篇我们从头至尾介绍做一个组件化思想的入门介绍。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"建模用ModelingToolkit.jl；求解用DifferentialEquations.jl。","category":"page"},{"location":"Modeling/ModelingTutorial/#电路问题","page":"组织方程的艺术——组件化（入门）","title":"电路问题","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以电路系统切入，深入探讨组件化建模的内涵是最合适不过的了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"首先准备2个电路元件的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"欧姆定律：电阻两端的电压与流过电阻电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"U=IR","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容器：电容两端电压的变化率与电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdVdt = fracIC","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nC是电容量，单位为法拉（F）。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"我们再准备一个电路系统，如下图:","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"需要求解的问题是：电容初始电压为0，当开关闭合后，电容电压电流的变化情况是？","category":"page"},{"location":"Modeling/ModelingTutorial/#手搓求解","page":"组织方程的艺术——组件化（入门）","title":"手搓求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手搓的意思是电路中学的传统解法。开关闭合后，视为导线。采用节点电压法求解。标记三个节点1，2，3。节点电压分别为V_1V_2V_3，如下图。整个电路只有一条主路，所以电流为I。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"所以电路的方程为：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"V_1-V_3=1 (V) \nV_1-V_2=1 (Omega) * I\nfracd(V_2-V_3)dt = fracI1 (F) = I\nV_3 = 0 tag1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手动化简之后可以得到2种情况：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留I，化简掉V_1V_3V_2。开关刚闭合，有电容视为导线，则0时刻，I=1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"frac1-Idt = -fracdIdt= I\nI_0 = 1(A) tag2","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留V_2，化简掉V_1V_3I","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdV_2dt = 1-V_2\nV_20=0(V) tag3","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以上微分方程式2或3，求解任何一个，把结果代回方程组1，整个电路系统的情况就可以得到了。这个问题就解决了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面看一看组件化怎么做！","category":"page"},{"location":"Modeling/ModelingTutorial/#组件化求解","page":"组织方程的艺术——组件化（入门）","title":"组件化求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"在之前的基础之上，我们只做一件事情——引入额外的变量。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"为每个器件添加两个端口变量（地只加一个端口）。正极叫p，负极叫n。同时为器件取名，电源叫做source，电阻叫做resistor，电容叫做capacitor，地叫做ground。同时规定，器件索引其子要素的方式为“.”。例如，电阻正极电压的变量全名为resistorpV。如下图所示。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"那么我们新引入了14个变量：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV\nsourceni\nsourcepV\nsourcepi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV\nresistorni\nresistorpV\nresistorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV\ncapacitorni\ncapacitorpV\ncapacitorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地的两个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV\ngroundporti","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再研究一下变量关系，我们可以发现。所有端口电流（地端口除外）的数值都等于I，端口电压值都等于对应的电压节点的电压。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这，貌似就是给V_1V_3V_2I这几个变量加了很多别名？一顿操作猛如虎，细想发现全白干，形式主义我最行？","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面才是主菜！","category":"page"},{"location":"Modeling/ModelingTutorial/#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。","page":"组织方程的艺术——组件化（入门）","title":"Step1: 把V_1V_3V_2I全踢掉，如下图。","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 3)   ","category":"page"},{"location":"Modeling/ModelingTutorial/#Step2.-分别写组件的方程，规定电流入流为正，流出为负：","page":"组织方程的艺术——组件化（入门）","title":"Step2. 分别写组件的方程，规定电流入流为正，流出为负：","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV - sourcenV = 1 (V)\nsourcepI + sourcenI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1 (Omega)\nresistorpI + resistornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracd(capacitorpV - capacitornV)dt = fraccapacitorpI1 (F) \ncapacitorpI + capacitornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地（规定电势为0的点，电流不做要求）：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV = 0\ngroundportI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/#Step3:-构建连接关系","page":"组织方程的艺术——组件化（入门）","title":"Step3: 构建连接关系","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源和电阻连（等价于节点1，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV = resistorpV\nsourcenI + resistorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻和电容连（等价于节点2，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容、电源和地连（等价于节点3，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV = sourcpV = groundportV\ncapacitornI + sourcpI + groundportI= 0\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"稍微思考一下可以发现，上述10多个方程组成的方程大组，其数学本质与方程小组1完全等价！唯一的区别是前者多引入了很多变量，并且这些变量完全可以消去！","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"但是，前者完成了组件化的封装，由此连接关系与组件内部之间成了相互独立的关系。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"什么意思呢？以V_1为例。V_1既是电压源的出口电压又是电阻的正极电压。同时V_1作为节点电压，已经消去了电流的概念。这就意味每节点是不同的。而组件化的内涵就是把这一点拆解成了两部分：连接与组件内部。以电阻的正负极端口为例，对内建立组件内部的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是U=IR；对外建立与其他组件连接：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV = resistorpV\nsourcenI + resistorpI = 0\nresistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是节点电压1和2.","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这么多方程很复杂但逻辑清晰。其实它很简单，因为化简计算机会去做。","category":"page"},{"location":"Modeling/ModelingTutorial/#求对比解","page":"组织方程的艺术——组件化（入门）","title":"求对比解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/#手搓版","page":"组织方程的艺术——组件化（入门）","title":"手搓版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把节点电压法的分析过程，写成ModelingToolkit的代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n在VScode中，输入入V_3就能输入V₃(Image: 图 1)  在VScode中，按下Ctrl+Enter可以执行光标所在行的一行代码。以下的代码可以一行一行执行，看中间结果。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义变量\n@variables t\n@variables V₁(t) V₂(t) V₃(t) I(t)\n\n# 定义微分\nD = Differential(t)\n\n# 设置参数\nR = 1.0\nC = 1.0\nV = 1.0\n\n# 输入方程\nrc_eqs = [\n    V₁ - V₃ ~ V\n    V₁ - V₂ ~ I * R\n    D(V₂) ~ I / C\n    V₃ ~ 0\n]\n\n# 构建系统\n@named rc_model = ODESystem(rc_eqs, t)\n\n# 系统化简\nsys = structural_simplify(rc_model)\n\n# 设置初值\nu0 = [\n    V₂ => 0.0\n]\n# 求解时间范围\ntspan = (0.0, 10.0)\n\n# 构建问题并求解\nprob = ODAEProblem(sys, u0, tspan)\nsol = solve(prob, Tsit5())\n\n# 分别查看 V₁, V₂, V₃ 的变化\nsol[V₂]\nsol[V₁]\nsol[V₃]\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简前的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(rc_model)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简后的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(sys)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"方程中V_1=1，和推导的结果是一致的。","category":"page"},{"location":"Modeling/ModelingTutorial/#组件版","page":"组织方程的艺术——组件化（入门）","title":"组件版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把组件化的过程，写成代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义独立时间变量\n@variables t\n\n# 器件端口作为连接点\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    return ODESystem(Equation[], t, sts, []; name=name)\nend\n\n# 地，地的端口名字改为g，不是port\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0; g.i ~ 0]\n    return compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n# 电阻元件\nfunction Resistor(; name, R=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters R = R\n    eqs = [\n        p.v - n.v ~ p.i * R\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n# 电容元件，因为不能对表达式进行微分，所以再引入一个电容的电压差变量v\nfunction Capacitor(; name, C=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters C = C\n    sts = @variables v(t) = 1.0\n    D = Differential(t)\n    eqs = [\n        v ~ p.v - n.v\n        D(v) ~ p.i / C\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, sts, ps; name=name), p, n)\nend\n# 电压源\nfunction ConstantVoltage(; name, V=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters V = V\n    eqs = [\n        V ~ p.v - n.v\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n\n# 定义组件\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R) # @name可以视为给定义的组件起了个名字，Resistor(R=R)返回的组件名字就叫resistor\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\n\n# 构建连接关系\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t) #连接关系也需要放到ODESystem中。\n\n# 组件与组件连接关系一起构建系统\n@named rc_model = compose(_rc_model,[resistor, capacitor, source, ground])\nequations(rc_model) # 查看方程\n\n# 系统化简\nsys = structural_simplify(rc_model)\nequations(sys) # 查看方程\n\n# 定义初值\nu0 = [\n    capacitor.v => 0.0\n]\n\n# 求解\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\n\n# 查看\nsol[capacitor.v]\nsol[resistor.n.v]\nsol[capacitor.p.v]","category":"page"},{"location":"Modeling/ModelingTutorial/#小结","page":"组织方程的艺术——组件化（入门）","title":"小结","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"引入的组件端口变量作为内部方程与外部连接关系的桥梁，使得组件完整又独立，可以与任意外部组件相连接。连接就去干连接的活，组件内部就管组件内部的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"从另一个角度说，节点电压法需要针对每一个系统做比较复杂的系统分析，因为其包含了某种化简的内涵；而组件化模式则是批量定义组件和批量处理连接关系，最后统一化简。后者更加易于理解与设计计算算法。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化的意义就在于高效复用以提高系统构建效率。因为组件都是由开发者写好的，用户只需要构建连接关系，系统即可搭建好。这也是为什么说组件化是关于方程组织的艺术了，本质还是那个本质，只是换一种变量与方程的组织模式。电路系统的组件化是组件化思想的体现之一。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化建模实例简要介绍了组件化建模思想。\nAi4EComponentLib.jl中系统的设计方法，都体现了组件化思想。\nAi4EComponentLib.jl设计理念介绍了更高层次的抽象组件内涵。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"最后，思考如何用节点电压法解下图的电路，以及如何用组件搭建。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2) ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其实思考之后就会发现组件化构建的优点：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"高复用性：节点电压法构建需要自己写组件的特性方程；组件化不需要，不管它内部是什么牛鬼蛇神，组件写好了就能拿来用。之后就一个事——连接。定义组件的过程就是对组件内部方程的重用。\n高易用性：一旦组件设计好了，构建连接关系不需要再动脑子了，照着系统图哪里有节点连哪里不就完事了？剩下精髓，是如何去设计一个系统，不再需要考虑组件底层。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n提问：我们上面手敲代码定义组件和构建连接的过程，与在Simulink中通过图形化界面拖一个组件连一个线的过程，有本质的区别吗？如果你觉得没有区别，恭喜，你已经大致掌握流程模拟仿真软件底层架构的逻辑了。","category":"page"},{"location":"Modeling/ModelingTutorial/#练习","page":"组织方程的艺术——组件化（入门）","title":"练习","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"尝试用上面写好的组件构建上图系统并求解。同样的，都假设电容电压初值为0。","category":"page"},{"location":"Frameworks/OptControl/#OptControl.jl设计理念","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"tip: Tip\nContents：OptControl：最优控制问题的解释器Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"note: Note\nOptControl地址。arXiv文章引用","category":"page"},{"location":"Frameworks/OptControl/#摘要","page":"OptControl.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题。OptControl.jl(OptControl)基于Julia语言，实现了最优控制的符号化建模过程，并生成相应的基于Julia生态的最优控制问题的数值优化求解代码。OptControl没有定义数据类型(struct)，而是通过处理字符生成解决方案脚本，并在内部解析并运行脚本。OptControl也提供保存脚本文件到本地的接口。同时，OptControl支持组件化建模，这让构建复杂系统的最优控制问题变得简单。OptControl的依赖包完全来自于Julia生态。","category":"page"},{"location":"Frameworks/OptControl/#Motivation","page":"OptControl.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题，更准确的说是一个泛函求极值问题。从实现的角度，最优控制的解析解只有在特定的几种情况下才能求出，例如线性系统。而实际问题中往往需要面对非线性系统或者一些复杂的系统，这些问题的解析解一般而言难以求得。因此，能算出结果的数值解则是一个利器。虽然数值解在结果上会有一些偏差，但有偏差的结果也能带给人们一定理解问题的灵感。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的数值解法一般而言可以转化为数值优化问题。数值优化问题可以使用JuMP.jl来求解。使用JuMP.jl求解一个最优控制问题，可以分为5步：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"抽象实际问题\n获得状态方程模型\n构建数值优化模型\n生成JuMP模型\n求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，JuMP.jl完成了第4步，第5步的内容由具体的求解器完成。但JuMP.jl在完成第4步的基础上，提供了到第5步的接口。因此也可以认为，JuMP.jl包揽了第4步和第5步的工作。那么整个问题需要留给用户解决的，还有前3步。它们的关系由下图所示。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，第一步包含了从实际问题到数学表达的抽象过程，这一过程只有高级的人脑才能完成。那么，第2步和第3步能否实现自动化呢？这正是OptControl所希望完成的内容。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的重点在于自动化，即如何自动构建最优问题，如何自动构建JuMP优化模型以及调用求解器自动求解。如何求解一个最优问题，如何构建符号化的系统等类型的问题，OptControl都不涉及。OptControl关心的是，整合已有的资源（Julia生态中的各种软件包），尽可能地自动化完成上述5个步骤。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以可以视OptControl是一个解释器，实现状态空间模型到最优控制问题的转化。它有三个特点：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"接受Symbolics.jl或ModelingToolkit.jl构建的基于符号系统的状态空间模型\n自动生成以JuMP模型表达的最优化问题求解脚本，并自动运行\n提供保存脚本文件的接口，供用户自由修改","category":"page"},{"location":"Frameworks/OptControl/#OptControl框架","page":"OptControl.jl设计理念","title":"2 OptControl框架","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的能力是逐步提高的。","category":"page"},{"location":"Frameworks/OptControl/#.1-构建优化模型","page":"OptControl.jl设计理念","title":"2.1 构建优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"首先完成的是第3步到第5步的解决方案。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes——处理线性系统\ngenerateNLJuMPcodes——处理非线性系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes与generateNLJuMPcodes接受以符号形式表达的状态方程。符号表达通过Symbolics.jl构建。Symbolics.jl是一个拥有高性能，并能够以用户语言进行拓展的符号代数系统。用符号表达的状态方程能够转变成Julia函数，通过该函数对问题进行离散化处理，将离散后的模型中的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 3)  ","category":"page"},{"location":"Frameworks/OptControl/#.2-获得状态方程模型","page":"OptControl.jl设计理念","title":"2.2 获得状态方程模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"更进一步，我们希望自动化实现第2步到第5步。第2步到第5步的解决方案需要使用ModelingToolkit.jl的非因果组件建模系统。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes——处理ODESystem系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes接受ODESystem系统。ODESystem中描述系统的微分方程事实上就是最优控制问题的状态方程。它们的区别是，ODESystem系统中的某些变量在最优控制问题中是状态量，而另一些是控制量。换而言之即，在最优控制中的状态方程与仿真系统中的微分方程本质上是相同的，不同的是最优控制问题赋予了某些变量特殊的含义。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes使用ModelingToolkit.jl中的generate_function函数生成Julia函数，并使用函数进行离散，将离散后的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。2.1与2.2中解决方案的思路是相同的。它们都生成了Julia函数。2.1中的函数来自Symbolics.jl符号矩阵，2.2中的函数来自ModelingToolkit.jl中的ODESystem。OptControl利用生成的Julia函数进行状态空间的离散，并构建JuMP优化模型。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 4)  ","category":"page"},{"location":"Frameworks/OptControl/#OptControl中的数学推演","page":"OptControl.jl设计理念","title":"3 OptControl中的数学推演","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-仿真或者控制？","page":"OptControl.jl设计理念","title":"3.1 仿真或者控制？","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的中描述系统的方程为:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx(t)=boldsymbolAboldsymbolx(t)+boldsymbolBboldsymbolu(t)=fboldsymbolx(t)boldsymbolu(t)ttag1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，boldsymbolx(t)是系统的状态向量，boldsymbolu(t)是系统的控制量向量。它们都是关于自变量t的函数，也就是说它们随时间的变化而变化。事实上，在控制问题中，系数矩阵boldsymbolAboldsymbolB也是可以随时间而变化的，则变为boldsymbolA(t)boldsymbolB(t)。这根据实际需要而定。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"省去关于时间的函数表达，上述方程可以简写成：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=boldsymbolAboldsymbolx+boldsymbolBboldsymbolu=f(boldsymbolxboldsymbolut)tag2","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果从数学的角度思考，不考虑boldsymbolxboldsymbolu的物理含义，这是一个关于时间的常微分方程问题。如果boldsymbolu的值不人为地决定，而是在系统中自我演化。那么这个就是一个微分方程求解问题。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)tag3","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解该微分方程的在真实世界中对应系统的动态仿真。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以，控制问题和动态仿真问题的本质是相同的。系统的描述方程都为关于时间的微分方程（组）。不同之处在于，问题的中的某些变量是否可以人为介入改变。也可以说，动态仿真问题是我们希望看到系统是如何演化的，而控制问题是，我们希望系统按照我们的期望去演化。正因为我们有期望，所以我们需要介入，对系统进行人为干预。而在方程中的体现是boldsymbolu，boldsymbolu是对系统干预的数学表达。所以，如果我们构造了boldsymbolu而不改变它，即它没有起到干预的作用，那这样的问题仍然是一个动态仿真问题。因为人的影响并没有通过boldsymbolu传递到系统。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这正是为何OptControl能够用ModelingToolkit.jl构建系统的原因。ModelingToolkit.jl原本是用来构建动态仿真问题的工具，ODESystem描述的是动态系统的仿真模型，它并不存在可以人为干预系统的接口——控制变量boldsymbolu。我们可以构建ODESystem，观察系统是怎样变化的，而不能从头至尾地控制它的演化方向（事实上，偶尔的干预是可以通过Callback功能实现的，但它远没有达到“控制”的内涵）。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"但我们只要稍加改变，就能够将仿真问题转变为控制问题。只需要给ODESystem中的某些变量加上控制属性，工作就完成了。这正是OptControl使用的方法——把ODESystem中的参数boldsymbolp变为了控制量boldsymbolu。就得到到了控制问题中状态空间方程的最原始形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)Rightarrow dotboldsymbolx=f(boldsymbolxboldsymbolut)tag4","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"为了实现这一点，在构建ODESystem时需要做一点设计——需要把我们系统中某需要转变为控制量的变量设置成参数boldsymbolp。","category":"page"},{"location":"Frameworks/OptControl/#.2-最优控制怎样最优","page":"OptControl.jl设计理念","title":"3.2 最优控制怎样最优","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上一节中我们探讨了boldsymbolu的内涵。那么还剩下一个问题是，如何用于数学语言描述最优。整个最优问题可以分为两个部分，控制过程中的最优以及控制终态的最优。方程5表示对最优的一个目标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min Phi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt  tag5","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，Phi(boldsymbolx(t_f)t_f)表示对终端状态的一个期望，积分int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt表示控制过程中的期望状态达到的最小指标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程2和方程5合起来，就成为了最优控制问题控制方程的一般形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdtst hspace10cm dotboldsymbolx =\nfboldsymbolx(t)boldsymbolu(t)t \nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/#.3-数值优化模型","page":"OptControl.jl设计理念","title":"3.3 数值优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程6是连续形式，如果采用数值优化方法则需要将其离散化。离散方法采用欧拉法，则有:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_iboldsymbolu_it_i)*dt\nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果采用后退欧拉法则有：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_i+1boldsymbolu_i+1t_i+1)*dt\nendmatrix tag7","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"此外，还有很多的离散方法，如梯形法，亚当斯方法等等。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"一旦获得了方程6和方程7的结果，下一步可以用JuMP.jl来构建相应的JuMP模型，以便调用相关的求解器求解。这由OptControl自动化地完成。","category":"page"},{"location":"Frameworks/OptControl/#求解实例","page":"OptControl.jl设计理念","title":"4 求解实例","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-Case1:-线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.1 Case1: 线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrix01 newline 00endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(2)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用OptControl求解该问题的步骤是：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl描述系统方程\n确定初态和终态等参数\n调用generateJuMPcodes求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, Statistics, ModelingToolkit\n@variables t u x[1:2]\nf = [0 1; 0 0] * x + [0, 1] * u\nL = 0.5 * u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"该最优问题中，x_1的解析解是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"x_1(t) = 05*t^3-175*t^2+t+1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"比较解析解和优化数值解，可以得到它们的均方差是2.696E-6。在这个误差下的结果即使不能使用，它也是极具参考意义的，能给与人们启示。","category":"page"},{"location":"Frameworks/OptControl/#.2-Case2:-非线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.2 Case2: 非线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下非线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrixexpcos newline sin1endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(1)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl定义符号变量，给定初态和终态。调用generateNLJuMPcodes则可以得到结果。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n@variables t u x[1:2]\nf = [exp(x[1]) + cos(x[2]), sin(x[1]) + x[2]] + [1, 0] * u\nL = u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateNLJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/#.3-Case3:-RC电路系统最优控制","page":"OptControl.jl设计理念","title":"4.3 Case3: RC电路系统最优控制","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这是一个简单的电路系统。电源电压1V，电阻1欧姆，电容1法拉。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"我们构造的最优控制问题是，电压如何变化才能使得电容电压在1s内从1V变化到3V的同时，满足整个过程中电压尽可能低的目标。这在物理上是有意义的，但是可能没有应用价值。但它能充分说明问题所在。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n\n# Components ......\n\n# Define and Simplify System\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R)\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, capacitor, source, ground])\nsys = structural_simplify(rc_model)\n\n# Build Optimal Control Problem and Solve\nL = 0.5 * (source.V^2)\nt0 = [1.0]\ntf = [3.0]\ntspan = (0.0, 1.0)\nN = 100\nsol = OptControl.generateMTKcodes(L, sys, states(sys), [source.V], tspan, t0, tf;N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上述代码的组件来自于ModelingToolkit.jl的文档。如果是一个仿真问题，当ODESystem被化简完成后应该需要调用DifferentialEquations.jl来求解。现在是一个最优控制问题，所以我们指定优化目标，以及定义相关参数，通过generateMTKcodes求解。","category":"page"},{"location":"Frameworks/OptControl/#结论","page":"OptControl.jl设计理念","title":"5 结论","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl实现了从状态方程到最优控制问题的自动化构建以及从ModelingToolkit的常微分方程系统到系统最优控制问题的自动化构建。问题的核心在于选择设计控制变量boldsymbolu。在状态空间方程离散过程中，OptControl提供了选择离散方法的接口。在未来的工作中，会发展更多离散方法。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl另外一个重要特点是，它不直接解决问题，而是生成解决方案脚本并解释运行。这意味OptControl像一个指挥者，它把问题分解，再调用Julia生态中的包解决问题。OptControl提供了获得脚本的接口，这意味当OptControl的功能不能满足你的需求时，你可以直接修改脚本。在它基础之上添加任何你需要的功能。如果你不熟悉JuMP的建模语言，那么你正好可以通过生成的脚本学习一些JuMP的高级用法。如果你还想选择一些不同的求解器，那就修改脚本吧。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"在未来，OptControl也许会提供更多的接口。但它不会改变指挥者的角色。也就是说，OptControl会一直致力于自动化生成最优控制问题的解决方法，而不是像ModelingToolkit.jl和JuMP.jl发展一种建模语言，也不会像JuMP.jl调用的求解器一样发展求解算法。OptControl的初衷是打通壁垒，整合工具，方便快捷的解决最优控制的问题。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"编程中函数的本质是把具有一定功能性代码整合起来，可以重复的使用。至于函数内部的实现，你可以认为就是一个黑箱。但是我得告诉你我这个黑箱中有什么功能。就像快递收发点一样，怎么运输的你不用管，但是我得有个目录告诉你有些什么选择和对应的收费标准。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"c语言中，stdio等库就是这么个情况，把很多有用的函数封装在一起，成为一个库（静态和动态我们等会儿再说），库里有什么则通过stdio.h这个文件告诉你，同时stdio.h也告诉你了要以什么样的参数方式调用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"人们可以把一些函数封装成库，提供给用户服务。c语言就有很多这样的库，你写程序的时候，就可以调用c语言自带的这些库函数。编译的时候，你的c语言源代码会编译成.o文件，但是要做成exe文件，还需要把库里所有要用到的那些函数代码嵌入进来，这种方式就是静态的链接到了你的exe文件中。提供的这些库，就称呼为静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"而如果某些函数使用率非常的高，或者你自己脑回路清奇，或者乐意，你也可以把那些用到的函数不嵌入进来，只是告诉你的exe程序，需要用到某个库中的某个函数，在运行的时候才加载那个库，调用库里的函数。这样的方式就是动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在windows下，静态链接库一般是lib为后缀名，动态链接库一般是dll为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在linux下，静态链接库一般是a为后缀名，动态链接库一般是so为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在mac os x 下，动态链接库一般是dylib为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"我们在julia中可以很方便的调用动态链接库里的函数。详情请见julia调用dll中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库是什么","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库是什么","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库（Dynamic Link Library，DLL）是一种在多个程序之间共享代码和数据的可执行文件格式。DLL包含一组可重用的函数、类、变量和资源，可以被不同的应用程序或进程调用和使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"与静态链接库（Static Link Library）不同，DLL在运行时才加载到内存中，并且可以由多个应用程序同时使用。这种共享的特性带来了一些优势：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"节省内存空间：由于多个应用程序可以共享同一个DLL，所以不同的应用程序不需要在内存中加载相同的代码和数据，从而节省了内存空间。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"代码和数据的更新和维护：如果需要更新DLL中的代码或数据，只需更新DLL本身，而不需要重新编译和链接所有使用该DLL的应用程序。这样可以简化代码的维护和更新过程。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"提供标准化的功能和接口：通过使用DLL，可以将常用的功能和接口封装在一个共享的库中，使得多个应用程序可以共享这些标准化的功能，减少了代码冗余和重复开发。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在Windows操作系统中，DLL文件具有特定的文件扩展名 \".dll\"，并且可以通过动态链接方式进行加载和调用。应用程序可以使用特定的函数调用语法来调用DLL中的函数，从而实现对DLL中功能的使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"需要注意的是，由于DLL是共享的，因此在使用DLL时需要注意版本兼容性和依赖关系。如果一个应用程序依赖于某个DLL的特定版本，那么必须确保该DLL的版本可用，并且正确配置应用程序的运行环境，以避免出现兼容性问题。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"总之，动态链接库是一种方便共享代码和数据的可执行文件格式，它提供了灵活性、代码重用和资源共享的好处，被广泛用于软件开发中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用c语言，CMake工具，来个例子","page":"静态链接库和动态链接库","title":"使用c语言，CMake工具，来个例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当使用CMake构建动态链接库或静态链接库时，您需要编写CMakeLists.txt文件来描述构建过程。下面是一个示例，展示如何使用C语言生成一个动态链接库和一个静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为mylib的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建库的CMake文件。\nmylib.h - 库的头文件。\nmylib.c - 库的源代码文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib_shared SHARED ${SOURCES})\n\n# 生成静态链接库\nadd_library(mylib_static STATIC ${SOURCES})\n\n# 设置库的输出名称\nset_target_properties(mylib_shared PROPERTIES OUTPUT_NAME \"mylib\")\nset_target_properties(mylib_static PROPERTIES OUTPUT_NAME \"mylib\")\n\n# 设置库的安装路径\ninstall(TARGETS mylib_shared mylib_static\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n\n# 设置头文件的安装路径\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_library命令来创建动态链接库和静态链接库。set_target_properties命令用于设置库的输出名称，这里设置为\"mylib\"。install命令用于指定库的安装路径和头文件的安装路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建库，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成动态链接库（libmylib.so）和静态链接库（libmylib.a）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把库文件和头文件安装到默认的系统路径（例如，/usr/local/lib和/usr/local/include）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#对应的c语言源文件","page":"静态链接库和动态链接库","title":"对应的c语言源文件","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"非常抱歉，这里是一个示例的C源文件mylib.c，用于生成动态链接库和静态链接库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们定义了两个简单的函数：add和subtract。这些函数的实现位于mylib.c文件中，并在mylib.h文件中进行了声明。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"您可以将这个mylib.c文件放在与CMakeLists.txt相同的目录中，然后按照上述说明使用CMake来构建动态链接库和静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#头文件呢？","page":"静态链接库和动态链接库","title":"头文件呢？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当生成动态链接库或静态链接库时，您需要一个头文件来声明库中的函数和数据结构。在上一个示例中，我忘记包含头文件mylib.h的内容，非常抱歉。以下是正确的mylib.h头文件内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请将上述代码保存到名为mylib.h的文件中，并确保与CMakeLists.txt和mylib.c文件位于同一个目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这个头文件声明了两个函数：add和subtract，这些函数的实现位于mylib.c文件中。通过包含这个头文件，其他源文件就可以使用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这次提供的信息对您有所帮助！如果您还有其他问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#如何调用","page":"静态链接库和动态链接库","title":"如何调用","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当调用生成的动态链接库或静态链接库时，您需要创建一个主函数文件，并使用CMake来构建项目。下面是一个示例，展示如何编写主函数文件和CMakeLists.txt文件来调用生成的库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为myapp的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建应用程序的CMake文件。\nmain.c - 主函数文件，用于调用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 添加库的源文件\nset(SOURCES main.c)\n\n# 生成可执行文件\nadd_executable(myapp ${SOURCES})\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)\n\n# 设置库的搜索路径\nlink_directories(/path/to/mylib)\n\n# 设置库的头文件路径\ninclude_directories(/path/to/mylib)\n\n# 设置可执行文件的安装路径\ninstall(TARGETS myapp DESTINATION bin)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_executable命令创建可执行文件，并使用target_link_libraries命令将生成的库（这里假设为mylib）链接到可执行文件中。通过link_directories和include_directories命令，我们设置库的搜索路径和头文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建应用程序，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建应用程序：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成可执行文件（myapp）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装应用程序到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把可执行文件安装到默认的系统路径（例如，/usr/local/bin）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要根据实际情况修改link_directories和include_directories中的路径，以确保正确链接和包含库的头文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这个示例对您有所帮助！如有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用clion来一个step-by-step生成动态链接库的例子","page":"静态链接库和动态链接库","title":"使用clion来一个step by step生成动态链接库的例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"使用CLion来生成动态链接库的步骤如下：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 mylib.c。\n编写您的库的实现代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 mylib.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 创建头文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的头文件，例如 mylib.h。\n在头文件中声明您的库的函数和数据结构。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是 mylib.h 的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 编辑CMakeLists.txt","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目根目录下找到 CMakeLists.txt 文件，并编辑它。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个基本的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib SHARED ${SOURCES})\n\n# 设置库的安装路径\ninstall(TARGETS mylib LIBRARY DESTINATION lib)\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 5: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中生成动态链接库。生成的动态链接库将位于 build/lib 目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以在 CMakeLists.txt 中添加以下安装规则：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"install(TARGETS mylib LIBRARY DESTINATION /usr/local/lib)\ninstall(FILES mylib.h DESTINATION /usr/local/include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行 Reload CMake Project 和 Build 命令后，库将安装到 /usr/local/lib 和 /usr/local/include 路径中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这样，您就可以在CLion中使用CMake逐步生成动态链接库了。如果您有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#调用如何进行？","page":"静态链接库和动态链接库","title":"调用如何进行？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是在CLion中调用动态链接库的步骤：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 main.c。\n编写您的主函数代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 main.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include <stdio.h>\n#include \"mylib.h\"\n\nint main() {\n    int result = add(5, 3);\n    printf(\"Addition result: %d\\n\", result);\n\n    result = subtract(5, 3);\n    printf(\"Subtraction result: %d\\n\", result);\n\n    return 0;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 添加动态链接库的引用","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开项目的 CMakeLists.txt 文件。\n在 add_executable 行之前，添加 add_library 行来引用动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是修改后的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 引用动态链接库\nadd_library(mylib SHARED IMPORTED)\n\n# 设置动态链接库的路径\nset_target_properties(mylib PROPERTIES IMPORTED_LOCATION /path/to/mylib.so)\n\n# 添加可执行文件\nadd_executable(myapp main.c)\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中将动态链接库引用到可执行文件中。然后，您可以在CLion中运行项目，查看调用动态链接库函数的结果。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径，并确保动态链接库文件存在。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这个步骤对您有所帮助！如果您有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#能否简单补充一下CMake是什么？","page":"静态链接库和动态链接库","title":"能否简单补充一下CMake是什么？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当然可以！CMake是一个开源的跨平台构建系统，用于管理软件项目的构建过程。它使用名为CMakeLists.txt的文本文件来描述项目的构建配置，并根据此配置生成适合各种构建工具（如make、Ninja等）的构建文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake的主要优势在于它提供了一种简化和抽象构建过程的方式，使得开发者可以更方便地管理复杂的项目结构和依赖关系。通过CMake，您可以编写平台无关的构建脚本，这意味着您可以在不同的操作系统和编译器上使用相同的CMake配置来构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake使用类似于编程语言的语法，提供了丰富的命令和变量，用于定义项目的源文件、目标、库依赖关系、编译选项等。通过编写CMakeLists.txt文件，您可以描述项目的组织结构、源代码文件、库的构建方式等细节，从而使得构建过程更加灵活和可定制。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在使用CMake构建项目时，通常的步骤是：创建CMakeLists.txt文件，定义源文件和目标，指定库的依赖关系和链接选项，然后运行CMake来生成构建文件，最后使用构建工具进行实际的构建操作。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake已被广泛使用，并且许多开源项目和跨平台项目都使用CMake来管理其构建过程，使得项目在不同的平台和编译器上更容易构建和交付。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这个简要的补充对您有所帮助！如果您有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#作业","page":"静态链接库和动态链接库","title":"作业","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请自己完成静态链接库及其调用。使用CLion，CMake。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#视频链接","page":"静态链接库和动态链接库","title":"视频链接","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库和静态链接库","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE（对比MTK）","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nContents：DE、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\nDE = DifferentialEquations.jlPDE = Partial Differential EquationDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE","page":"DE求解PDE（对比MTK）","title":"DE求解PDE","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在MTK手动空间离散求解PDE中介绍了手动空间离散的思想。本篇中将通过手动PDE求解传热问题对DE与MTK进行一个小对比。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE构建的问题过程中，需要把问题推演至求解之前。求解之前的部分都需要手动完成。MTK手动空间离散求解PDE中提到，求解PDE的数值方法有这么几步：建立数学描述方程、对变量进行离散、迭代求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把问题进一步细化，则变为：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"Step1:建立数学描述方程\nStep2:网格生成（变量离散）\nStep3:生成求解格式\nStep4:迭代求解","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK完成了Step3、Step4的内容，而DE只能帮我们完成Step4的内容。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\n如果我们仔细琢磨，会发现：如果是基于时间微分的组件化建模。使用MTK时，我们完成Step1的内容，剩下MTK全包了！所以这也是为什么说，MTK提供了基于时间的一条龙求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们来看看，DE是如何完成Step4的内容的。同时，也会让大家对数值求解过程有一个更加深刻的理解。","category":"page"},{"location":"Simulation/DE_heattran/#数值传热学实例","page":"DE求解PDE（对比MTK）","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"考虑MTK手动空间离散求解PDE中正方形铸件的散热过程。节点的离散结果如下（不再推导）：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"内节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"边边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"角边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"这里，我们进一步对问题进行拓展。正方形铸件初始温度1000℃，环境温度为一个变化的值：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"T_f = 400 * (1 + sin(t))","category":"page"},{"location":"Simulation/DE_heattran/#求解实例","page":"DE求解PDE（对比MTK）","title":"求解实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"using ModelingToolkit, DifferentialEquations\nusing Dates\n\nprintln(\"=====DE TEST=====\")\nstarttime = now()\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\np = [A, B, n]\nfunction to_index(i, j, n)\n    return (i - 1) * n + j\nend\nfunction heat!(dT, T, p, t)\n    A, B, n = p\n    n = Int(n)\n    Tf = 400.0 * (1 + sin(t))\n    # 内部节点\n    for i in 2:n-1\n        for j in 2:n-1\n            dT[to_index(i, j, n)] = A * (T[to_index(i + 1, j, n)] + T[to_index(i - 1, j, n)] + T[to_index(i, j + 1, n)] + T[to_index(i, j - 1, n)] - 4 * T[to_index(i, j, n)])\n        end\n    end\n    # 边边界\n    for i in 2:n-1\n        dT[to_index(i, 1, n)] = A * (T[to_index(i + 1, 1, n)] + T[to_index(i - 1, 1, n)] + T[to_index(i, 2, n)]) - (3B + A) * T[to_index(i, 1, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(i, n, n)] = A * (T[to_index(i + 1, n, n)] + T[to_index(i - 1, n, n)] + T[to_index(i, n - 1, n)]) - (3B + A) * T[to_index(i, n, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(1, i, n)] = A * (T[to_index(1, i + 1, n)] + T[to_index(1, i - 1, n)] + T[to_index(2, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(n, i, n)] = A * (T[to_index(n, i + 1, n)] + T[to_index(n, i - 1, n)] + T[to_index(n - 1, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    # 角边界\n    dT[to_index(1, 1, n)] = A * (T[to_index(2, 1, n)] + T[to_index(1, 2, n)]) - (2B + 2A) * T[to_index(1, 1, n)] + 2B * Tf\n    dT[to_index(n, n, n)] = A * (T[to_index(n - 1, n, n)] + T[to_index(n, n - 1, n)]) - (2B + 2A) * T[to_index(n, n, n)] + 2B * Tf\n    dT[to_index(n, 1, n)] = A * (T[to_index(n, 2, n)] + T[to_index(n - 1, 1, n)]) - (2B + 2A) * T[to_index(n, 1, n)] + 2B * Tf\n    dT[to_index(1, n, n)] = A * (T[to_index(2, n, n)] + T[to_index(1, n - 1, n)]) - (2B + 2A) * T[to_index(1, n, n)] + 2B * Tf\nend\nu0 = [1000.0 for i in 1:n for j in 1:n]\nprob = ODEProblem(heat!, u0, (0, 100), p, saveat=1)\nsol = solve(prob, Tsit5())\nendtime = now()\nprintln(\"time use:\"*string(endtime - starttime))","category":"page"},{"location":"Simulation/DE_heattran/#可视化","page":"DE求解PDE（对比MTK）","title":"可视化","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画走你！","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"an_len = length(sol.u)\nusing Plots, GR\nres = rand(n, n, an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i, j, t] = sol.u[t][to_index(i, j, n)]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\nPlots.contourf(xs, ys, res[:, :, 1])\nanim = @animate for i ∈ 2:an_len\n    contourf!(xs, ys, res[:, :, i])\nend\ngif(anim, \"DE_trans.gif\", fps=24)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"以上代码对比之前，有所改变的是：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"saveat","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们把时间拉长，同时saveat的时间步长变成了1s。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/#求解速度对比","page":"DE求解PDE（对比MTK）","title":"求解速度对比","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"跑相同的问题：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK用时：2.407s\nDE用时：0.810s","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"可见，Step3的符号化简与DE问题生成的确需要消耗不少的资源。","category":"page"},{"location":"Simulation/DE_heattran/#关于内涵的理解","page":"DE求解PDE（对比MTK）","title":"关于内涵的理解","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK与DE两种方法都能够求解PDE问题。为什么这样做能行呢？下面分享一些关于问题内涵的思考。","category":"page"},{"location":"Simulation/DE_heattran/#空间离散的物理内涵","page":"DE求解PDE（对比MTK）","title":"空间离散的物理内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画中可以清晰感受到外围颜色的震动，这是我们设定环境温度波动的结果。若要把环境温度变化以微分方程的形式定义，同样可行。只需要再添加一个变量关于时间相关的变量即可。而这个随时间的变化的环境温度，是真正驱动系统变化的变量，它的变化是由时间决定，而不受其它网格影响。相反，其它网格受到环境温度变量的影响。可以说，环境温度变量是独立于网格离散而存在的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"由此，我们可以聊一聊关于空间离散的内涵。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在以上的传热实例中，系统的根本“驱动力”在于温差。也就是说，因为温差的存在，才会让系统产生变化。而我们在空间离散时，其实并没有对这种变化进行处理。我们手动空间离散的内涵是：在不同网格间，架起了让网格相互联系的桥梁。其本质描述了网格和网格之间的联系。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"从高数中微元的角度思考，只要网格足够小，那么我们就可以得到非常精确的模拟结果；从物理内涵的角度思考，不管网格如何小，任何一个网格都可以视为一个小组件，这个小组件的特性有：温度、边长、导热系数等等，并且在小组件内部，这些属性的数值视为不变。而空间离散，就是建立了这些小组件之间的关联。这种思想在数值计算领域是一种专业的离散方式——有限容积法。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"所以，以上空间离散的思想内涵就和之间组件化建模的思想内涵统一起来了。区别在于，空间离散出来的结果是微元，组件化建模的模型结果是宏观组件。 但是，不同组件（微元）之间需要建立相互联系的桥梁这一点是不变的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"如果深入思考传热的内涵——由温差引起的热量传递。我们也能发现，以小组件的形式看待微元网格，其物理逻辑也是非常自洽的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把空间离散赋予物理内涵（微元组件化）后，剩下的问题也很清晰了——组件在时间域上的变化。组件之间的连接建立好之后，当外界环境（温度）随时间动态变化，组件的属性（温度）也会发生相应的变化。这不就是时间域上动态系统的求解内涵吗？只是我们不会把描述时间微分的方程离散，而是把它丢给求解器去解。","category":"page"},{"location":"Simulation/DE_heattran/#迭代格式的数学内涵","page":"DE求解PDE（对比MTK）","title":"迭代格式的数学内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"迭代格式数学内涵中最关键的一环是函数to_index()","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"function to_index(i, j, n)\n    return (i - 1) * n + j\nend","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK中采用T[i, j]的网格描述方式，这是从物理位置中对网格进行了一种描述。这种描述中是附加由物理含义的——空间位置。而这种附加了物理含义的变量描述，底层求解器是无法求解的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE能求解的方程是什么样的呢？如下所示：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"leftbeginarrayc\ny_1^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right) y_2^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  ldots y_n^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  y_1left(x_0right)=y_10 y_2left(x_0right)=y_20 ldots y_nleft(x_0right)=y_n 0endarrayright","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"写成统一的格式即：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"mathbfyprime=mathbff(mathbfxmathbfy)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\n求解微分方程的数值解法主要有：欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_iy(x_i)right)+Oleft(h^2right)后退欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_i+1y(x_i+1)right)+Oleft(h^2right)梯形法yleft(x_i+1right)=yleft(x_iright)+frach2leftfleft(x_iy_i right)+fleft(x_i+1y_i+1right)right+Oleft(h^3right)辛普森方法yleft(x_i+1right)=yleft(x_i-1right)+ frach3leftfleft(x_i-1y_i-1right)+4fleft(x_iy_iright)+fleft(x_i+1y_i+1right)right+Oleft(h^5right)标准龙格库塔法leftbeginarrayc\ny_i+1=y_i+frac16left(K_1+2 K_2+2 K_3+K_4right) \nK_1=h fleft(x_i y_iright) \nK_2=h fleft(x_i+frac12 h y_i+frac12 K_1right) \nK_3=h fleft(x_i+frac12 h y_i+frac12 K_2right) \nK_4=h fleft(x_i+h y_i+K_3right)\nendarrayright其中，h为求解的步长。各方法阶数为（阶数越高精度越高）：方法 阶数\n欧拉法 1阶\n后退欧拉法 1阶\n梯形法 2阶\n辛普森方法 4阶\n标准龙格库塔法 4阶","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"对于这样的数学描述方式，y可以视为微分变量的数组，f(xy)视为变量之间的联系。那么y=f(xy)的含义是：微分与其它变量之间的关联。这种关联是不包含物理内涵的。而二维数组T[i, j]包含了位置关系。所以要去位置化，就需要把二维映射到一维上。所以我们采用(i - 1) * n + j将二维索引展平为一维。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"本质是通过to_index()消除了物理位置含义。生成了DE可计算的描述方式——最原始最根本的微分方程组数学描述方式。这一步就是前面所说的Step3。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"总的来看，DE求解我们手动完成了Step2、Step3、Step4。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nMTK求解时。Step3、Step4由程序完成。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#以SAM为例实操","page":"以SAM为例实操","title":"以SAM为例实操","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM是什么","page":"以SAM为例实操","title":"SAM是什么","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL (National Renewable Energy Laboratory) 的 SAM (System Advisor Model) 是一个广泛应用于可再生能源系统分析和评估的计算工具。SAM 可以帮助研究人员、工程师和政策制定者评估各种可再生能源项目的技术和经济可行性。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 提供了一系列模块，涵盖了太阳能、风能、生物质能、地热能等多个可再生能源技术。使用 SAM，用户可以建立虚拟的可再生能源项目，并对其进行系统级的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 的主要功能包括：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"建模工具：SAM 提供了丰富的建模工具，可以创建和配置各种可再生能源系统。用户可以定义系统的组件、能源资源、电网连接等。\n技术性能模型：SAM 包含了各种可再生能源技术的技术性能模型，例如太阳能光伏电池板的发电模型、风力涡轮机的功率曲线等。这些模型基于广泛的实验数据和经验，并提供了高精度的技术性能预测。\n资金成本模型：SAM 还提供了成本模型，可以帮助用户估算可再生能源项目的资金成本。这些成本模型包括设备成本、建设成本、运营维护成本等。\n经济性分析：SAM 可以对可再生能源项目进行经济性分析，包括计算项目的净现值、内部收益率、年均收益等经济指标。这有助于评估项目的可行性和经济效益。\n市场分析：SAM 还提供了市场分析模块，可以评估可再生能源项目在不同市场条件下的竞争力和盈利潜力。用户可以模拟不同的电力市场、能源政策和投资条件，以了解项目在不同情景下的表现。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的GitHub地址是：https://github.com/nrel/SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关于NREL和SAM的官方网站，您可以访问以下链接获取更多信息：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL官方网站：https://www.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM官方网站：https://sam.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总而言之，NREL 的 SAM 是一个功能强大的可再生能源系统分析工具，可以帮助用户评估和优化可再生能源项目的技术性能、经济可行性和市场前景。它在可再生能源领域的研究、工程设计和政策制定中发挥了重要作用。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的组件构成","page":"以SAM为例实操","title":"SAM的组件构成","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的组件构成主要包括以下几个部分：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC（SAM Simulation Core）：SSC是SAM的内核，是一个用C++编写的计算引擎。它提供了可再生能源系统模拟和分析的核心功能，包括模型计算、数据处理和结果生成等。SSC负责处理技术性能模型、成本模型、经济模型等方面的计算。\nGUI（Graphical User Interface）：SAM的GUI是一个可视化界面，提供了图形化的用户界面，使用户可以通过交互方式创建、配置和分析可再生能源项目。GUI简化了输入参数的设置和结果的可视化，使用户更方便地使用SAM进行建模和分析。\nSDK（Software Development Kit）：SDK是一个开发工具包，用于扩展SAM的功能和自定义模块。SDK提供了一组API和文档，使开发人员可以根据自己的需求开发新的模型、算法或工具，并与SAM进行集成。\nDatasets：SAM还包括一系列数据集，用于提供输入参数和参考数据。这些数据集包括天气数据、设备性能数据、成本数据等，可以帮助用户进行准确的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"综上所述，SAM的核心是SSC，它提供了计算引擎和模型库，支持可再生能源系统的建模和分析。GUI提供了图形化界面，使用户可以通过可视化方式操作SAM。SDK则允许开发人员进行功能扩展和定制化开发。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的windows下的编译过程","page":"以SAM为例实操","title":"SAM的windows下的编译过程","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当使用SAM进行编译时，以下是SAM的编译过程的基本步骤和解释：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"源代码收集：首先，需要获取SAM的源代码。您可以从SAM的GitHub存储库中获取源代码，并将其下载到本地计算机中。\n依赖项安装：在编译之前，需要安装SAM所需的依赖项和开发工具。这些依赖项可能包括编译器、构建工具、库文件等。您可以查阅SAM的文档或README文件，了解所需的依赖项和安装说明，并确保在编译之前正确安装它们。\n配置编译环境：为了成功编译SAM，您需要配置适当的编译环境。这可能包括设置编译器选项、环境变量、路径设置等。根据您的操作系统和编译工具，您可能需要执行一些特定的设置步骤。确保按照指南进行正确的环境配置。\n构建项目：一旦环境配置完成，您可以开始构建SAM项目。这通常涉及使用构建工具（如Makefile或CMake）执行构建命令。构建过程会编译源代码文件，并将它们转换为可执行文件或库文件。构建过程可能需要一些时间，具体取决于项目的规模和计算机的性能。\n编译错误解决：在编译过程中，可能会出现错误或警告。这些错误可能是由于缺少依赖项、语法错误、库文件问题等引起的。如果出现编译错误，您需要仔细阅读错误消息，并在代码中找到并修复问题。通常，错误消息会提供有关问题所在的线索，例如错误的行号或函数名称。\n构建成功：一旦编译过程成功完成，您将获得SAM的可执行文件或库文件。这些文件可以用于在您的计算机上运行SAM，并开始使用它的功能。确保验证编译的结果，并根据需要进行必要的配置和安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"通过以上步骤，您可以通过SAM的编译过程理解程序编译的 step by step 流程。请注意，编译过程可能因操作系统、编译工具和项目的特定要求而有所差异。因此，建议您参考SAM的文档和指南，以获取针对SAM的具体编译说明和最佳实践。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这里是Windows下如何编译SAM的官方说明。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"以下是其中文翻译： Windows构建说明","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这些说明适用于在您的计算机上设置构建SAM Windows版本所需的几个开源C++代码库。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"更新于2022年7月","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"概述 构建工具 要构建SAM，您需要构建CMake、wxWidgets和Google Test：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake是一套用于构建软件的工具集：https://cmake.org/。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"wxWidgets是一个用于开发用户界面的平台：https://www.wxwidgets.org。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Google Test是一个C++测试框架：https://github.com/google/googletest。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"版本控制和协作 SAM的代码存储库存储在GitHub.com上，因此您需要使用Git进行工作的工具。这些说明假设您已经安装了Git并熟悉它。（如果您需要使用Git进行SAM的帮助，请参阅此基本教程。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Git是版本控制和协作软件：https://git-scm.com/ 源代码 构建SAM所需的C++和其他代码存储在GitHub.com上的LK、WEX、SSC和SAM存储库中：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LK是SAM的内置LK脚本语言：https://github.com/nrel/lk。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"WEX包含了对wxWidgets的自定义用户界面增强功能：https://github.com/nrel/wex。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC是用于SAM性能和财务模型的代码：https://github.com/nrel/ssc。（SSC API和PySAM Python软件包提供了对SSC的访问权限，供其他软件应用程序使用。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM是用于SAM用户界面的代码：https://github.com/nrel/SAM。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private存储库包含了SAM官方NREL版本的代码。只有在与NREL的SAM软件开发团队合作构建官方NREL版本的SAM时，才需要这些代码。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private是用于用户注册、欢迎页面、Web API密钥和其他SAM官方NREL版本的功能的代码：https://github.com/nrel/SAM-private。 开发和修补分支 每个存储库的Develop分支包含最新的代码。如果您要贡献代码，应从该分支开始工作。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"每个存储库的Patch分支在发布新版本的SAM后的几个月内处于活动状态。在此期间，如果您要贡献代码以更新当前版本，应从Patch分支开始工作。（完成和批准工作后，应将Patch分支合并到Develop分支。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GitHub.com上的默认分支为Develop，除了在更新期间，此时默认分支设置为Patch。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM版本的标签 要构建特定版本的SAM，可以检出该版本的标签。请参阅此标签列表，了解SAM、SSC、WEX和LK的不同版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总体构建步骤 整个设置和构建过程应该需要1到2个小时，具体取决于您选择每个步骤的选项和互联网下载速度。计算机设置完成后","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"，首次构建SAM可能需要几分钟时间。后续构建速度较快，具体取决于构建选项以及在构建之前修改的代码量。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装Visual Studio Community 2022（10分钟，需要Microsoft账户和计算机重新启动）。\n下载并构建wxWidgets 3.2.0（10分钟）。\n下载并安装CMake 3.24或更高版本（5分钟）。\n克隆并构建Google Test（需要CMake）（5分钟）。\n克隆SAM代码存储库（根据互联网速度，可能需要10-20分钟）。\n设置环境变量（5分钟）。\n为Visual Studio生成SAM项目文件（需要CMake）（5分钟）。\n构建SAM（对于SAMOS的干净构建需要10分钟，构建所有项目需要更长时间）。\n测试构建结果。\n下载并安装Visual Studio Community 2022","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您的计算机上尚未安装Visual Studio Community 2022 (VS 2022)，请从https://visualstudio.microsoft.com/下载并安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用VS 2022需要一个免费的Microsoft账户，当您首次启动程序时，系统会提示您创建或输入账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行Visual Studio安装程序，并选择以下三个工作负载：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"C++桌面开发\nPython开发（用于SAM与Python的集成）\nC++ Linux和嵌入式开发（用于CMake）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您的计算机上安装了其他版本的Visual Studio，您可以与其他版本并存安装和运行VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并登录到您的Microsoft账户或创建一个新账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并构建wxWidgets 3.2.0","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的用户界面使用的是wxWidgets 3.2.0，这是截至2022年7月7日的最新稳定版本。其他版本的wxWidgets可能与SAM兼容也可能不兼容。您可以从https://www.wxwidgets.org/downloads/下载不同版本的wxWidgets。在页面底部的\"Other Downloads\"下的GitHub Release Archive中，提供了以前的版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/wxWidgets/wxWidgets/releases/tag/v3.2.0下载Windows源代码，可以选择ZIP或7Z文件。将文件解压到计算机上的一个文件夹中，例如c:/wxWidgets-3.2.0。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并打开c:/wxWidgets-3.2.0/build/msw/wx_vc17.sln解决方案文件。该目录中有适用于其他版本的Visual Studio的项目文件，因此请确保打开vc17文件。vc17解决方案适用于VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建64位的Debug和Release版本：在VS 2022的工具栏中，选择Release配置和x64平台，然后按F7键或从Build菜单中选择Build Solution。构建完成后，选择Debug x64并进行构建。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会看到构建了24个项目成功的消息。在c:/wxWidgets-3.2.0/build/msw中，您还应该看到vcx64-mswu和vcx64-mswud文件夹，每个文件夹中都有几个文件夹和.pch文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装CMake","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM需要CMake 3.24或更高版本来为Windows、Linux和Mac生成构建文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://cmake.org/download/下载最新版本的Windows x64安装程序。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行安装程序，按照提示安装CMake，并勾选“将CMake添加到系统路径中”选项，可以选择单个用户或所有用户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"安装程序应自动将C:/Program Files/CMake/bin添加到Windows系统路径中。要验证，请在Windows开始菜单中输入\"env\"，打开\"环境变量\"窗口，双击系统变量下的Path变量。如果路径列表中没有该路径，您可以手动添加。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"克隆并构建Google Test SAM的代码存储库依赖于Google Test C++单元测试框架。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/google/googletest.git克隆Google Test。在命令窗口中执行以下命令：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/my/repos git clone https://github.com/google/googletest.git 在问题https://github.com/NREL/ssc/issues/806解决之前，切换到提交b85864c64758dec007208e56af933fc3f52044ee：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest git checkout b85864c64758dec007208e56af933fc3f52044ee 这样就会显示HEAD is now at b85864c6 Eliminate the legacy GTESTCOMPILEASSERT_ macro.","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入包含ci、docs、googlemock和googletest的顶级googletest文件夹，并创建一个build文件夹：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/googletest/build 进入刚创建的build文件夹：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest/build 运行CMake生成Visual Studio项目文件：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，在CMake命令的末尾使用两个句点..，以确保命令能够找到父文件夹中的CMakeLists.txt文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKECONFIGURATIONTYPES=\"Release;Debug\" -Dgtestforceshared_crt=ON .. 如果CMake成功，您应该会看到path/to/googletest/build/googletest/gtest.sln文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在VS 2022中打开gtest.sln文件，并构建x64的Debug和Release配置。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会在path/to/googletest/build/lib中看到包含gtest.lib等文件的Release和Debug文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"克隆SAM代码存储库","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"创建一个父文件夹来存储这些存储库，例如path/to/sam_dev：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/sam_dev 将每个存储库克隆到父文件夹中。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev git clone https://github.com/nrel/lk git clone https://github.com/nrel/wex git clone https://github.com/nrel/ssc git clone https://github.com/nrel/sam 如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM，请选择使用Web浏览器身份验证方式验证您的GitHub.com账户是否有权访问该存储库：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/sam-private","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"设置环境变量","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的构建工具使用Windows环境变量来确定它所需文件在计算机上的存储位置。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关闭任何打开的命令窗口以及正在运行的VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开Windows系统属性窗口，在\"高级\"选项卡上，点击\"环境变量\"，或在Windows搜索栏中输入\"env\"并点击\"编辑系统环境变量\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在用户变量列表中，点击\"新建\"，并为下表中的每一项输入变量名和值。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"例如，如果您将LK存储库放在c:/samdev/lk中，您将把环境变量的名称设置为\"LKDIR\"，其值设置为\"c:/samdev/lk\"（不需要输入引号）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LKDIR\tpath/to/samdev/lk WEXDIR\tpath/to/samdev/wex SSCDIR\tpath/to/samdev/ssc SAMNTDIR\tpath/to/samdev/sam RAPIDJSONDIR*\tpath/to/sam_dev/ssc *RAPIDJSONDIR是一个单独的环境变量，用于支持不依赖于SSC的WEX构建。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMNRELDIR\tpath/to/sam_dev/SAM-private 创建以下用户变量，指向Google Test、wxWidgets和CMake的文件夹：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GTDIR\tpath/to/googletest WXMSW3\tpath/to/wxWidgets-3.2.0 CMAKEBUILDDIR\tpath/to/sam_dev/build 关闭系统属性窗口。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"生成 SAM Visual Studio 2022 项目文件","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这一步是在首次构建 SAM 以及从 LK、WEX、SSC 或 SAM 存储库中添加或移除 .cpp 源文件后所需的。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用文本编辑器在 SAM 的父文件夹中创建一个名为 CMakeLists.txt 的 \"总体 CMake 文件\"（在我们的例子中为 path/to/sam_dev/CMakeLists.txt），其内容如下：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake_minimum_required(VERSION 3.24)\n\nset(CMAKE_OSX_DEPLOYMENT_TARGET \"10.15\" CACHE STRING \"Minimum OS X deployment version\")\nif (UNIX AND NOT CMAKE_C_COMPILER)\n    set(CMAKE_C_COMPILER gcc)\n    set(CMAKE_CXX_COMPILER g++)\nendif()\n\nif(MSVC)\n    set(CMAKE_CONFIGURATION_TYPES \"Debug;Release\" CACHE STRING \"Debug and Release Builds Configured\" FORCE)\nendif()\n\nproject(system_advisor_model)\n\noption(SAMPRIVATE \"Release build of SAM\" OFF)\n\nadd_subdirectory(lk)\nadd_subdirectory(wex)\nadd_subdirectory(ssc)\nadd_subdirectory(sam)\nif (SAMPRIVATE)\n    add_subdirectory(SAM-private)\n    add_subdirectory(SAM-private/webupd)\nendif()","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开一个终端窗口，并在 SAM 的父文件夹中创建一个名为 build 的文件夹（path/to/sam_dev/build）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果这不是你第一次构建 SAM，而且你想删除旧的构建（除非你在构建过程中遇到问题或重新运行 cmake 后添加了 .cpp 文件到其中一个存储库，否则不需要删除旧的构建）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nrmdir /Q/S build\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"现在，你应该有一个 SAM 的目录结构，它看起来像这样（对于我们的示例，这将是 path/to/sam_dev 的内容）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"build\nlk\nsam\nssc\nwex\nCMakeLists.txt","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入你上面创建的 build 文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行 CMake 以生成 Visual Studio 解决方案和项目文件。该命令为 SAM 的开源版本构建了 Debug 和 Release 文件，这对于大多数开发任务足够了。如果要构建官方的 NREL 版本的 SAM，并/或者生成用于 PySAM 的 API 文件，请选择下面描述的适当的 CMake 选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，CMake 命令的末尾有两个句点 ..，以确保运行你在父文件夹中创建的 CmakeLists.txt 文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKE_CONFIGURATION_TYPES=\"Debug;Release\" -DSAM_SKIP_AUTOGEN=1 -DSAMAPI_EXPORT=0 -DSAMPRIVATE=0 -DCMAKE_SYSTEM_VERSION=10.0 ..","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当 CMake 完成后，你应该在 path/to/samdev/build/ 文件夹中看到 systemadvisor_model.sln Visual Studio 解决方案文件以及支持文件、Debug 和 Release 文件夹，以及分别包含 SAM、","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC、WEX 和 LK 的文件夹等其他文件和文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果出现有关缺少文件的构建错误，请检查环境变量以确保它们被正确命名并指向正确的文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake 选项","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，每个选项在 cmake 命令中的前面都有字母 \"D\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMAKECONFIGURATIONTYPES","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建调试、发布版本或两个版本的选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"\"Debug\" = 为调试版本构建文件。如果你打算使用 VS 2022 的调试工具，请选择此选项。 \"Release\" = 为发布版本构建文件。选择此选项可在不使用 VS 2022 的调试工具的情况下运行 SAM。 \"Debug;Release\" = 为调试和发布版本构建文件。 SAMSKIPAUTOGEN","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"跳过从 export_config 自动生成 SAMAPI 文件。SAMAPI 文件用于 PySAM Python 包。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 跳过 SAMAPI 文件的生成。当不需要生成 SAMAPI 文件时，使用此选项可以加快构建时间。 0 = 重新生成文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。 SAMAPI_EXPORT","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"将 SSC 二进制文件导出到 SAMapi 文件夹。这些文件用于 PySAM Python 包。（Unix 还会编译 SAMAPI 的库文件）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 导出二进制文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。 0 = 不导出。当不需要构建 PySAM 文件时，使用此选项可以加快构建时间。 SAMPRIVATE","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"为官方的 NREL 发行版本的 SAM 构建解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 在解决方案中包括私有 (SAM) 和开源 (SAMOS) 项目。如果你正在构建官方的 NREL 发行版本并且可以访问私有的 SAM-private 存储库，请使用此选项。 0 = 在解决方案中只包括开源 (SAMOS) 项目。如果你正在构建 SAM 的开源版本，请使用此选项。 CMAKESYSTEMVERSION CMake 版本号。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"（可选，但推荐）：在 path/to/sam_dev 文件夹中添加一个 .editorconfig 文件，以确保你的代码与项目标准一致的格式化。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建 SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动 VS 2022，打开上一步中的 systemadvisormodel.sln 解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在大多数情况下，你只需要构建 SAMOS 项目：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在解决方案资源管理器中选择 SAMOS 项目（如果看不到解决方案资源管理器，请按 Ctrl+; 显示它）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从窗口顶部的工具栏中选择 Release 或 Debug。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从“生成”菜单中选择“构建 SAMOS”（或按 Ctrl+B）。这将从 SAM、SSC、WEX 和 LK 以及其他依赖项目构建出 SAM 的可执行版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建解决方案中的所有项目比仅构建 SAMOS 需要更长时间，会创建 SDKtoool 和 TCSconsole 的可执行文件，并生成大量用于 PySAM 的 API 文件，你可能不需要。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你有权限构建官方 NREL 版本的 SAM，并在上面的 cmake 命令中使用了 SAMPRIVATE = 1 选项，将会有两个 SAM 项目：SAMOS 是 SAM 的开源版本，而 SAM 是官方 NREL 版本的 SAM。构建 SAMOS 来测试官方版本特定的功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"官方版本（SAM）需要注册密钥才能运行，并包括从 SAM 用户界面下载 NSRDB 天气文件、URDB 电费数据和 Cambium 市场价格数据等功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"开源版本（SAMOS）可以在没有注册密钥的情况下运行。如果你想在 SAMOS 中使用下载功能，请修改 path/to/samdev/sam/src/private.h 添加有效的 API 密钥。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"默认情况下，VS 2022 的启动项目设置为 ALL_BUILD。如果你想在 VS 2022 中从“调试”菜单运行 SAM，或者按 Ctrl+F5 或 F5 键而不构建不必要的其他项目，可以将启动项目更改为 SAMOS（或 SAM，如果是官方 NREL 版本的 SAM）。要更改启动项目，请在解决方案资源管理器中右键单击项目名称（SAMOS 或 SAM），然后单击“设置为启动项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你的代码贡献涉及添加或更改输入的默认值，你应该在构建中包含 exportconfig 和 SAMapi，以更新用于 PySAM 的文件中的默认值。这需要在上面的 cmake 命令中使用 -DSAMSKIPAUTOGEN=0 和 -DSAMAPIEXPORT=1，以便这些项目在你的 Visual Studio 解决方案中可用。为了避免同时运行两个作业时的冲突，你只需要构建一个 Release 版本即可。（对于此目的来说，构建调试和发布版本是多余的，例如，没有 exportconfigd.exe。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"你还可以使用批量构建来选择要构建的项目：在“生成”菜单中，点击“批量生成”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在构建解决方案后，通过启动 SAM 并运行模拟来","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建。可执行文件取决于你构建的版本：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的开源版本，请转到 path/to/sam_dev/SAM/deploy/x64 并运行 SAMOS.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的官方 NREL 版本，请转到 path/to/samdev/SAM-private/buildwindows/deploy/x64 并运行 SAM.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"调试版本位于相同的文件夹中，但文件名中包含 \"d\"：SAMOSd.exe 和 SAMd.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进行基本功能测试：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 启动后，在 SAM 的欢迎页面上，点击“开始新项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"选择“光伏”、“详细光伏模型”和“分布式”、“住宅业主”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在 SAM 窗口左下方点击“模拟”。SAM 应该运行模拟并显示结果。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“模拟”按钮下方点击“宏”，选择其中一个宏名称，然后点击“运行宏”或“查看代码”。你应该看到宏代码，表示 LK 构建正确。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“位置和资源”页面上，点击“查看数据”。一个 DView 窗口应该打开，表示 WEX 项目的 DView 构建正确。（SAM 还使用 DView 在“结果”页面上显示数据。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你正在测试官方 NREL 版本，请在“位置和资源”和“电费”页面上测试下载功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#小结","page":"以SAM为例实操","title":"小结","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果不明白，请查看前面6条内容。ssc实际编译完就是ssc.dll这个动态链接库。sam额外加了gui壳，以方便用户使用。lk只是sam提供的一个脚本语言，忽略它。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#写在最后","page":"以SAM为例实操","title":"写在最后","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果对git不懂，请参考我们系列文档的git介绍。对cmake不懂请参考我们的make和makefile介绍。仍然不明白，请自行借助网络搜索引擎。编译完之后，把前面讲过的内容再想一想，体会一下。每一步大概都是在干啥，为什么。","category":"page"},{"location":"Optimization/systemParaEste/#MTK符号系统参数辨识","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste/#原理","page":"MTK符号系统参数辨识","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"MTK与DE在问题层面具有一致性。MTK是符号处理的软件包，问题的求解仍然推给DE。而DEPE是从DE的problem层面构建的参数优化问题，所以使用MTK进行建模后，依然可以使用DEPE进行参数估计。对于DEPE来说，不管是MTK还是DE，它接受的问题都是DE的Problem。所以，不管是使用MTK还是DE构建模型，到DEPE这一层面都是贯通的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"下面以RC电路模型为例，进行电路中正弦电压源的电压值估计。","category":"page"},{"location":"Optimization/systemParaEste/#RC组件建模","page":"MTK符号系统参数辨识","title":"RC组件建模","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"基于ModelingToolkit，建立RC电路模型，模型如下图所示。这是一个震荡电路 (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#构建组件","page":"MTK符号系统参数辨识","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"首先完成电路模型的组件编写，一共有5个组件，分别是电源、电阻、电容、电感、接地","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，系统一共定义有4个参数，分别是电阻值，电容值，电感值以及电压的最大值","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0/24)\n@named source = ChangeableVoltage(vol=10.0)\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n          connect(source.p, capacitor.p)\n          connect(capacitor.n, inductor.p)\n          connect(inductor.n, resistor.p)\n          connect(source.n,resistor.n,ground.g)\n         ]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n     ]\nP=[3.0,1.0/24,0.1,10.0]  #系统的参数\nprob = ODAEProblem(sys, u0, (0, 10.0),P)\nsol = solve(prob, Tsit5())\n\np1 = plot(sol,vars=[capacitor.v capacitor.p.i],xlims = (0,10),ylim = (-10,15))\np2 = plot(sol,vars=[inductor.v inductor.i],xlims = (0,10),ylim = (-5,5))\nplot(p1,p2,layout=(2,1))\n","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"运行代码可以得到结果图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"电容的电压电流、电感的电压电流都是震荡的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"初值向量P分别对应4个参数的参数值，电压值为最后一个，设定为10.0","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"在不知道参数的顺序时，可以使用parameters函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"parameters(sys)","category":"page"},{"location":"Optimization/systemParaEste/#建立问题","page":"MTK符号系统参数辨识","title":"建立问题","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"为了能够模拟参数辨识，给其中一个变量加上扰动（这里依旧采用手动生成数据的思想，可能保证模型与数据匹配）。可以使用states函数查看系统变量（在组件设计过程中定义的）。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"states(sys)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"这里对两个变量都添加扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using RecursiveArrayTools\nt = collect(range(0,stop=10,length=1000)) # 建立时间向量\nrandomized = VectorOfArray([(sol(t[i]) + .5randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)  ","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"对sol的结果，选取了1000个点作为样本点加入扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"加入的扰动的方式是：通过生成绝对值小于0.5的随机数加入到从sol中选取出来的样本点中去，将其作为需要参数辨识的样本数据。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"看一看扰动生成的结果：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"p1=plot(t,data[1,:],ylim=(-8,8))\np1=plot!(t,data[2,:],ylim=(-8,8))\np2=plot(sol,vars=[inductor.i,capacitor.v],ylim=(-8,8))\nplot(p1,p2,layout=(2,1))","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"产生的结果图为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#辨识过程","page":"MTK符号系统参数辨识","title":"辨识过程","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"参数辨识使用DiffEqParamEstim，","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using DiffEqParamEstim\ncost_function = build_loss_objective(prob,Tsit5(),\nL2Loss(t,data),maxiters=10000,verbose=false)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"通过buildlossobjective建立了辨识模型，即通过该函数可以求处理后的样本点与模型计算结果的方差和（L2Loss），当然方差和只是作为拟合的评价指标之一，可以选取不同的函数或者构建不同的指标。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"接下来，看一看不同的电压值，带来的方差和的变化。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"vals = 0:0.1:20.0\nplot(vals,[cost_function([3.0,1.0/24,0.1,i]) for i in vals],yscale=:log10,\n     xaxis = \"Parameter\", yaxis = \"Cost\", title = \"1-Parameter Cost Function\",\n     lw = 3)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"val为从0开始，到20，步长为0.1。对这些电压值，去匹配模型，算出来的与样本值的方差和会不同。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"结果为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，在10.0的地方，方差和最小（因为设定的值就是10.0，扰动是在此基础之上叠加的）。说明辨识结果有效。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"以上是通过“肉眼”观察的出来的结果。科学的方法是求一组参数，使得方差和最小。这是一个最优化问题。使用Optim","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using Optim\nresult = optimize(cost_function, [3.0,1.0/24,0.1,15])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"将电压的初始值设为15去寻优，得到的结果为：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.975801390547115\n 0.04266590691854741\n 0.09999565290932136\n 9.923607580088433","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"和真实值是非常接近的！寻优有效！","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"也可以将4个初始值都改变去寻优。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"result = optimize(cost_function, [2.0,0.1,0.5,16])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"得到的结果也很好","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.972037379476059\n 0.04300492580277582\n 0.09998659716890046\n 9.911215185371102","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。","category":"page"},{"location":"tengfeibei/#腾飞杯","page":"腾飞杯","title":"腾飞杯","text":"","category":"section"},{"location":"tengfeibei/#**腾飞杯招募**","page":"腾飞杯","title":"腾飞杯招募","text":"","category":"section"},{"location":"tengfeibei/#腾飞杯项目简介信息","page":"腾飞杯","title":"腾飞杯项目简介信息","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"自我介绍：能动研二杨景懿，感兴趣的研究方向是：系统的建模、仿真、优化与控制。个人主页。QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"目前已有核心开发人员3名，指导老师1名。","category":"page"},{"location":"tengfeibei/#主题","page":"腾飞杯","title":"主题","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"云仿真平台（具体名字待定），简单理解为：网页版Simulink（或者网页版AspenPlus，网页版gproms，网页版modelica，本质都一样）","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"暂定赛道：科技发明制作A类","category":"page"},{"location":"tengfeibei/#技术框架","page":"腾飞杯","title":"技术框架","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"前后端分离。前端VUE3，后端Julia，通过json交互。","category":"page"},{"location":"tengfeibei/#已有进展","page":"腾飞杯","title":"已有进展","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"所有代码、文档可在Github上自行查看。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"我们的Ai4Energy开源组织：https://github.com/ai4energy\n模型库Ai4EComponentLib.jl，现在已有的有可压缩组件库（空压系统），不可以压缩组件库（管道系统），电化学库（光伏、电解槽、电池等），热力循环库（各类循环等）\njson解析器：Ai4EMetaPSE.jl\nAi4ELab，Julia的web框架。但是灵活性不够高，希望用VUE3开发。\n求解器采用开源求解器。\n前端页面参考：https://github.com/yaolunmao/vue-webtopo-svgeditor","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"总结：高可拓展性的后端框架已经完成，完整作品的上线测试运行只差前端。","category":"page"},{"location":"tengfeibei/#招募队员","page":"腾飞杯","title":"招募队员","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"招募2-3名队员。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"负责内容：基于该VUE实现做开发，打造自己的作品。 要求：专业不限，年级不限。动手能力强，具有钻研精神。热爱程序设计。能投入。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"有兴趣的同学联系+QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"tip: Tip\n基于上述介绍，我们是踏实严肃的且有货的开发团队，不鸽不水。\n本网页是我们开放的文档库，可自行学习浏览。\n我们的目的是打造作品，只要东西能做出来，队长、队员重要程度什么的都好商量。最后，腾飞杯只是一个展示平台。比赛过后，我们的组织依旧会传承与发展，我们的目标是星辰大海~ 抛开比赛，欢迎有热情、有激情的同学加入，共同学习、成长与开发。","category":"page"},{"location":"Simulation/componementModel/#组件化建模实例","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/componementModel/#MTK符号建模","page":"组件化建模实例","title":"MTK符号建模","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"在DifferentialEquations建模方法与ModelingToolkit建模方法中介绍DE与MTK的两种建模方式。分析了使用它们建模的具体步骤与实现方法，并介绍了相应的内涵。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这一篇中主要介绍符号建模的另一个强大功能——组件化建模。","category":"page"},{"location":"Simulation/componementModel/#RC电路建模实例","page":"组件化建模实例","title":"RC电路建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"仿真如下图的电路系统：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend\n\n\n\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]\n\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nsol[resistor.p.i]\np1 = plot(sol, vars=[capacitor.v capacitor.p.i], xlims=(0, 10), ylim=(-20, 20))\np2 = plot(sol, vars=[inductor.v inductor.i], xlims=(0, 10), ylim=(-5, 5))\nplot(p1, p2, layout=(2, 1))","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"结果如图所示：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"主要的过程有以下几步：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件\n定义组件实例\n连接系统\n化简\n设置初值\n构建问题并求解\n结果处理","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件过程中主要有两方面考虑，系统内部结构与系统对外接口。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"内部结构则是各个组件内部的数学特性。对于电阻有： V=R*I","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电容有： fracdVdt=fracIC","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电感有： fracdIdt=fracVL","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这些关系可以在模型构建时体现。这是系统的内部变量之间的决定关系。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"外部结构是模块化的另一个关键部分。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"RC的接口体现在函数Pin()上，每一个组件都由两个Pin——输入引脚与输出引脚。这完全是抽象出来的，引脚存在的意义就是为了连接。每个引脚有自己的电压值（更准确的说是电势大小）以及电流。这些变量的引入只是为了跟好地模块化。例如，器件A的出口引脚与器件B的进口引脚相连，它们在电路模型中完全可以视为一个等价的点。为了使模块变得更加完整，分化出来各自的引脚。事实上，这些引脚变量在最后计算时，被化简消除了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"所以，在模块化的过程中为了使个组件变得完整，会派生出很多变量，这些变量都是“锦上添花”的存在，不具备决定性意义。但它们又是使各模块间能够衔接的必要存在。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"组件实例化中的@named的作用是给相应组件命名，每个组件的本质都是一个ODESystem，不同的组件不过是ODESystem中存储的方程不同。ODESystem中有一个成员为name，@named把实例的名称赋值给这个成员变量。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"例如,下面两种定义方式是等价的。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n\nresistor = Resistor(R=3.0;name =:resistor)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"rc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"依据系统的拓扑结构进行连接。connect函数可以接受任意参数个（并联中多点连接的问题就解决了）。连接的本质是建立模块间的联系，连接模块内部的机理，一旦连接绑定，这些变量的使命就完成了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"化简的过程中，会把多余的中间变量都消去。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sys = structural_simplify(rc_model)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"查看各组件各变量的求解结果：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sol[resistor.p.i]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"值得一提的是，在求解的过程中会化简，但是依旧可以查看这些变量的求解结果。方法如示例所示。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib.jl设计理念","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"tip: Tip\nContents：Ai4EComponentLib：Julia组件模型库Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"note: Note\nAi4EComponentLib地址。arXiv文章","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#摘要","page":"Ai4EComponentLib.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib是基于Julia语言构建的组件化模型库。它依赖于微分方程求解器DifferentialEquations.jl与符号建模工具Modelingtoolkit.jl。面向不同的物理领域的问题，Ai4EComponentLib尝试使用组件化建模的方法去构建它们。在新一代符号建模工具的支持下，使用Ai4EComponentLib构建的模型比传统的用Modelica构建的模型更加灵活，并具有更高的可拓展性。本文将介绍Ai4EComponentLib模型库的实例与通用建模思想。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Motivation","page":"Ai4EComponentLib.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在建模仿真领域，已经存在着许许多多的建模工具，例如Modelica、gProms、Simulink等等。它们在不同领域中都发挥着重要的作用，这些工具也已经成为科研工作者的必备工具。但这并不意味着，它们是完美无暇的。以开源的Modelica为例，Modelica拥有自己的编译器，能将建模语言编译成C语言。对于仿真问题来说，它形成了一个完备的解决方案链条。但它的缺陷是，不易扩展。它不能向外扩展形成优化问题的解决方案（参数辨识、最优控制问题）等等。而Julia生态中的ModelingToolkit就解决了扩展性不足的问题。在符号建模体系下，它具有高可拓展性。基于ModelingToolkit的工作，Ai4EComponentLib构建了一些模型库，期望在将来能够利用其高可拓展行的优势。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib设计理念","page":"Ai4EComponentLib.jl设计理念","title":"2 Ai4EComponentLib设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib设计系统的方法与传统的组件化建模思想是相通的。但由于ModelingToolkit的高可拓展性，我们将用更高一层的抽象来看待这个问题。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件建模的核心在于过程，以及过程中的物质能量流动。建模过程中的两个关键点为：内部过程与外部连接。设计一个系统，也就是设计它们的内部过程与外部连接。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现有一个系统，系统中有3个组件A, B and C，如图所示，每个组件有各自的输入输出节点（如a1、a2等），其输入输出特性如箭头所示。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1) ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1-内部过程","page":"Ai4EComponentLib.jl设计理念","title":"2.1 内部过程","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"各模块内部有自身的特性。即输入输出量之间在节点内部产生的反应与物质信息交换的过程。在组件与组件之间是各不相同的。这些机制反映了模型对现实实体的映射，是不同的数学物理现象的抽象。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如上图组件A的a1、a2、a3。在组件内部，它们有特定的数学关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"f(a1a2a3) = 0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在这里f(a1a2a3)是一种通用的函数形式，它可以是微分方程，也可以是代数方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，对于电阻组件，同样的电压差加在一个不同电阻的两端，流过的电流大小不同。若电阻是随时间变化的，那么系统的电流也是随时间变化的。“不同的电阻”与“随时间变化的电阻”都是组件的特性，在设计组件时，通过不同的方程f来描述。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些方程就决定了“物质能量流动”流经组件时的变化。一旦系统中的组件确定了，整个系统的特性就能够通过这些组件确定下来。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-外部连接","page":"Ai4EComponentLib.jl设计理念","title":"2.2 外部连接","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建系统连接时，我们关注点在于连接点的物质和能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如电路系统。电路系统的a2作为组件的出口，电流与电势值是必要的属性。同时，每个组件的进出口都存在电流与电势。所以，在电路系统中，电流与电势是连接系统的“物质流”。\n例如水流管道系统（不考虑势能）。管道系统的a2作为组件的出口，水流的压力与流速是必要的属性。每个组件的进出口都存在水压与流速属性。所以，在管道系统中，水压与流速连接系统的“物质流”。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"具体的物质流动关系，我们需要根据特性系统的数学模型来构建。例如，电路系统中的基尔霍夫定律，管道流动的伯努利方程。控制方程是描述系统的基础。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在外部的连接特性中，一般都必须遵循守恒定律——能量守恒与质量守恒：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag1","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于状态量，如电压、水压、气体压力。一般有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于过程量，如电流、水流量、气体流量。一般有（规定流入为正，流出为负）：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2+b 1=0  b 3+c 2 =0a 3+c 1=0\nendarrayrighttag3","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#系统实例","page":"Ai4EComponentLib.jl设计理念","title":"3 系统实例","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1-不可压缩管道系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1 不可压缩管道系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"当管道中液体为不可压缩流体时，系统的控制方程为伯努利方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +fracv^22g  + h=text  constant  tag4","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，v是速度，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"写成流量形式则有，","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +frac8q^2pi^2D^4g + h=mathrmconstant tag5","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，q是流量，D是管道直径，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"伯努利方程描述的是管道内部液体流动的能量守恒定律。组件的内部过程是能量的增加或减少。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-管道组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 管道组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于一个直管道，组件内部一般有沿程阻力损失与局部阻力损失。当液体从管道一端流向另一端时，液体的总能量减小。沿程阻力损失与局部阻力损失是管道组件的内部过程。其数学方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+h_f+h_mtag6","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，下标_in代表管道进口，_out代表管道出口，h_f表示沿程阻力损失，h_m表示局部阻力损失。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"沿程阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_f = ffracLD frac8q^2pi^2D^4gtag7","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，f为摩擦因数，L为管道长度，D为管道直径。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"局部阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_m = K frac8q^2pi^2D^4gtag8","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，K为局部阻力系数。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"管道的外部连接主要为压力与流量(高度也是，暂不考虑)。压力是状态量，流量是过程量。在两个组件a,b之间，有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"p_a=p_bq_a+q_b=0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-离心泵组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 离心泵组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"与管道组件类型，离心泵组件的内部过程是为流体增加能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+H_ttag9","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，H_t表示流经离心泵增加的能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"H_t=frac(romega)^2g-fracomega cotbeta 2pi bgQ=c_0omega^2-c_1omega Q=a_0-a_1Qtag10","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，a_0a_1代表水泵特性参数，方程10实际上是水泵的理论扬程流量曲线。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.3-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.3 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"构建系统的水泵、管道等主要组件之前，建立ModelingToolkit中的Connector（Connector中的变量在管道系统中为压力与流量）。代码仓库中有详尽的代码可以查看。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"# Component: SimplePipe(pipe with fixed friction factor `f`)\nfunction SimplePipe(; name, L=10.0, D=25E-3, f=0.01, ρ=1.0E3, zin=0.0, zout=0.0, K_inside=0.0)\n    @named in = PipeNode(z=zin)\n    @named out = PipeNode(z=zout)\n    ps = @parameters D = D L = L f = f K_inside = K_inside\n    eqs = [\n        _NodeEnergy(in, D, ρ) ~ _NodeEnergy(out, D, ρ) + _h_f(in, f, L, D) + _h_m(in, K_inside, D)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: CentrifugalPump\nfunction CentrifugalPump(; name, D=25E-3, ω=2500, c_0=4.4e-4, c_1=5.622, ρ=1.0E3)\n    @named in = PipeNode()\n    @named out = PipeNode()\n    a_0 = c_0 * abs2(ω * 2π / 60)\n    a_1 = c_1 * ω * 2π / 60\n    ps = @parameters D = D\n    eqs = [\n        _NodeEnergy(in, D, ρ) + a_0 - a_1 * abs(in.q) ~ _NodeEnergy(out, D, ρ)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: Sink_P\nfunction Sink_P(; name, p=101325)\n    @named port = PipeNode(z=0.0)\n    eqs = [\n        port.p ~ p\n    ]\n    compose(ODESystem(eqs, t, [], [], name=name), port)\nend\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"由以上组件构建如下系统则变得简单快捷。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: )","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named Pump = CentrifugalPump(ω=5000)\n@named A = Sink_P()\n@named B = Sink_P()\n\nsystem = [A, B, Pump]\n\n@named Pipe1 = SimplePipe(L=2.0);\npush!(system, Pipe1);\n@named Pipe2 = SimplePipe(L=3.0);\npush!(system, Pipe2);\n@named Pipe3 = SimplePipe(L=7.0);\npush!(system, Pipe3);\n@named Pipe4 = SimplePipe(L=9.0);\npush!(system, Pipe4);\n@named Pipe5 = SimplePipe(L=5.0);\npush!(system, Pipe5);\n@named Pipe6 = SimplePipe(L=4.0);\npush!(system, Pipe6);\n@named Pipe7 = SimplePipe(L=5.0);\npush!(system, Pipe7);\n@named Pipe8 = SimplePipe(L=1.0);\npush!(system, Pipe8);\n@named Pipe9 = SimplePipe(L=10.0);\npush!(system, Pipe9);\n@named Pipe10 = SimplePipe(L=2.0);\npush!(system, Pipe10);\n@named Pipe11 = SimplePipe(L=2.0);\npush!(system, Pipe11);\n@named Pipe12 = SimplePipe(L=3.0);\npush!(system, Pipe12);\n@named Pipe13 = SimplePipe(L=12.0);\npush!(system, Pipe13);\n@named Pipe14 = SimplePipe(L=1.0);\npush!(system, Pipe14);\n@named Pipe15 = SimplePipe(L=2.0);\npush!(system, Pipe15);\n@named Pipe16 = SimplePipe(L=3.0);\npush!(system, Pipe16);\n@named Pipe17 = SimplePipe(L=6.0);\npush!(system, Pipe17);\n@named Pipe18 = SimplePipe(L=6.0);\npush!(system, Pipe18);\n@named Pipe19 = SimplePipe(L=6.0);\npush!(system, Pipe19);\n@named Pipe20 = SimplePipe(L=1.0);\npush!(system, Pipe20);\n@named Pipe21 = SimplePipe(L=1.0);\npush!(system, Pipe21);\n@named Pipe22 = SimplePipe(L=7.0);\npush!(system, Pipe22);\n@named Pipe23 = SimplePipe(L=3.0);\npush!(system, Pipe23);\n@named Pipe24 = SimplePipe(L=3.0);\npush!(system, Pipe24);\n@named Pipe25 = SimplePipe(L=2.0);\npush!(system, Pipe25);\n\neqs = [\n  connect(A.port, Pump.in)\n  connect(Pump.out, Pipe1.in)\n  connect(Pipe1.out, Pipe2.in, Pipe5.in)\n  connect(Pipe2.out, Pipe3.in, Pipe6.in)\n  connect(Pipe3.out, Pipe4.in, Pipe7.in)\n  connect(Pipe4.out, Pipe10.out, Pipe14.in)\n  connect(Pipe5.out, Pipe11.in, Pipe12.in)\n  connect(Pipe6.out, Pipe8.in, Pipe9.in)\n  connect(Pipe7.out, Pipe9.out, Pipe10.in)\n  connect(Pipe12.out, Pipe8.out, Pipe13.in)\n  connect(Pipe13.out, Pipe14.out, Pipe15.in)\n  connect(Pipe11.out, Pipe19.in, Pipe16.in)\n  connect(Pipe16.out, Pipe17.in, Pipe20.in)\n  connect(Pipe17.out, Pipe18.in, Pipe21.in)\n  connect(Pipe18.out, Pipe15.out, Pipe22.in)\n  connect(Pipe19.out, Pipe20.out, Pipe23.in)\n  connect(Pipe21.out, Pipe22.out, Pipe24.in)\n  connect(Pipe23.out, Pipe24.out, Pipe25.in)\n  connect(B.port, Pipe25.out)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-热力循环系统","page":"Ai4EComponentLib.jl设计理念","title":"3.2 热力循环系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-数学内涵","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 数学内涵","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"热力循环系统中，有几个典型的内部过程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"等温过程：fracTP = constant\n等压过程：fracTv = constant\n等熵过程：pv^k = constant\n等容过程：pv = constant","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些过程中能量变化的体现，最终体现在流体的压力、密度、焓值、熵值、温度上。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在热力循环中，外部连接正包含这5个状态量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建热力系统时，尽管可以使用不同内部过程的控制方程，但理论方程和实际始终会有些出入。所以在构建热力系统时，可以利用ModelingToolkit的可拓展性特点——调用外部的物性库。调用物性库可以减小某些理论计算的误差。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等温过程为例，过程起点的状态已知。其内部过程的控制方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"T_1=T_2tag11","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"再确定过程终点的另一个状态量，则终点的其他状态可由2个已知状态得到。那么有以下4种组合：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"beginmatrix\n T_2p_2 Rightarrow  s_2D_2h_2\n T_2s_2 Rightarrow  p_2D_2h_2\n T_2D_2 Rightarrow  s_2p_2h_2\n T_2h_2 Rightarrow  s_2p_2D_2\nendmatrixtag12","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"使用CoolProp物性库，输入等式左边的两个参数，就能得到等式右边的任意一个参数。由此，可以外部CoolProp库替换内部方程，完成组件构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等焓过程为例，等焓过程中，内部方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_1=h_2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如给定一个参数p，则函数chose_equations会自动生成通过ph调用CoolProp得到其他参数数值的代码","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"\nfunction IsoenthalpyProcess(; name, inter_state=\"Q_0\", fluid=\"Water\")\n    @assert inter_state != \"H\" \"IsoenthalpyProcess can't accept H. Please chose another state.\"\n    @named oneport = StreamPort()\n    @unpack Δh, out = oneport\n    eqs = [\n        Δh ~ 0\n    ]\n    push!(eqs, chose_equations(out, inter_state, \"H\", fluid)...)\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"考虑图3-2描述的再热循环：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其代码如下。更加详细的代码请查看代码仓库以及文档。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named pump = IsentropicProcess(inter_state=\"P\")\n@named pump_P = DThermalStates(state=\"P\", value=-1.0E5, u0=18.0E6)\n\n@named boiler = IsobaricProcess(inter_state=\"T\")\n@named boiler_T = ThermalStates(state=\"T\", value=550+ 273.15)\n\n@named turbine = IsentropicProcess(inter_state=\"P\")\n@named turbine_P = ThermalStates(state=\"P\", value=3.0e6)\n\n@named reboiler = IsobaricProcess(inter_state=\"T\")\n@named reboiler_T = ThermalStates(state=\"T\", value=450 + 273.15)\n\n@named returbine = IsentropicProcess(inter_state=\"P\")\n@named returbine_P = ThermalStates(state=\"P\", value=4.0e3)\n\n@named condenser = IsothermalProcess(inter_state=\"Q_0\")\n\neqs = [\n  connect(pump.out, boiler.in, pump_P.node)\n  connect(boiler.out, turbine.in, boiler_T.node)\n  connect(turbine.out, reboiler.in, turbine_P.node)\n  connect(reboiler.out, returbine.in, reboiler_T.node)\n  connect(returbine.out, condenser.in, returbine_P.node)\n  connect(condenser.out, pump.in)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#组件化模型的优势","page":"Ai4EComponentLib.jl设计理念","title":"4 组件化模型的优势","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现在可以做一个小结，组件本质上就是描述变量与变量之间关系的方程。组件内部的控制方程才是最重要的部分，对系统的变化具有决定性意义。外部连接通过补充一个连接方程，描述了组件与组件之间的关系。连接方程对于真正的系统反应不具备决定性，只是辅助系统构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"模块化的组件在设计时会把大系统拆解成一个个小组件。这样做的好处是方便用户构建系统，坏处是这些连接变量在系统构建后的系统化简时还要消耗计算资源将它们化简。但事实上，组件化模型带来的收益远超过消耗一点计算资源付出的代价。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，由模块ABC组成的系统视为一个整体X，则ABC成为了X的内部结构，其数学形式也为微分代数方程，与模块ABC的数学形式并没有本质上的区别。唯一的区别在于方程数量的多少。系统X同样拥有对外的三个接口：输入接口x1、x2与输出接口x3。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"此时系统与子系统有了完备的闭包概念。假若此时ABC并不是一个最小系统，在ABC的基础之上可进一步细分出更小的模块。那么，可以称ABC为系统X的子系统，系统ABC同样拥有自己的子系统。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如ABC一共只有几个方程，那么不需要ABC作为X的子系统来构建。我们直接把X内部的方程手动展平，只包含x1、x2、x3即可。但假如ABC一共有成千上万个方程，假若系统ABC同样拥有自己的子系统。这个时候手动展平还是一种好方法吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"所以，分为内外结构的组件，在组成一个巨型系统时具有重要意义。一旦内部最关键的特性决定了，在今后复杂系统的任何层次节点上，人们的精力都能够集中在系统最关键的问题上——系统（子系统）之间的构建连接关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"剩下的化简，就交给计算机吧！若是让人不断的去展平方程，从零构建系统，不也是人力资源的浪费吗？人思维的价值应该体现系统的设计上，而不是展平方程上，虽然浪费一些计算资源，但不也是生产力的提升吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#结论","page":"Ai4EComponentLib.jl设计理念","title":"结论","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件化模型在构建时具有它本身的优势。依托于ModelingToolkit符号体系构建的组件化模型则有更加广阔的应用前景。ModelingToolkit自动的回调时间相应、DifferentialEquations的求解器分析可以更加灵活地处理仿真问题，基于ModelingToolkit的OptControl.jl可以将组件模型系统转变利用JuMP求解的最优控制问题。此外还有SciML的参数辨识工具包等等。在Julia社区的强力支撑下，组件化模型不仅仅是用于仿真的方程，它也可以是控制问题中的状态方程模型，优化问题中的约束。组件的本质——方程可以用最基本Julia要素描述——函数。","category":"page"},{"location":"Optimization/JumpMILP/#JuMP混合整数线性优化实例","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"tip: Tip\nContents：优化Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JumpMILP/#问题简介","page":"JuMP混合整数线性优化实例","title":"问题简介","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Advent Of Code中有一个很有意思的问题，可用JuMP来求解。同时也是能源系统优化的一个缩影。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"问题如下：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"为了收获粘土，你需要专用的粘土收集机器人。要制造任何类型的机器人，你都需要矿石。收集矿石需要带大钻头的矿石收集机器人。幸运的是，你的背包中正好有一个矿石收集机器人，你可以使用它启动整个操作。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个机器人每分钟可以收集1个其资源类型。机器人工厂（也在你的背包中）构建任何类型的机器人也需要一分钟，尽管它在构建开始时会消耗必要的可用资源，同时每分钟最多建造1个机器人。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"机器人工厂有很多蓝图（问题的输入）你可以选择，但一旦你用蓝图配置好了，你就不能改变它。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1：\n    制造一个矿石机器人（ore robot）消耗4矿石（ore）。\n    制造一个粘土机器人（clay robot）消耗2矿石（ore）。\n    制造一个黑曜石机器人（obsidian robot）消耗3块矿石（ore）和14块粘土（clay）。\n    制造一个紫晶机器人（geode robot）消耗2个矿石（ore）和7个黑曜石（obsidian）。\n\n蓝图2：\n    制造一个矿石机器人消耗2矿石。\n    制造一个粘土机器人消耗3矿石。\n    制造一个黑曜石机器人消耗3块矿石和8块粘土。\n    制造一个紫晶机器人消耗3个矿石和12个黑曜石。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化问题为：如何分配资源去建造机器人，在24分钟后获得最多的紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1的最优方案为最多获得9个紫晶，具体操作过程为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"==第1分钟==\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n==第2分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n\n==第3分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n新的粘土收集机器人准备就绪；你现在有一个了。\n\n==第4分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n1个粘土收集机器人收集1个粘土；你现在有1个粘土。\n\n==第5分钟==\n\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n1个粘土收集机器人收集1个粘土；你现在有2个粘土。\n\n新的粘土收集机器人准备就绪；你现在有两个了。\n\n==第6分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n2个粘土收集机器人收集2个粘土；你现在有4块粘土。\n\n==第7分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n2个粘土收集机器人收集2个粘土；你现在有6块粘土。\n\n新的粘土收集机器人准备就绪；你现在有3个了。\n\n==第8分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有9块粘土。\n\n==第9分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n3个粘土收集机器人收集3个粘土；你现在有12块粘土。\n\n==第10分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n3个粘土收集机器人收集3个粘土；你现在有15块粘土。\n\n==分钟11==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有4块粘土。\n\n新的黑曜石收集机器人准备就绪；你现在有一个了。\n\n==第12分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n3个粘土收集机器人收集3个粘土；你现在有7块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有1个黑曜石。\n\n新的粘土收集机器人准备就绪；你现在有4个。\n\n==第13分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有11块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有2颗黑曜石。\n\n==第14分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有15块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有3个黑曜石。\n\n==第15分钟==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n4个粘土收集机器人收集4个粘土；你现在有5块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有4颗黑曜石。\n\n新的黑曜石收集机器人准备就绪；你现在有两个了。\n\n==第16分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有9块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n\n==第17分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有13块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n\n==第18分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有17块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有3个黑曜石。\n\n新的紫晶机器人准备就绪；你现在有一个了。\n\n==第19分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有21块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有5颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有一个紫晶。\n\n==第20分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有25块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有7颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有2个紫晶。\n\n==第21分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有29块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有2颗黑曜石。\n1个紫晶开裂机器人开裂1个大地洞；你现在有3个紫晶。\n\n新的紫晶机器人准备就绪；你现在有两个了。\n\n==第22分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有33块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有4颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有5个紫晶。\n\n==第23分钟==\n1台矿石收集机器人收集1个矿石；你现在有5个矿石。\n4个粘土收集机器人收集4个粘土；你现在有37块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有7个紫晶。\n\n==第24分钟==\n1台矿石收集机器人收集1个矿石；你现在有6个矿石。\n4个粘土收集机器人收集4个粘土；你现在有41块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有9个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图2最多获得12个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"对于以下蓝图，分别能获得的最多紫晶是多少？","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.","category":"page"},{"location":"Optimization/JumpMILP/#优化问题的数学表达","page":"JuMP混合整数线性优化实例","title":"优化问题的数学表达","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"因为涉及到时间域上的状态改变（本质就是离散），所以需要在求解时间域上的每个时间点上设置一个变量。同时，每个不同种类的矿石也需要设置变量。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"变量设置：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个种类每个时间点矿石数量，整数\n每个种类每个时间点机器人数量，整数\n每个种类每个时间点是否建造，0或1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"所以有：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nrobots_ij  in N\nisBuild_ij in 01\nobtains_ij in N\ni in ore clay obsidian geode\nj in 1232324\n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化目标为第24分钟，紫晶最多：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nmax obtains_geode24 \n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"约束：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"note: Note\ncosts的每一行是建造不同种机器人消耗的材料个数。costs =  beginbmatrix4 3 2 3  0 0 17 0  0 0 0 16  0 0 0 0endbmatrix例如，第一行为建造4中不同的机器人，分别要消耗4，3，2，3个ore；第二行为建造4中不同的机器人,分别要消耗0，0，17，0个clay：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij = obtains_ij-1+robots_ij - sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"上一个周期结束，矿石足够才能在本周期建造机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij-1 geqslant sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"建造机器人，数量增加","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"robots_ij =  robots_ij-1  + isBulid_ij-1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"一次只能建造一个机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"sum_k^ isBulid_kj leqslant 1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"初值条件，没有材料且只有一台矿石机器人：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"isBulid_i1 = 0 i in ore clay obsidian geode\nobtain_i1 = 0 i in  clay obsidian geode\nrobots_i1 = 0 i in  clay obsidian geode\nobtain_ore1 = 1 \nrobots_ore1 = 1 ","category":"page"},{"location":"Optimization/JumpMILP/#JuMP求解代码","page":"JuMP混合整数线性优化实例","title":"JuMP求解代码","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"using JuMP\nimport HiGHS\n\ninputs = \"\"\"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.\n\"\"\"\n\ninputs = IOBuffer(inputs)\n\nfunction readData(path=inputs)\n    rawData = readlines(path)\n    rawData = split.(rawData, c -> c == '.' || c == ':')\n    regs = [\n        r\"Blueprint (\\d+)\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore and (\\d+) clay\",\n        r\"costs (\\d+) ore and (\\d+) obsidian\",\n    ]\n    d = Dict{Int,Vector{Vector{Int64}}}()\n    for line in rawData |> eachindex\n        c = map(x -> zeros(Int64, 4), 1:4)\n        r = Vector{Int64}[]\n        for i in 1:5\n            m = match(regs[i], rawData[line][i]).captures\n            m = map(x -> parse(Int64, x), m)\n            push!(r, m)\n        end\n        c[1][1] = r[2][1]\n        c[1][2] = r[3][1]\n        c[1][3] = r[4][1]\n        c[1][4] = r[5][1]\n        c[2][3] = r[4][2]\n        c[3][4] = r[5][2]\n        d[r[1][1]] = c\n    end\n    return d\nend\n\n\nfunction solve_1(costs, periods)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    names = [\"ore\", \"clay\", \"obsidian\", \"geode\"]\n    # robots为每个机器人的数量，obtains为每个机器人每个周期的产出，isBuild为每个机器人每个周期是否建造\n    @variable(model, robots[names, periods], Int)\n    @variable(model, obtains[names, periods], Int)\n    @variable(model, isBuild[names, periods], Bin)\n    # 矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p2] == obtains[names[ind], p1] + robots[names[ind], p2] - sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 矿石足够才能建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p1] >= sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], robots[names[ind], p2] == robots[names[ind], p1] + isBuild[names[ind], p1])\n    end\n    # 一次只能建造一个机器人\n    @constraint(model, [i = periods], sum(isBuild[:, i]) <= 1)\n    # 初始条件\n    @constraint(model, [ind = 2:4], robots[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], robots[names[ind], 1] == 1)\n    @constraint(model, [ind = 2:4], obtains[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], obtains[names[ind], 1] == 1)\n    @constraint(model, [ind = 1:4], isBuild[names[ind], 1] == 0)\n    # 目标函数\n    @objective(model, Max, obtains[\"geode\", lastindex(periods)])\n    optimize!(model)\n    return objective_value(model) |> Int\nend\n\nfunction solve_P1()\n    d = readData()\n    s = String[]\n    for (i, c) in d\n        res = solve_1(c, 1:24)\n        push!(s,\"第$(i)个结果:\"*string(res))\n    end\n    return s\nend\n\nsolve_P1()","category":"page"},{"location":"Optimization/JumpMILP/#小结","page":"JuMP混合整数线性优化实例","title":"小结","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"这个问题重要的特点为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"存在时域上的状态转移（能源系统中负荷的变化等等），以及如何用变量之间的关联体现状态转移的关系\n包含整数与布尔变量（设备启停、满足最小需求的设备数量等等）","category":"page"},{"location":"Modeling/neural_network/#数学视角下的神经网络","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tip: Tip\nContents：Flux，神经网络Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"note: Note\nFlux.jl Julia机器学习包\n著作\nPattern Recognition and Machine Learning - Christopher M. Bishop\n机器学习 - 周志华\nDive into Deep Learning - 阿斯顿·张，李沐\n博文\nApacheCN 人工智能知识树\n机器学习原理\n视频\n吴恩达 deeplearning.ai\n李宏毅 Course-Machine Learning\n前言\npapers with code","category":"page"},{"location":"Modeling/neural_network/#神经网络的数学内涵","page":"数学视角下的神经网络","title":"1 神经网络的数学内涵","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于这样一个简单的神经网络，其中间神经元的激活函数为tanh，输入x与输出y之间的数学表达式为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练的目标为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"minsum_i=0^n left(y_reali-y_trainiright)^2 tag1-1","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其中y_reali为实际数据，y_traini为通过模型计算出来的数据。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"如果y也是一个激活函数tanh，经过激活函数后输出，那么数学模型则变为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=tanh(w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2)+b","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的参数训练，则是为了要找到使训练目标最小的一组参数：w_ijb_ij。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"由此可以归纳：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的本质是一个关于激活函数的复合函数\n训练的内涵是寻优的过程，内涵是优化问题（回归问题）\n神经网络处理问题的内涵是用复合函数去拟合数据集","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以从数学内涵上来说，作为人工智能代表之一的神经网络并没有那么神秘。事实上，它也并没有那么强大！根据其内涵，可以总结出其优缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"优点：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"普适性的优化框架，如BP算法\n模型任意搭建，成熟的工具（Tensorflow等）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"缺点：包含了拟合的缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其模型的内涵（机理）不明确，只是从数学的角度逼近真实数据\n容易过拟合","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面通过一些实验来说明。","category":"page"},{"location":"Modeling/neural_network/#神经网络的学习特性探究","page":"数学视角下的神经网络","title":"2 神经网络的学习特性探究","text":"","category":"section"},{"location":"Modeling/neural_network/#.1-一维曲线学习","page":"数学视角下的神经网络","title":"2.1 一维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"考虑简单的函数学习问题，用神经网络（1隐藏层2节点，如上图所示，中间层激活函数采用双曲正弦函数）来学习一个一元函数，即单输入单输出网络，一共有7（2*2+2+1）个参数。在数据集中生成中，严格按照二次曲线规律生成，不添加任何扰动。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"采用下面的程序计算，训练10000次，训练结果的均方差为5.52E-5。为了验证学习的效果。在区间010内取一些原函数（y= x^2）上的点，作为测试集。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(2,1)\nb1 = rand(2)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,2)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\ng(x) = x^2\n\nmodel(x) = layer2(g.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2\nscatter(x_train,y_train,legend=false)\n\nmodel.(x_train)\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nfor i in 1:5000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(x_train,y_train))\nbegin\n    scatter(x_train,y_train,legend=false,title=\"x^2\",color=\"red\")\n    plot!(x_train,model.(x_train),color=\"blue\")\nend\n\nbegin\n    x_learned = collect(0.07:0.07:1)\n    scatter!(x_learned,x_learned.^2,legend=false,color=\"green\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 3)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的结果如上图，红色点为训练集，以绿色点为测试集。可以认为，学习机很好地找到了在区间010原有数据的“机理”，因为学习结果几乎和原函数一致。这是一个非常漂亮的学习过程！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上述学习训练过程的核心特点为：训练集的学习域覆盖了测试集的测试域，它们都在之内010。自然而然地想到，没有学习过的区域呢？比如1020left-1000right这些区间表现会表现得怎么样？","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"begin\n    x_pred = collect(1:.1:2)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend\n\nbegin\n    x_pred = collect(-1.0:.1:0)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在1020left-1000right区间上，结果如图所示。表现为没有“学会”。因为实际值和测试值偏离了。","category":"page"},{"location":"Modeling/neural_network/#.2-内涵探讨","page":"数学视角下的神经网络","title":"2.2 内涵探讨","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"事实上，这个结果应该是意料之中的。上面说过，神经网络学习的本质上是用复合函数逼近。用一个构造的数学函数y去代替数据点二次曲线的实际内涵。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"Tanh的泰勒展开为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tanh=x-fracx^35+frac2x^515+o(x^7)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在式（1-1）中，学习机除去偏移量b_2还有6个参数，简单认为逼近的精度为tanh泰勒展开的前6项，误差为项为o(x^13)。在数据训练集区间内，o(x^13)可以保证在训练域误差可以很小，但一旦扩展到全实数域，这部分误差是无法避免的。因为其本质的“机理”并不相同。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上面的问题中，神经网络通过参数优化，逼近了0 10区间内关于x^2的数据特性，可以使得学习机在0 10 完美替代x^2$。在这个区间外，它还是它自己，即tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，神经网络的数学内涵是逼近，其预测世界规律的方法是激活函数。采用统一的方法去逼近任意区间内的数据。所以，从数学的角度，激活函数与神经元个数都体现神经网络结构的逼近能力。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下图分表表示了激活函数为exp与x^2训练与预测情况。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 7)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在0 10内，可以认为神经网络可以代表x^2。而在0 10外，函数走势都是它们“本来的样子”。","category":"page"},{"location":"Modeling/neural_network/#.3-二维曲线学习","page":"数学视角下的神经网络","title":"2.3 二维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"拓展到二维平面拥有相同的规律。采用10节点2隐藏层全连接网络逼近二元函数函数:","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"gleft(xyright)=sinleft(xright)ast c o sleft(yright)   xyinleft(01right)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络图与训练结果如下图：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 8)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 9)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"散点代表真实值。平面代表预测平面。可以看到散点图几乎都在平面上，训练效果较好。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 10)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机在xyinleft(02right)的表现如上图所示。红点为训练数据集，黄点为训练集域内的测试集，绿点为训练集外的测试集。可以看到随着预测范围往外扩展，绿点作为测试集与预测平面已经“分道扬镳”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"这与前面的分析一致，不同之处在于学习机逼近二元函数，逼近的对象是面而不是曲线。再拓展到更高维度的超平面上，神经网络逼近的特性仍然成立。这是由它的数学内涵决定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"代码如下。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(10,2)\nb1 = rand(10)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(10,10)\nb2 = rand(10)\nlayer2(x) = W2 * x .+ b2\n\nW3 = rand(1,10)\nb3 = rand(1)\nlayer3(x) = W3 * x .+ b3\n\nmodel(x) = layer3(tanh.(layer2(tanh.(layer1(x)))))[1]\n\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nz_train = cos.(x_grid) .* sin.(a_grid)\nxy = [[x,y] for x in xs for y in xs]\nmodel.(z_train)\n\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2,W3,b3]\ndata = [(xy,z_train)]\nopt = Descent(0.1)\n\nfor i in 1:1000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(xy,z_train))\n\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid))\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nxs = collect(0.05:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"yellow\",legend=false)\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"red\")\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs if x>=1.0||y>=1.0]\na_grid = [y for x = xs for y = xs if x>=1.0||y>=1.0]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"green\")","category":"page"},{"location":"Modeling/neural_network/#.4-正则化对逼近的影响","page":"数学视角下的神经网络","title":"2.4 正则化对逼近的影响","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么正则化的引入有没有改变这一内涵呢？答案是否定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在前面的讨论中，数据集都严格符合函数规律，没有任何误差。在实际的数据集中，不可能由如此理想的情况。而正则项就是对这测量值误差的一种折中处理，神经网络的设计者可以通过正则项来指引网络的优化方向，从人的智能角度规避纯数据带来的“误导”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"首先，基于y=x^2在0010范围内生成一些点，并且加上随机扰动作为训练集。如下图所示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 11)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从散点图依稀可以看出二次函数的影子。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面尝试不同的正则化。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况1，无正则化：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 13)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=05：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-05)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 14)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=x^2：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-x_i^2)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 16)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机是否克服了“逼近”带来的缺点呢？答案依旧是否定的。在未知域，学习机并没有带来惊喜。如图下图所示，在1020的预测范围内，预测能力也没有得到显著的提升。Loss方程的改变，只是规避了数据观测误差带来的影响，防止神经网络因某些异常点陷入过拟合状态。其并没有改变神经网络架构逼近的数学内涵，所以其仍然不具备学习域外的预测能力，因为其“探索世界的根本方法论”依旧是——tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"但正则项所带来的泛化能力是毋庸置疑的，在遇到特定问题时也许不容易知道数据的“机理”，但是从方法论的进程上来说，正则化已经向“探索未知”迈出了重要的一步。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 17)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\nusing Statistics\n\nN = 10\nW1 = rand(N,1)\nb1 = rand(N)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,N)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\nmodel(x) = layer2(tanh.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2 .+ rand(length(x_train))*0.2\n\nmodel.(x_train)\nloss(x,y) = 0.1*Flux.Losses.mse(model.(x),y) + mean((model.(x).-x.^2).^2)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nbegin\n    for i in 1:2000\n        train!(loss, parameters, data, opt)\n    end\n    println(loss(x_train,y_train))\nend\n\nbegin\n    scatter(x_train,y_train,legend=false)\n    plot!(x_train,model.(x_train))\nend\n\nbegin\n    x_pred = collect(1:0.1:2)\n    y_pred = model.(x_pred)\n    scatter!(x_pred,x_pred.^2,color=\"green\")\n    plot!(x_pred,y_pred,color=\"green\")\nend\n","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的数学内涵是用函数去逼近某个区间内的数据集，其本质的特征是激活函数。这一点决定了在未学习过的未知域，神经网络的预测作用有限。 在纷杂又充满噪声的数据中，正则化是探索数据内涵重要的利器！正则项代表人的智能对学习机学习的一种指导，在已知域内正则化可以剔除噪声发现已知域的本质。这是从完全的数据挖掘以至于陷入过拟合发展状态的重大突破。虽然如此，但正则项没有改变根本的拟合逼近问题。","category":"page"},{"location":"Modeling/neural_network/#启发与讨论","page":"数学视角下的神经网络","title":"3 启发与讨论","text":"","category":"section"},{"location":"Modeling/neural_network/#神经网络应用的启示","page":"数学视角下的神经网络","title":"神经网络应用的启示","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从上面的分析中，我们可以划分定义两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练域：训练集涉及到的变量区间\n未知域：训练集未涉及到的变量区间","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"可以把测试集分成两类。一类是在训练域中的，一类是在未知域中的。由上面的实验可以推知，在训练域中训练集的临域通过学习机“逼近”了，那么在临域内的测试集就能有很高预测精度。而在未知域中的测试集，那么就只能听天由命。因为训练域之外，学习机就呈现了激活函数本来的面貌。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对其应用而言，又要引入两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"结构化问题：传统的机理明确（能用完备的数学方程描述，如欧姆定律：U=I*R）的问题\n非结构化问题：机理不明确的问题（只知变量之间有关联但无明确的机理量化关系，如喝牛奶频率和身高的关系）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从以上分析，可以知道。在结构化问题中，神经网络无优势。其优势在于非结构化问题的预测，因为非结构化问题本就机理不明，不明就“暴力拟合”试试呗 :)！虽然上述过程中讨论的都是结构化问题，但是对于非结构化问题也有一定的参考。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"例如，人脸识别。这可以从某种程度上解释人脸学习时为何需要一组端端正正的人脸。图像可以视作高维函数（自变量为RGB值）。一组端正的人脸保证了不管是训练集还是测试集，他们作为“数”的特性的坐标都比较相近，即保证了用来测试的人脸一定是在训练时“见过的”，或者“和见过的非常相近”。类比至上述实验的解释是，采用端正的0 10区间的“人脸”作为训练集，当测试集的人脸也很端正，也在0 10区间内，或者在其“附近”，那么学习机就能准确识别，因为已经学过了。但是，出现了一张“奇怪”的人脸，假设它是在25 30区间内。这没有学过，那就不会！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么，机器学习的应用中可以获得一些启示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于分类问题判别问题，应该用训练集包含更加广泛的训练域，如果训练域涵盖了测试集，那么精度会非常高。类似与高维的图像识别在数据量少的如何做到这一点呢？就需要在特征提取与降维方面下功夫。简单来说是，训练时让学习机见识过了所有的情况，那么测试时再见到，它一定可以处理得很好。如果见识太少，那就只能靠猜。人的经验不就是这样的道理吗？但问题是，在一维0 10区间，我们很容易界定训练域与未知域。在实际问题中，这是很难定义的。例如，怎么量化定义人脸的训练域？仅通过RGB颜色值？似乎不好说。所以，这还有待长远的探索。\n关于预测，若是对于训练域之外的测试集要想准确预测，要么改变tanh能够让激活函数体现出数据发展趋势的“道”；要么提取被学习对象的精髓让激活函数能够成为它的“道”。但预测本来就有巨大的不确定性。在实际问题的非结构性问题中，神经网络拟合的这个“机理”究竟是否是“真实的机理”呢？没人说得清，依旧要靠其它测试集来实践检验！或者，面对一些复杂的问题，通过一系列“猛如虎的操作”（例如池化卷积等等），本质上没有提升神经网络的预测能力，而是通过调参把训练集与测试集的尽可能缩到了处理后的变量训练域内。这样，逼近就有效果了，但这内涵难道不更像是插值处理？所以预测在某些些问题上，本就是一个伪命题。要真正实现预测，一定是机理得以明确，找到了事物最本质的规律之后的“对未知的预测”，而不是基于统计原理的“带插值含义的预测”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，对于神经网络，我们不需要过于神话。其本质可以看作一个强有力的拟合工具，尤其是在计算机技术飞速发展的今天，神经网络有它巨大的使用价值。但作为工具来说，科学的发展并不依赖于工具。工具只是手段，有些时候我们也应该“不忘初心”，回到对问题本质的结构化性质探索的方向上去。从另一个角度来说，神经网络可以成为结构化性质探索道路上的得力帮手，但是其大概率不能成为决定性因素。若是我们心中对它已经有了一种依赖，或者陷入了某种网络调参的狂热。那么我们是不是应该反思，我们是否陷入了对机器学习的路径依赖，是否忘了探索的真谛——研究问题本身？","category":"page"},{"location":"Modeling/neural_network/#.2-学习的本质","page":"数学视角下的神经网络","title":"3.2 学习的本质","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"人类探索真理的过程，本质上是一个演绎推理、实验验证的过程。对应机器学习，一次训练对应演绎推理，测试集测试对应实验验证。对于人类的科学发展而言，这一探索是螺旋式上升的。从实践到理论，再用理论指导实践，实践结果修正理论，这是马克思科学原理的哲学观。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在探索与发展的过程中，没有什么是绝对成立的，没有绝对的真理。就像牛顿定律不适用于量子领域，正是在“大误差”中，科学得以修正发展，本质上是一个理论与实践的Loss方程数值不断缩小的过程。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"类比科学发展的本质，在有限的数据集下，机器学习的学习方法或者学习范式还不够具有发展性。机器学习的学习方式更加接近于“一锤子买卖”。学习训练然后测试，没有测试结果指导理论的过程，或者说这一过程是由人来完成的。人根据测试结果的准确性来判断模型是否需要修改提升。目前阶段学习机没有自我驱动的迭代能力，即根据学习的效果来修正学习模型。人类智能的巨大潜力，正是体现在驱动实践理论再实践这一个过程当中。从这哲学的角度，这样一种实践理论再实践的学习范式是面对“未知的虚无”最强有力的手段，也是最强大的学习方法。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的本质，在机器学习中更加接近元学习的思想。即在学习模型中提供根据结果修正模型参数的接口，让学习机能够在Loss方程的指引下，自我迭代。目前可能是调整超参数，未来可能就能发展成为自我修正网络结构、激活函数等学习模型的框架结构。从计算的本质来说，这一过程对应Code Generation。目前普遍的学习方法是修改模型参数，元学习的学习方法是学习机能够修改模型代码。对应的实现方式为元编程——用代码写代码。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"目前来说元编程的技术实现完全没有问题，Julia语言中就有成熟高效的元编程方式。元学习的技术实现不是问题。但从它的学习过程可以轻易推断，元学习的难点在于Loss方程的量化指标。由损失到参数，是在数的领域。而由损失到网络结构，这不是一个可以直接跨越的鸿沟。在它们中间，需要架起一座由数到结构的桥梁，也就是变成一个可计算的问题。要实现这一点，还需要长时间的探索。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识实例","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"tip: Tip\nContents：微分方程参数辨识、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识问题","page":"微分方程参数辨识实例","title":"微分方程参数辨识问题","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在JuMP非线性参数辨识实例与MTK非线性参数辨识实例中介绍了参数辨识问题的形式与求解工具。求解的问题的数学形式为一般方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE则是针对另外一种数学形式进行参数辨识求解的工具包——微分方程形式。例如，如下问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"fracdydt = at^2+sin(bt)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"对于这样一个微分问题。假设我们并不知道参数ab的值是多少。同样只能过实验和测量获得对应时间点上y的观测值。参数辨识需要解决的问题是：根据t，y观测值。反推出ab的值。与前面解决的问题不同的是，它是微分方程形式。相同的是，它们的核心逻辑是“优化”。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"要求解这样一个含有微分方程的参数辨识问题，可以很自然地想到：将微分方程的原函数求出来，再进行常规方程的参数辨识，问题就解决了。但是这有一个前提——能够求出原函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE的解决方式是，直接将微分方程离散，通过离散后的节点直接构造优化问题，进行求解。这样就避免了求解原函数问题。","category":"page"},{"location":"Optimization/DE_Estim/#离散的概念","page":"微分方程参数辨识实例","title":"离散的概念","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"离散是微分方程数值解法中的一个概念。例如，求解：fracdydt = ytin(01)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"具体的方法是在tin(01)选特定步长的点，假如选定步长为0.1，那么有：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"t_0=0t_1=01t_2=02t_10=10","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"同时，对于函数y，有","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n-1 * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"所以，对于微分方程问题，就转为了求y_0至y_10的值，也就是求出具体时间点上的函数值。问题就由一个连续的方程变成了有限个点上的函数值，这个过程就成为离散。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数值求解算法的精度与离散的方法有紧密关系。上面的离散方式可以换成：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"区别不过不过是等式右端取y_n-1还是y_n的区别。但却是两种不同的方法——向前与向后差分，求解的精度也不一样。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"此外，求解的精度还与步长等因素相关。更多理论，可以查阅《数值分析》一书。","category":"page"},{"location":"Optimization/DE_Estim/#微分参数辨识的优化表达","page":"微分方程参数辨识实例","title":"微分参数辨识的优化表达","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"回到问题fracdydt = at^2+sin(bt)，已知系列观测值：y_real那么优化问题的数学表达为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"undersetabminsum_i=0^n(y_reali-y_i)^2sthspace5mmy_i+1-y_i=at_i^2+sin(bt_i)","category":"page"},{"location":"Optimization/DE_Estim/#加热器实例","page":"微分方程参数辨识实例","title":"加热器实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"现有一个加热系统，由加热器、温度传感器、散热器构成。那么其控制方程为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"mcfracdTdt=(-Sh(T-T_out)+Q)*u(t-t_0)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以简单理解为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"温度变化=加热-散热*延迟函数","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"经过化简之后：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"beginarrayc\nfracd Td t=left(-fracTa+fracbaright) * u(t-c) \nu(t-c)=f(x)=leftbeginarrayll\n0  x0 1  x geq 0endarrayrightendarray","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"参数辨识的目标是辨识出a，b，c。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数据（数据在文档最后，以CSV文件格式保存到julia程序文件夹即可）的第二列中为加热功率，在方程模型中我们做了简化。由于功率只有0和100，在方程中我们简化为开关延时函数。所以第二列的原始数据后面并没有使用。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"首先，实际的曲线如下：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV,DataFrames,Plots\ndata = CSV.read(\"./codetest/data.csv\",DataFrame)\n########根据第一列与第三列数据画出图像#########\nplot(data[:,1],data[:,3]) ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"使用DE作为建模基础建立方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DifferentialEquations\nfunction fun(a)\n    if a>=0\n        1\n    else\n        0\n    end\nend\nfunction ff(u,p,t)\n    -u * fun( t- p[3])/p[1] + p[2] * fun( t- p[3])/p[1]\nend","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这里采用了简写方式，省略了du，只包含微分方程右边的部分，因为只有一个微分变量所以可以简写。\nFun表示函数u的作用，其本质是单位阶跃函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"定义参数等要素：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [1.0,1.0,1.0]\nprob = ODEProblem(ff,u0,tspan,p)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"需要留意p的值，这里p为选定的初始值。p的最终值是需要通过优化才能得到。优化目标为找到一组p，使得Loss方程的数值最小。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"如果按照初值p = [1.0,1.0,1.0]求解，则可以得到如下结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"sol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以看到，相去甚远！说明这个初值与真实值相差很远。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"通过DiffEqParamEstim构建优化模型：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DiffEqParamEstim\nrealdata = data[:,3]\nt= data[:,1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"其中，","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"realdata是实际过程中的温度值向量\nt是实际采样过程中的温度点\nbuildlossobjective 直接构建了Loss方程，其方法是L2Loss，即差的平方和。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"求解优化问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Optim.optimize就是求解器，能求cost_function的最小值。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"得到结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 3)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"画图测试优化结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [779.0,49.0,-652.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"似乎结果差得有点远！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"再次优化：这是因为初值对优化问题造成的影响。由于初值与目标相去甚远，所以结果有些出入。p[3]应该是正数。把优化初值的第三项改为正数。再次优化","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"result_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 5)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在这个结果下，画出来的图像如图：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 6)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这是一个让人满意的结果！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\n多次优化是优化中一种常见的策略。某些问题的优化结果可能是一个局部最优解，这并不代表结果是错误的。所以，当优化结果不满意时，可以选择不同的初值进行优化求解。当初值离最优值越近，结果越准确。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV, DataFrames, Plots\ndata = CSV.read(\"./codetest/data.csv\", DataFrame)\ndata[!, 3]\nplot(data[:, 1], data[:, 3]) #画出图像\n\nusing DifferentialEquations\nfunction fun(a)\n    if a >= 0\n        1\n    else\n        0\n    end\nend\nfunction ff(u, p, t)\n    -u * fun(t - p[3]) / p[1] + p[2] * fun(t - p[3]) / p[1]\nend\n\nu0 = 3.6\ntspan = (0.0, 3000.0)\np = [1.0, 1.0, 1.0]\nprob = ODEProblem(ff, u0, tspan, p)\n\nsol = solve(prob, Tsit5())\nplot(sol)\n\nusing DiffEqParamEstim\nrealdata = data[:, 3]\nt = data[:, 1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)\n\nusing Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n\nresult_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)\n\n\nu0=3.6\ntspan = (0.0,3000.0)\np = [267.0,45.0,343.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"原始数据：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Time (min),Valve Position (% open),Temperature (degC)\n0,0,3.6\n5,0,3.7\n10,0,3.6\n15,0,3.7\n20,0,3.6\n25,0,3.7\n30,0,3.7\n35,0,3.6\n40,0,3.6\n45,0,3.6\n50,0,3.6\n55,0,3.7\n60,0,3.7\n65,0,3.7\n70,0,3.7\n75,0,3.5\n80,0,3.6\n85,0,3.7\n90,0,3.5\n95,0,3.6\n100,0,3.5\n105,0,3.7\n110,0,3.6\n115,0,3.7\n120,0,3.6\n125,0,3.7\n130,0,3.7\n135,0,3.7\n140,0,3.7\n145,0,3.7\n150,0,3.7\n155,0,3.5\n160,0,3.6\n165,0,3.6\n170,0,3.6\n175,0,3.7\n180,0,3.6\n185,0,3.6\n190,0,3.7\n195,0,3.6\n200,0,3.5\n205,0,3.6\n210,0,3.5\n215,0,3.7\n220,0,3.6\n225,0,3.5\n230,0,3.7\n235,0,3.7\n240,0,3.6\n245,0,3.7\n250,0,3.5\n255,0,3.7\n260,0,3.7\n265,0,3.6\n270,0,3.6\n275,0,3.7\n280,0,3.7\n285,0,3.7\n290,0,3.5\n295,0,3.7\n300,0,3.5\n305,0,3.5\n310,0,3.7\n315,0,3.6\n320,0,3.7\n325,0,3.6\n330,0,3.7\n335,0,3.5\n340,0,3.5\n345,0,3.5\n350,0,3.7\n355,0,3.7\n360,0,3.6\n365,0,3.6\n370,0,3.7\n375,0,3.5\n380,0,3.7\n385,0,3.5\n390,0,3.7\n395,0,3.6\n400,100,3.7\n405,100,14.9\n410,100,18.2\n415,100,19.2\n420,100,19.9\n425,100,20.1\n430,100,20.8\n435,100,21.0\n440,100,21.3\n445,100,21.4\n450,100,21.5\n455,100,22.0\n460,100,21.8\n465,100,21.8\n470,100,21.9\n475,100,21.5\n480,100,21.7\n485,100,21.2\n490,100,20.7\n495,100,20.3\n500,100,20.3\n505,100,20.1\n510,100,21.2\n515,100,22.8\n520,100,23.9\n525,100,24.2\n530,100,24.9\n535,100,25.7\n540,100,26.4\n545,100,26.5\n550,100,26.7\n555,100,27.3\n560,100,27.6\n565,100,27.5\n570,100,27.5\n575,100,27.7\n580,100,27.8\n585,100,27.8\n590,100,27.9\n595,100,27.9\n600,100,28.0\n605,100,28.2\n610,100,28.2\n615,100,28.5\n620,100,28.7\n625,100,28.9\n630,100,29.0\n635,100,29.2\n640,100,29.7\n645,100,29.8\n650,100,30.1\n655,100,30.4\n660,100,30.5\n665,100,30.9\n670,100,31.6\n675,100,31.8\n680,100,32.2\n685,100,32.7\n690,100,32.8\n695,100,33.0\n700,100,33.4\n705,100,33.8\n710,100,34.0\n715,100,34.6\n720,100,34.8\n725,100,35.2\n730,100,35.4\n735,100,35.7\n740,100,36.0\n745,100,36.6\n750,100,36.8\n755,100,36.9\n760,100,37.3\n765,100,37.5\n770,100,37.7\n775,100,37.9\n780,100,37.9\n785,100,38.3\n790,100,38.2\n795,100,38.4\n800,100,38.7\n805,100,38.8\n810,100,39.1\n815,100,39.2\n820,100,39.2\n825,100,39.4\n830,100,39.4\n835,100,39.3\n840,100,39.5\n845,100,39.5\n850,100,39.7\n855,100,39.7\n860,100,39.8\n865,100,40.1\n870,100,39.9\n875,100,40.1\n880,100,40.0\n885,100,40.2\n890,100,40.1\n895,100,40.3\n900,100,40.3\n905,100,40.2\n910,100,40.1\n915,100,40.1\n920,100,40.1\n925,100,40.2\n930,100,40.3\n935,100,40.4\n940,100,40.4\n945,100,40.8\n950,100,40.8\n955,100,40.8\n960,100,40.7\n965,100,40.9\n970,100,41.0\n975,100,41.2\n980,100,41.3\n985,100,41.3\n990,100,41.3\n995,100,41.3\n1000,100,41.4\n1005,100,41.7\n1010,100,41.7\n1015,100,41.6\n1020,100,41.8\n1025,100,41.6\n1030,100,41.7\n1035,100,41.8\n1040,100,41.9\n1045,100,42.0\n1050,100,42.1\n1055,100,42.0\n1060,100,42.2\n1065,100,42.1\n1070,100,42.4\n1075,100,42.4\n1080,100,42.6\n1085,100,42.7\n1090,100,42.7\n1095,100,42.9\n1100,100,43.0\n1105,100,43.0\n1110,100,43.1\n1115,100,43.2\n1120,100,43.4\n1125,100,43.4\n1130,100,43.5\n1135,100,43.4\n1140,100,43.5\n1145,100,43.8\n1150,100,43.8\n1155,100,43.8\n1160,100,44.0\n1165,100,44.0\n1170,100,44.0\n1175,100,44.1\n1180,100,44.1\n1185,100,44.2\n1190,100,44.3\n1195,100,44.2\n1200,100,44.4\n1205,100,44.4\n1210,100,44.3\n1215,100,44.4\n1220,100,44.2\n1225,100,44.2\n1230,100,44.0\n1235,100,44.1\n1240,100,43.9\n1245,100,43.9\n1250,100,43.8\n1255,100,44.0\n1260,100,44.0\n1265,100,43.8\n1270,100,43.9\n1275,100,43.9\n1280,100,44.0\n1285,100,44.0\n1290,100,44.1\n1295,100,44.1\n1300,100,44.2\n1305,100,43.9\n1310,100,43.9\n1315,100,44.0\n1320,100,43.8\n1325,100,43.9\n1330,100,43.8\n1335,100,43.9\n1340,100,43.8\n1345,100,43.6\n1350,100,43.7\n1355,100,43.7\n1360,100,43.8\n1365,100,43.7\n1370,100,43.6\n1375,100,43.8\n1380,100,43.6\n1385,100,43.7\n1390,100,43.4\n1395,100,43.4\n1400,100,43.5\n1405,100,43.4\n1410,100,43.4\n1415,100,43.6\n1420,100,43.7\n1425,100,43.6\n1430,100,43.6\n1435,100,43.5\n1440,100,43.5\n1445,100,43.6\n1450,100,43.6\n1455,100,43.5\n1460,100,43.4\n1465,100,43.6\n1470,100,43.6\n1475,100,43.6\n1480,100,43.6\n1485,100,43.7\n1490,100,43.7\n1495,100,43.7\n1500,100,43.7\n1505,100,43.6\n1510,100,43.6\n1515,100,43.7\n1520,100,43.7\n1525,100,43.5\n1530,100,43.5\n1535,100,43.7\n1540,100,43.8\n1545,100,43.7\n1550,100,43.8\n1555,100,43.8\n1560,100,43.8\n1565,100,43.8\n1570,100,43.9\n1575,100,44.0\n1580,100,43.8\n1585,100,43.9\n1590,100,44.0\n1595,100,44.1\n1600,100,44.1\n1605,100,44.1\n1610,100,44.2\n1615,100,44.0\n1620,100,44.1\n1625,100,44.0\n1630,100,44.0\n1635,100,44.1\n1640,100,44.1\n1645,100,44.2\n1650,100,44.2\n1655,100,44.2\n1660,100,44.2\n1665,100,44.1\n1670,100,44.3\n1675,100,44.3\n1680,100,44.3\n1685,100,44.5\n1690,100,44.5\n1695,100,44.5\n1700,100,44.5\n1705,100,44.5\n1710,100,44.6\n1715,100,44.7\n1720,100,44.5\n1725,100,44.7\n1730,100,44.7\n1735,100,44.9\n1740,100,44.8\n1745,100,45.0\n1750,100,44.8\n1755,100,44.9\n1760,100,44.9\n1765,100,45.0\n1770,100,45.1\n1775,100,45.1\n1780,100,45.1\n1785,100,45.2\n1790,100,45.1\n1795,100,45.2\n1800,100,45.2\n1805,100,45.3\n1810,100,45.3\n1815,100,45.2\n1820,100,45.3\n1825,100,45.2\n1830,100,45.2\n1835,100,45.3\n1840,100,45.3\n1845,100,45.2\n1850,100,45.3\n1855,100,45.2\n1860,100,45.4\n1865,100,45.4\n1870,100,45.2\n1875,100,45.4\n1880,100,45.3\n1885,100,45.4\n1890,100,45.4\n1895,100,45.2\n1900,100,45.1\n1905,100,45.2\n1910,100,45.1\n1915,100,45.3\n1920,100,45.1\n1925,100,45.2\n1930,100,45.2\n1935,100,45.0\n1940,100,45.0\n1945,100,45.1\n1950,100,45.2\n1955,100,45.0\n1960,100,45.2\n1965,100,45.3\n1970,100,45.2\n1975,100,45.3\n1980,100,45.1\n1985,100,45.2\n1990,100,45.3\n1995,100,45.3\n2000,100,45.3\n2005,100,45.3\n2010,100,45.2\n2015,100,45.3\n2020,100,45.1\n2025,100,45.3\n2030,100,45.2\n2035,100,45.2\n2040,100,45.4\n2045,100,45.2\n2050,100,45.3\n2055,100,45.4\n2060,100,45.5\n2065,100,45.4\n2070,100,45.4\n2075,100,45.3\n2080,100,45.4\n2085,100,45.3\n2090,100,45.5\n2095,100,45.4\n2100,100,45.5\n2105,100,45.3\n2110,100,45.5\n2115,100,45.5\n2120,100,45.5\n2125,100,45.3\n2130,100,45.4\n2135,100,45.4\n2140,100,45.4\n2145,100,45.5\n2150,100,45.3\n2155,100,45.5\n2160,100,45.4\n2165,100,45.5\n2170,100,45.3\n2175,100,45.5\n2180,100,45.5\n2185,100,45.5\n2190,100,45.5\n2195,100,45.4\n2200,100,45.5\n2205,100,45.3\n2210,100,45.4\n2215,100,45.4\n2220,100,45.5\n2225,100,45.3\n2230,100,45.3\n2235,100,45.4\n2240,100,45.5\n2245,100,45.5\n2250,100,45.5\n2255,100,45.5\n2260,100,45.5\n2265,100,45.5\n2270,100,45.5\n2275,100,45.6\n2280,100,45.5\n2285,100,45.6\n2290,100,45.5\n2295,100,45.5\n2300,100,45.5\n2305,100,45.5\n2310,100,45.6\n2315,100,45.6\n2320,100,45.7\n2325,100,45.5\n2330,100,45.6\n2335,100,45.6\n2340,100,45.7\n2345,100,45.8\n2350,100,45.7\n2355,100,45.7\n2360,100,45.6\n2365,100,45.8\n2370,100,45.7\n2375,100,45.9\n2380,100,45.8\n2385,100,45.8\n2390,100,45.7\n2395,100,45.6\n2400,100,45.9\n2405,100,45.7\n2410,100,45.7\n2415,100,45.7\n2420,100,45.7\n2425,100,45.8\n2430,100,45.9\n2435,100,45.8\n2440,100,45.7\n2445,100,45.9\n2450,100,45.8\n2455,100,45.7\n2460,100,45.9\n2465,100,45.9\n2470,100,45.9\n2475,100,45.9\n2480,100,45.7\n2485,100,45.8\n2490,100,45.7\n2495,100,45.7\n2500,100,45.9\n2505,100,45.8\n2510,100,45.9\n2515,100,45.8\n2520,100,45.7\n2525,100,45.7\n2530,100,45.9\n2535,100,45.8\n2540,100,45.9\n2545,100,45.9\n2550,100,45.9\n2555,100,45.7\n2560,100,46.0\n2565,100,45.8\n2570,100,45.8\n2575,100,45.9\n2580,100,46.0\n2585,100,45.8\n2590,100,46.0\n2595,100,45.8\n2600,100,45.8\n2605,100,45.9\n2610,100,46.0\n2615,100,46.0\n2620,100,45.9\n2625,100,46.0\n2630,100,46.1\n2635,100,45.9\n2640,100,46.0\n2645,100,46.0\n2650,100,45.9\n2655,100,46.0\n2660,100,46.0\n2665,100,46.0\n2670,100,46.0\n2675,100,46.1\n2680,100,46.0\n2685,100,46.1\n2690,100,46.1\n2695,100,46.0\n2700,100,45.9\n2705,100,46.1\n2710,100,45.9\n2715,100,46.1\n2720,100,46.0\n2725,100,46.0\n2730,100,46.1\n2735,100,46.0\n2740,100,46.0\n2745,100,46.0\n2750,100,46.0\n2755,100,46.0\n2760,100,46.0\n2765,100,45.8\n2770,100,46.0\n2775,100,46.0\n2780,100,45.8\n2785,100,45.9\n2790,100,45.9\n2795,100,45.9\n2800,100,45.9\n2805,100,46.0\n2810,100,46.0\n2815,100,46.0\n2820,100,46.0\n2825,100,46.0\n2830,100,45.9\n2835,100,45.9\n2840,100,45.9\n2845,100,45.9\n2850,100,45.9\n2855,100,46.0\n2860,100,46.0\n2865,100,45.9\n2870,100,45.8\n2875,100,45.8\n2880,100,46.1\n2885,100,46.0\n2890,100,46.1\n2895,100,45.9\n2900,100,46.1\n2905,100,45.9\n2910,100,46.1\n2915,100,45.9\n2920,100,46.0\n2925,100,45.9\n2930,100,46.1\n2935,100,46.0\n2940,100,46.0\n2945,100,46.1\n2950,100,46.0\n2955,100,46.0\n2960,100,46.1\n2965,100,46.1\n2970,100,46.0\n2975,100,45.9\n2980,100,46.0\n2985,100,46.1\n2990,100,46.0\n2995,100,46.1\n3000,100,46.0","category":"page"},{"location":"Optimization/systemParaEste_batter/#MTK部分参数辨识实例","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: HYEmail:1171006975@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste_batter/#原理","page":"MTK部分参数辨识实例","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在进行参数辨识的时候，我们往往会遇到一个问题——实验只能测一到两个关键数据，例如温度、电压电流等。但在咱们的ODEsystem中，状态量states往往不止一两个（甚至有几十个），而在DiffEqParamEstim.jl包中，构建损失函数时要求我们导入所有states的实验数据，显然咱们是办不到的。这个时候，咱们有两种解决方案：1.自己重构损失函数，这个方法显然是最高级的，是真正的治标又治本的方法，但是重构损失函数对初学者可能不够友好（比如说我）。因此，在这里给大家介绍第2种解决方案：引入加权值weight，无法通过实验测得的数据，我们可以将其的weight设为0，其他能测得的states设为1。这样，我们相当于重构了损失函数，程序只会根据我们“指定”的那些数据进行参数辨识，效果跟方案1是一样的。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"下面以三星18650锂电池为例，对锂电池的模型参数进行辨识。","category":"page"},{"location":"Optimization/systemParaEste_batter/#等效电路建模","page":"MTK部分参数辨识实例","title":"等效电路建模","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"基于ModelingToolkit，建立Thevenin二阶RC等效电路模型，如下图所示。 该等效电路模型是由开路电压Uoc，欧姆内阻R0和两个RC网络结构组成，U1、U2分别为R1、R2的端电压，UT表示电池的端电压。 (Image: 图1)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建组件","page":"MTK部分参数辨识实例","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"组件总共有两个，一个是锂电池组件，用来模拟锂电池的伏安特性，另一个是充放电控制器组件，用来模拟锂电池的恒流充放电。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"using DiffEqParamEstim, DifferentialEquations, Random, ModelingToolkit, PlotlyJS\nusing OptimizationOptimJL\nusing IfElse: ifelse\nimport RecursiveArrayTools.VectorOfArray\n@variables t\n∂ = Differential(t)\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction OnePort_key(; name, v_start = 1.0, i_start = 0.0)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = v_start [irreducible=true] i(t) = i_start [irreducible=true]\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\nfunction Lithium_ion_batteries(; name, OCV=3.9998, R0=0.029031, R1=0.00994, R2=0.01408, C1=147.462, C2=902.911)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    sts = @variables v_c1(t) = 0.001 v_c2(t) = 0.001 v_b(t) = 1.0 i_b(t) = 0.0\n    ps = @parameters(\n        R0 = R0,\n        R1 = R1,\n        R2 = R2,\n        C1 = C1,\n        C2 = C2,\n        OCV = OCV,\n    )\n    eqs = [\n        OCV ~ i_b * R0 + v_c1 + v_c2 + v_b\n        i_b ~ C1 * ∂(v_c1) + v_c1 / R1\n        i_b ~ C2 * ∂(v_c2) + v_c2 / R2\n        v ~ v_b\n        i ~ -i_b\n    ]\n    return extend(ODESystem(eqs, t, sts, ps; name=name), oneport)\nend\nfunction charge_controller(; name)\n    @named oneport = OnePort_key()\n    @unpack v, i = oneport\n    equa = ifelse(t <= 10.0,16.0,ifelse(t <= 40.0,0.0,ifelse(t <= 50.0,-16.0,0.0)))\n    eqs = [i ~ equa]\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"不难发现，系统一共定义有6个参数，分别是欧姆内阻R0,两个RC支路所对应的R1,R2,C1,C2以及开路电压OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"@named ground = Ground()\n@named cg = charge_controller()\n@named batter = Lithium_ion_batteries()\neqs = [\n    connect(batter.p, cg.p)\n    connect(batter.n, cg.n, ground.g)\n]\n\n@named OdeFun = ODESystem(eqs, t)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.024058864\n    batter.v_c2 => 0.002594792\n    cg.v => 3.928902637\n    cg.i => 0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (40.0, 60.0))","category":"page"},{"location":"Optimization/systemParaEste_batter/#导入实验数据","page":"MTK部分参数辨识实例","title":"导入实验数据","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"导入实验数据，并对数据的格式进行一定的处理。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    40.98797751\n    42.00601125\n    42.99980609\n    43.99360093\n    45.01163467\n    46.00542951\n    46.99922436\n    47.9930192\n    50.99864262\n    53.0104712\n    55.99185573]\nreal_data = [\n    4.511920324\n    4.536819172\n    4.551011516\n    4.570183629\n    4.57665733\n    4.5881108\n    4.593588547\n    4.598817305\n    3.985060691\n    3.94746343\n    3.910364146]\n\nrandomized = VectorOfArray([[0, 0, real_data[i], 0] for i in 1:length(time)])\ndata = convert(Array, randomized)\n\nweight = VectorOfArray([[0.0, 0.0, 1.0, 0.0] for i in 1:length(time)])\ndata_weight = convert(Array, weight)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"本实例的数据通过getdata软件从文献中扣取。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统变量有四个，分别为batter.v_c1,batter.v_c2,cg.v,cg.i。其中cg.v的数据通过实验获得，其权重值weight设为1，其他的变量权重值设为0。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统参数有六个，分别为batter.R0,batter.R1,batter.R2,batter.C1,batter.C2,batter.OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"最终生成了data和data_weight矩阵，分别代表实验数据和相应权重值。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图2)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在不知道参数的顺序时，可以使用parameters和states函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"parameters(sys)\nstates(sys)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建损失函数并求解","page":"MTK部分参数辨识实例","title":"构建损失函数并求解","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"obj = build_loss_objective(prob, Rosenbrock23(), L2Loss(time, data, data_weight=data_weight), maxiters=100000)\n\nresult = OptimizationOptimJL.optimize(obj,[0.037517357, 0.020913201, 0.006915906, 4636.08469, 1292.103841, 3.955556293])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图3)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"至此，锂电池充电阶段的参数辨识完毕。同理可辨识放电阶段的参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段实验数据：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    1.502811712\t\n    3.005623424\n    4.508435137\t\n    6.011246849\t\n    7.489819663\t\n    11.9982548\t\n    13.50106651\t\n    15.00387822\t\n    16.50668994\t\n    18.00950165\t\n    19.48807446\t\n    20.99088617\t\n    22.49369789\t\n    23.9965096\t\n    25.49932131\t\n    27.00213302\t\n    28.50494474\n    30.00775645\t\n    31.51056816\t\n    32.98914097\n    34.49195269\n    35.9947644]\nreal_data = [\n    3.335698724\n    3.31503268\n    3.295860566\n    3.277933396\n    3.266977902\n    3.864799253\n    3.878244631\n    3.880734516\n    3.888702148\n    3.897167756\n    3.898910675\n    3.902645503\n    3.908372238\n    3.911858077\n    3.915094927\n    3.918082789\n    3.91957672\n    3.926797386\n    3.923311547\n    3.92107065\n    3.92107065\n    3.926299409]","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图4)","category":"page"},{"location":"Optimization/systemParaEste_batter/#模型验证","page":"MTK部分参数辨识实例","title":"模型验证","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"当放电阶段和充电阶段的模型参数全部辨识出来了以后，我们再将模型参数重新带回ODEsystem中，验证一下辨识结果是否有效。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"continuous_events = [\n    [t ~ 40.0] => [batter.R0 ~ 0.037203619\n        batter.R1 ~ 0.062205413\n        batter.R2 ~ 0.007078411\n        batter.C1 ~ 6373.89753\n        batter.C2 ~ 407.3465496\n        batter.OCV ~ 3.902760964]\n]\n\n@named OdeFun = ODESystem(eqs,t,continuous_events=continuous_events)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.0\n    batter.v_c2 => 0.0\n    cg.v => 0.0\n    cg.i => 0.0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (0.0, 60.0))\nsol = solve(prob)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"对比锂电池的实验数据和仿真数据，可以得到锂电池模型的端电压响应拟合曲线与实际端电压响应曲线的误差，如下图所示。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图5)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图6)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"可以看到，各点的拟合电压曲线误差范围均在约±0.006 V以内，即0.19%。电压最大误差为0.0059 V，平均误差为0.0021 V。电压误差大小远远较锂电池平台电压的变化范围小。因此从精度上看，模型误差尚在可接受的范围之内。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。 完整代码可以在/src目录下查看","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波理论与应用","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"tip: Tip\nContents：卡尔曼滤波(Kalman Filtering)Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"note: Note\n一篇卡尔曼滤波的英文博客，兼具理论与感性认识。上述博客的中文翻译版本","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波介绍","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波介绍","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"一句简单的话概括卡尔曼滤波：综合考虑模型计算值与实际测量值，估计动态系统中状态的真实值。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对这句概括的话，提出2个问题：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为什么要综合考虑模型计算值和实际测量值？\n如何综合考虑？","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题1，有2个事实：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"模型不是准确的。例如，欧姆定律中，电阻值真的是一个常数吗？基础模型尚且如此，更不用说复杂系统的模型了。所以，描述系统的模型，一定是有偏差的。\n测量值不代表真实值。通过各种仪表读数时，读出来的数不能代表真实值，读数时会有各种随机误差。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"所以，Kalman觉得可以结合模型计算值与观测值，对状态的真实值进行估计。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题2：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"综合考虑的方式为：先通过状态空间方程的计算出结果，再对结合误差对结果进行修正。由此可见，卡尔曼滤波是控制学与统计学的交叉学科方法。","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波的数学表达","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波的数学表达","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"只给结论，不推导。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"leftbeginarrayl\nx_k=F_k-1 x_k-1+Gamma_k-1 w_k-1 \nz_k=H_k x_k+v_k\nendarrayright","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下表k代表k时刻\n系统状态向量——x_k（行向量）\n系统状态转移矩阵——F_k，如果在时间域上不变则为——F\n模型噪声——w_k\n模型噪声矩阵（描述噪声对变量的影响）——Gamma_k（行向量）\n系统量的测向量——z_k\n量测矩阵——H_k（行向量）\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"同时，噪声满足正态分布：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"w_k sim N(0Q_k)  v_k sim N(0R_k)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下面为卡尔曼滤波的滤波过程:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step1 模型计算:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"x_k=F_k-1 x_k-1\nP_k=F_k-1 P_k-1 F_k-1^T+Gamma_k-1 Q_k-1 Gamma_k-1^T","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step2 滤波:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"G_k=P_k  H_k^TleftH_k P_k H_k^T+R_kright^-1\nhatx_k=x_k+G_k(tildez_k - H_kx_k)\nhatP_k = (I-G_kH_k)P_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"系统的量测的协方差矩阵——P\n滤波后的系统状态向量——hatx_k\n滤波后的系统状态向量——hatx_k\n模型噪声的方差——Q_k，如果在时间域上不变则为——Q\n测量噪声的方差——R_k，如果在时间域上不变则为——R\n滤波后的系统的量测的协方差矩阵——hatP_k\n测量值向量——tildez_k\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波实例","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波实例","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"考虑加热器：fracdTdt = -(T-20) + 10 即散热系数为1，加热功率为10，环境温度为20。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"使用DifferentialEquations.jl获得仿真数据并加上扰动。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"using DifferentialEquations\nusing Statistics, Plots\n\nf(u, t, p) = -(u - 20) + 10\n\nprob = ODEProblem(f, 20.0, (0, 5))\n\nsol = solve(prob, saveat=0.1)\nnoise = rand(-0.5:0.0001:0.5, length(sol.u))\ncov(noise)\n\nmeasureT = noise + sol.u\nt = collect(0:0.1:5)\nplot(t, measureT, label=\"measure\", legend_position=:topleft)\nplot!(t, sol.u, label=\"real\", legend_position=:topleft)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"获得的measureT将作为未来每个时间点上的温度测量数据（实际为精确解加随机误差生成的数据）。真实值与测量值如下图。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若取dt=01，使用欧拉法离散，则上述微分则转变为状态空间方程：T_k+1 = 09T_k+3","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若采用上述状态空间方程，则可以称之为“完美模型”。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为了验证卡尔曼滤波的有效性，我们设计一个十分错误的模型：T_k+1 = T_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"即，我们认为这是一个温度不变的系统（错得不能再错的模型）。同时，给一个比较大的Q_w，说明模型扰动的方差比较大。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 1\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i]\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Wrong Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 2) ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"结果显示，居然和真实值差不多。如果令Q_w=1，给得比较小。则变成了：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"没那么好，但也不差（比直线好太多了）。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"如果把模型设置成原本的模型则:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 0.9\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i] + 3\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Right Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"基本就一致了。","category":"page"},{"location":"Control/KalmanFiltering/#小结","page":"卡尔曼滤波理论与应用","title":"小结","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"卡尔曼滤波的重要意义是利用了测量值带来的信息。模型不准确的时候，利用滤波带来的效果，可以对模型进行一个矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"但它的缺点在于，对预测没有帮助。对未来的多点预测只能是通过模型。既然是预测，说明事情还没有发生，那测量值无法获得，也就无法通过测量值进行矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其特点是，对已经发生的事情做一个优化，而不能提升预测未来的能力。","category":"page"},{"location":"WorkFlow/julia的安装/#Julia安装","page":"Julia安装","title":"Julia安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\nContents：julia安装Contributor: 孙蓓蓓、张启Email:如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia的安装/#下载网址","page":"Julia安装","title":"下载网址","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"搜索清华大学开源软件镜像站。   (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#下载julia-xxx-win64.zip安装包","page":"Julia安装","title":"下载julia-xxx-win64.zip安装包","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"note: Note\nv1.7.2(Feb 6,2022)为julia当前稳定版本。新安装时，下载最新版。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"首先，在搜索框中搜索julia，点击julia-releases： (Image: ) 其次，点击bin/： (Image: ) 找到winnt/： (Image: ) 选择x64/： (Image: ) 然后，找到最新版本系列： (Image: ) 最后，下拉找到julia-xxx-win64.zip安装包，点击下载。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#解压安装","page":"Julia安装","title":"解压安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"找到下载好的安装包，右键解压。解压后，生成一个julia-1.7.2文件夹。可执行文件julia.exe就在julia-1.7.2文件夹的bin文件夹下。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#将路径加到环境变量中","page":"Julia安装","title":"将路径加到环境变量中","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框中找到“编辑系统环境变量”： (Image: ) 打开环境变量；在用户变量中选择变量Path，点击编辑；新建，将julia.exe文件所在路径复制进去，然后点击确定。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\n也可使直接“(Image: ) + r”打开运行▱，输入 rundll32 sysdm.cpl,EditEnvironmentVariables 直接打开环境变量设置界面，注意，此时无法编辑系统环境变量（实际上也并不建议直接编辑系统环境变量），编辑用户环境变量即可。","category":"page"},{"location":"WorkFlow/julia的安装/#执行julia","page":"Julia安装","title":"执行julia","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框输入cmd，打开命令提示符，输入julia，进入Julie REPL，此时julia就可以执行了。 (Image: ) 直接输入exit()，即可退出。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"另外，Windows下推荐使用Windows Terminal作为交互终端（直接的Cmd或Powershell终端中，均不支持类似","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"20px\" height=\"20px\" viewBox=\"220 280 180 120\" xml:space=\"preserve\">\n    <g>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M259.618,401.811l1.231,0.268l-4.314,13.678h-39.031v-1.371h1.903\n  c2.132,0,3.654-0.699,4.568-2.082c0.521-0.799,0.774-2.639,0.774-5.506v-32.534c0-3.147-0.343-5.114-1.041-5.9\n  c-0.964-1.091-2.398-1.637-4.301-1.637h-1.903v-1.383h22.827v1.383c-2.677-0.025-4.556,0.216-5.634,0.736\n  c-1.078,0.52-1.814,1.18-2.208,1.979c-0.394,0.787-0.596,2.69-0.596,5.685v31.671c0,2.057,0.203,3.465,0.596,4.238\n  c0.292,0.52,0.749,0.9,1.37,1.154c0.622,0.242,2.551,0.367,5.799,0.367h3.68c3.87,0,6.586-0.279,8.146-0.85\n  c1.561-0.57,2.982-1.586,4.276-3.031C257.042,407.229,258.336,404.932,259.618,401.811L259.618,401.811L259.618,401.811z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M265.631,392.346h-15.192l-2.657,6.193c-0.662,1.521-0.988,2.658-0.988,3.418\n  c0,0.594,0.287,1.117,0.85,1.57c0.573,0.455,1.797,0.752,3.694,0.889v1.068H238.98v-1.068c1.64-0.295,2.697-0.672,3.181-1.135\n  c0.988-0.92,2.074-2.805,3.27-5.641l13.809-32.292h1.008l13.661,32.637c1.097,2.627,2.094,4.326,2.993,5.107\n  c0.899,0.779,2.153,1.225,3.753,1.322v1.068h-15.489v-1.068c1.561-0.078,2.618-0.346,3.171-0.789\n  c0.553-0.436,0.83-0.979,0.83-1.621c0-0.848-0.396-2.182-1.166-4.02L265.631,392.346L265.631,392.346L265.631,392.346z\n   M264.821,390.202l-6.658-15.854l-6.826,15.854H264.821L264.821,390.202L264.821,390.202z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M313.479,365.008l0.563,11.921h-1.432c-0.27-2.098-0.64-3.594-1.126-4.502\n  c-0.768-1.445-1.804-2.507-3.083-3.197c-1.292-0.691-2.98-1.036-5.077-1.036h-7.163v38.833c0,3.121,0.345,5.064,1.011,5.844\n  c0.946,1.051,2.417,1.574,4.387,1.574h1.766v1.381h-21.552v-1.381h1.803c2.149,0,3.671-0.652,4.566-1.957\n  c0.55-0.793,0.832-2.621,0.832-5.461v-38.833h-6.114c-2.367,0-4.055,0.179-5.053,0.524c-1.305,0.473-2.417,1.394-3.338,2.737\n  c-0.92,1.356-1.471,3.172-1.65,5.475h-1.42l0.602-11.921H313.479L313.479,365.008L313.479,365.008z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M319.647,381.675v19.259h10.708c2.785,0,4.637-0.418,5.569-1.252\n  c1.251-1.104,1.938-3.042,2.085-5.826h1.325v16.965h-1.325c-0.331-2.367-0.674-3.889-1.006-4.564\n  c-0.429-0.834-1.141-1.496-2.122-1.975c-0.981-0.477-2.49-0.723-4.526-0.723h-10.708v16.068c0,2.158,0.098,3.471,0.281,3.938\n  c0.197,0.467,0.528,0.834,1.006,1.117c0.479,0.27,1.398,0.404,2.736,0.404h8.267c2.748,0,4.76-0.184,5.999-0.576\n  c1.251-0.381,2.44-1.129,3.594-2.258c1.484-1.484,3.006-3.729,4.563-6.723h1.435l-4.194,12.219h-37.56v-1.326h1.73\n  c1.141,0,2.232-0.281,3.263-0.834c0.772-0.379,1.288-0.957,1.569-1.717c0.271-0.773,0.405-2.344,0.405-4.709v-31.661\n  c0-3.091-0.307-4.992-0.933-5.716c-0.858-0.957-2.294-1.435-4.305-1.435h-1.73v-1.337h37.56l0.539,10.672h-1.41\n  c-0.503-2.563-1.055-4.318-1.668-5.274c-0.613-0.957-1.509-1.693-2.711-2.196c-0.957-0.355-2.65-0.54-5.066-0.54H319.647\n  L319.647,381.675L319.647,381.675z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M370.217,387.709l10.832,16.14c2.997,4.469,5.219,7.289,6.679,8.469\n  c1.448,1.182,3.29,1.83,5.524,1.957v1.371h-21.651v-1.371c1.435-0.025,2.502-0.18,3.2-0.457c0.521-0.217,0.939-0.561,1.282-1.016\n  c0.331-0.459,0.496-0.928,0.496-1.398c0-0.57-0.114-1.143-0.331-1.713c-0.178-0.42-0.862-1.512-2.044-3.277l-8.559-12.94\n  l-10.565,13.538c-1.117,1.447-1.791,2.4-2.006,2.883c-0.229,0.482-0.344,0.99-0.344,1.51c0,0.801,0.344,1.447,1.004,1.969\n  c0.672,0.521,1.955,0.826,3.835,0.902v1.371h-17.893v-1.371c1.27-0.127,2.349-0.395,3.276-0.789\n  c1.536-0.646,2.996-1.51,4.381-2.602c1.396-1.092,2.984-2.77,4.762-5.029l11.911-15.022l-9.93-14.552\n  c-2.705-3.937-5.004-6.527-6.883-7.747c-1.893-1.232-4.063-1.879-6.515-1.956v-1.384h23.327v1.384\n  c-1.98,0.076-3.34,0.394-4.076,0.965c-0.724,0.571-1.092,1.207-1.092,1.893c0,0.927,0.597,2.26,1.778,4.025l7.745,11.568\n  l8.966-11.353c1.041-1.333,1.676-2.248,1.917-2.743c0.229-0.508,0.355-1.016,0.355-1.537s-0.152-0.978-0.457-1.372\n  c-0.368-0.521-0.838-0.889-1.409-1.092c-0.571-0.216-1.752-0.331-3.53-0.356v-1.384h17.893v1.384\n  c-1.41,0.076-2.565,0.292-3.467,0.661c-1.333,0.571-2.565,1.346-3.683,2.311c-1.117,0.965-2.692,2.755-4.724,5.358L370.217,387.709\n  L370.217,387.709L370.217,387.709z\" />\n    </g>\n</svg>","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"的用法输入UTF-8字符）。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"直接在Microsoft Store上下载Windows Terminal，打开软件后进入设置界面： (Image: 打开Windows Teminal设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"可以直接在界面中运行julia命令，或者将Julia添加到终端中。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"左侧导航栏划至最下，新建配置文件，这里这就复制Windows Powershell的（有兴趣可以复制Cmd的试试）。 (Image: Winwdos Termianl 新建设置文件)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在新建的配置文件里面编辑设计即可，详细如图： (Image: Julia终端设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"注：终端界面的图标自己找一个，如果懒着找，就接着使用Powershell的也行。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH、Git与Git图形化软件","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"tip: Tip\nContents：SSH、Git与Git的图形化软件Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本文介绍ssh、git与git的图形化软件。他们之间的关系为：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git基于ssh通讯操作\ngit图形化软件是操作git的图形化软件","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH使用","page":"SSH、Git与Git图形化软件","title":"SSH使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#SSH是什么","page":"SSH、Git与Git图形化软件","title":"SSH是什么","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"SSH是一种网络协议，用于计算机之间的加密登录。一个用户从本地计算机，使用SSH协议登录另一台远程计算机，就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH密钥登录原理","page":"SSH、Git与Git图形化软件","title":"SSH密钥登录原理","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"客户端发出认证请求；\n服务器端使用客户端发送的公钥对一个随机的256位的字符串进行加密，并发送给 客户端；\n客户端使用私钥对字符串进行解密，并生成一个MD5值发送给服务器端；\n服务器端根据原始随机字符串生成MD5值进行匹配, 确认客户端身份；\n至此, 双方互相确认对方身份并建立加密信道, 可以正式进行安全通信。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH的两种认证方式","page":"SSH、Git与Git图形化软件","title":"SSH的两种认证方式","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.基于口令的安全认证 ：提供正确的用户口令后可以登录远程服务器。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"操作方式：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(默认端口为22)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh user@host\n\nexample：\nssh root@127.0.0.1\nssh yjy@152.20.45.154","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"然后输入登录密码进行登录 使用p参数，可以修改端口","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -p 端口号 user@host\n\nexample：\nssh -p 8080 yjy@152.20.45.154 ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"上面这个例子是以8080端口登录","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.基于密钥的安全认证 ：使用公钥和私钥对的方式对用户进行认证。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"密钥登录首先需要产生公钥和私钥。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"公钥放在服务端，私钥放在需要远程登录服务端的客户端","category":"page"},{"location":"Tools/3-ssh-git实操/#产生公钥和私钥","page":"SSH、Git与Git图形化软件","title":"产生公钥和私钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh-keygen -t rsa","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"在~/.ssh文件夹（~为用户目录，windows和linux目录下都会有）下会出现idrsa与idrsa.pub两个文件。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"idrsa是私钥，idrsa.pub是公钥。","category":"page"},{"location":"Tools/3-ssh-git实操/#修改配置文件","page":"SSH、Git与Git图形化软件","title":"修改配置文件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之后，在远程主机的ssh配置文件(/etc/ssh/sshd_config)中做如下修改，开启权限。这几项有些是新加上的，有些原来是no：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys","category":"page"},{"location":"Tools/3-ssh-git实操/#在服务端存放公钥","page":"SSH、Git与Git图形化软件","title":"在服务端存放公钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法一：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"将公钥中的一大串字符添加到服务端~/.ssh/authorized_keys文件中去，如果已经存在，那么在后面再添上一条。不建议覆盖，因为这样其它客户端远程登录的公钥就会被覆盖！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法二：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"也可以用一段代码自动加过去","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh root@111.20.45.124 \"mkdir -p .ssh && cat >> .ssh/authorized_keys\" < ~/.ssh/id_rsa.pub","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"这条命令由多个语句组成，依次分解开来看：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"（1）\"$ ssh user@host\"，表示登录远程主机；\n（2）双引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n（4）'cat >> .ssh/authorizedkeys' < ~/.ssh/idrsa.pub的作用是，将本地的公钥文件~/.ssh/idrsa.pub，重定向追加到远程文件authorizedkeys的末尾。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"写入authorized_keys文件后，公钥登录的设置就完成了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"现在就可以远程免密登录了！","category":"page"},{"location":"Tools/3-ssh-git实操/#可能出现的问题","page":"SSH、Git与Git图形化软件","title":"可能出现的问题","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"基本都是文件权限的问题，比如报错too open。Linux和Windows都会出现这样的情况，相关的解决方案很多，可以直接查找。","category":"page"},{"location":"Tools/3-ssh-git实操/#登录github或者码云","page":"SSH、Git与Git图形化软件","title":"登录github或者码云","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"用ssh怎么操作呢？","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"做一个转换，github相当于就是服务端，只需要把公钥放在服务端就可以了。在github上更加方便，因为它都是图形化软件操作。进入设置软件，选择ssh就可以进行调试了（码云同理）。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"配置好了之后，可以进行如下测试：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -T git@github.com\n（ssh -T git@gitee.com）","category":"page"},{"location":"Tools/3-ssh-git实操/#git的使用","page":"SSH、Git与Git图形化软件","title":"git的使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#git和ssh的关联","page":"SSH、Git与Git图形化软件","title":"git和ssh的关联","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之前讲了那么多ssh的知识，有什么作用呢？ 会了ssh，git基本就会了一半了！","category":"page"},{"location":"Tools/3-ssh-git实操/#git的关键要素","page":"SSH、Git与Git图形化软件","title":"git的关键要素","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本地工作区（自己电脑的文件夹）\n远程仓库（远端服务器上的文件夹）","category":"page"},{"location":"Tools/3-ssh-git实操/#git基本操作","page":"SSH、Git与Git图形化软件","title":"git基本操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"初始化本地仓库\n从远端拉取\n在本地编写文件\n文件暂存\n提交修改\n提交到远程","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.初始化本地仓库","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"通过git bash或者cmd进入仓库文件夹 输入：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git init","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"简单配置(相关教程也很多，不赘述)：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git config user.name \"Your Name\"\ngit config user.email \"email@example.com\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"链接到仓库的地址，相当于后面的操作就不需要输入地址了： （origin相当于变量，储存远端的地址）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git remote add origin \"仓库的ssh地址\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.从远端拉取","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"拉取origin的master分支","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git pull origin master","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.本地编写文件 编写hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"4.提交暂存","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add .\n##或者\ngit add hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"5.提交修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git commit -m \"文件说明\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"6.推送到远端","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git进阶操作","page":"SSH、Git与Git图形化软件","title":"git进阶操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交多个版本的文件\n回退","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1. 提交多个版本的文件 hello.txt 版本1：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"first\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本2：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"second\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本3：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you\nI love you too much","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"third\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"接下来查看日志：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以看到，HEAD 指向的是最新版本（head可以理解为当前版本，也就说如果要推到远程就是推这个版本）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.回退 接下来回退到上一个版本：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard HEAD^ ##回退到上上个就是：HEAD^^","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"那么可以看到head确实变了","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"又不想回退了，还是要回到第三次改变的最新版本","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard 3ed54(commid的id，只能这样操作)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"其实回退了之后就看不到id了，如果想要回到最新版本，就要记下id，所以说善变是有代价的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以方便查看id与修改信息：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log --pretty=oneline","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.Push 在善变之后，找到了真爱，不管是谁吧，反正证还是要领的。最后就是把文件推送到远端了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git图形化软件","page":"SSH、Git与Git图形化软件","title":"git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git图形化软件的好处就是，把以上对git的操作图形化。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"常用且免费的有：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"sourcetree\nvscode中内嵌的git操作页面\ngitkraken（团队版付费，个人免费）","category":"page"},{"location":"Tools/3-ssh-git实操/#sourcetree示例","page":"SSH、Git与Git图形化软件","title":"sourcetree示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"软件如下：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"比如说clone：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"某一个链接仓库的工作软件：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/#vscode示例","page":"SSH、Git与Git图形化软件","title":"vscode示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 4)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"更多操作见vscode中使用git","category":"page"},{"location":"Tools/3-ssh-git实操/#gitkraken示例","page":"SSH、Git与Git图形化软件","title":"gitkraken示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"gitkraken网址","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 5)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"不管什么软件，拉取、提交、暂存等等都是相同的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如果你明白git的操作原理了，那么这个无师自通，因为本质上sourcetree就是提供一个图形化的操作软件。再没有其它新鲜玩意了！","category":"page"}]
}
