<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MTK求解MPC问题 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JumpMILP/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste_batter/">MTK部分参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li class="is-active"><a class="tocitem" href>MTK求解MPC问题</a><ul class="internal"><li><a class="tocitem" href="#MTK中的ControlSystem"><span>MTK中的ControlSystem</span></a></li><li><a class="tocitem" href="#MTK中的OptimizationSystem"><span>MTK中的OptimizationSystem</span></a></li><li><a class="tocitem" href="#实例：加热器问题"><span>实例：加热器问题</span></a></li></ul></li><li><a class="tocitem" href="../OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../../CSBase/1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../../CSBase/2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../../CSBase/3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../../CSBase/4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../../CSBase/5-make和Makefile介绍/">make和Makefile介绍</a></li><li><a class="tocitem" href="../../CSBase/6-静态链接库和动态链接库/">静态链接库和动态链接库</a></li><li><a class="tocitem" href="../../CSBase/7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../../CSBase/9-dll生成与调用实操/">动态链接库(DLL)的生成与调用</a></li><li><a class="tocitem" href="../../CSBase/SSH_Git/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../CSBase/env_variable/">环境（变量）的本质</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/ julia-binary-wrappers/">julia对外部程序的加壳</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia-call-c7fortran/">julia调用dll中的函数</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Control</a></li><li class="is-active"><a href>MTK求解MPC问题</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MTK求解MPC问题</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Control/MTKMPC.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MTK求解MPC问题"><a class="docs-heading-anchor" href="#MTK求解MPC问题">MTK求解MPC问题</a><a id="MTK求解MPC问题-1"></a><a class="docs-heading-anchor-permalink" href="#MTK求解MPC问题" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：MTK、Control</p><p>Contributor: YJY</p><p>Email:522432938@qq.com</p><p>如有错误，请批评指正。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>MPC = Model Predict Control</p><p>MTK = ModelingToolkit.jl</p><p><a href="https://mtk.sciml.ai/stable/tutorials/optimization/">OptimizationSystem</a>为MTK中的系统类型之一</p></div></div><h2 id="MTK中的ControlSystem"><a class="docs-heading-anchor" href="#MTK中的ControlSystem">MTK中的ControlSystem</a><a id="MTK中的ControlSystem-1"></a><a class="docs-heading-anchor-permalink" href="#MTK中的ControlSystem" title="Permalink"></a></h2><p>在ModellingToolkit的Optimal Control中，有关于ControlSystem的描述。但经过实验测试，ControlSystem并不能很好地求解“过程控制量”的值。</p><p>因为MTK使用runge<em>kutta</em>discretize（龙格库塔离散）函数将问题离散。问题离散后，传入OptimizationSystem，而OptimizationSystem目前有一个缺陷——不能接受问题的约束。所以，即使用龙格库塔离散离散出控制过程中的多个状态量，在变量没有约束时，优化结果没有意义。（离散的概念在<a href="../../Optimization/DE_Estim/">微分方程参数辨识</a>中有提及） 在实例过后，这一点会有清晰的体现。</p><h2 id="MTK中的OptimizationSystem"><a class="docs-heading-anchor" href="#MTK中的OptimizationSystem">MTK中的OptimizationSystem</a><a id="MTK中的OptimizationSystem-1"></a><a class="docs-heading-anchor-permalink" href="#MTK中的OptimizationSystem" title="Permalink"></a></h2><p>为了简单起见，手动构建一个MPC优化问题，通过OptimizationSystem来求解。通过构建优化目标方程，调用不同优化器求解该优化问题。那么从控制问题到优化问题这一过程可以看成是手动离散。相当于自己实现了runge<em>kutta</em>discretize。构建完优化问题，就可以直接把它推给OptimizationProblem求解，这是可以做到的。</p><p><strong>上述过程的核心就是把控制中的状态量手写出来</strong>。</p><p>可行的做法是，<strong>通过MTK符号建模体系建立优化变量，同时构建Loss方程关于优化变量的符号表达。通过OptimizationSystem生成用符号体系构建的优化问题，把构建的OptimizationSystem推给OptimizationProblem，最后选择合适的求解器求解</strong>。</p><h2 id="实例：加热器问题"><a class="docs-heading-anchor" href="#实例：加热器问题">实例：加热器问题</a><a id="实例：加热器问题-1"></a><a class="docs-heading-anchor-permalink" href="#实例：加热器问题" title="Permalink"></a></h2><h3 id="问题描述"><a class="docs-heading-anchor" href="#问题描述">问题描述</a><a id="问题描述-1"></a><a class="docs-heading-anchor-permalink" href="#问题描述" title="Permalink"></a></h3><p>现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为<span>$T_{out}$</span>。那么控制方程: </p><p class="math-container">\[T&#39; = α*(T_{out} - T) + β*Q(t)\]</p><p>现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从<span>$T_{0}$</span>开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量<span>$Q(t)$</span> 使得损失函数最小:</p><p class="math-container">\[Loss = \sum_{i} ||58.0-T(t_i)||\]</p><p>而<span>$Q(t_i)$</span>就是未来一段时间域内，不同时间点上的控制量（控制科学中称为状态量）。通过改变这些值，能够控制温度的走势，这是控制的内涵。若使温度达到一个让人满意的状态（这里是维持在58℃，也可以是使温度线性上升等等），这是最优控制的内涵。</p><p><strong>所以，最优控制或者模型预测控制最根本的数学内涵是优化——多变量优化</strong>。这也是为什么能用OptimizationProblem来处理控制问题。</p><h3 id="构建问题"><a class="docs-heading-anchor" href="#构建问题">构建问题</a><a id="构建问题-1"></a><a class="docs-heading-anchor-permalink" href="#构建问题" title="Permalink"></a></h3><p>首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。</p><pre><code class="language-julia hljs">using Plots,DifferentialEquations
Tout = 18.0
α = 0.2
β = 0.1
f(x,p,t) = α*(Tout - x) + β*p
tspan=(0.0,40.0)
u0 = 20.0
p = 80.0
pr = ODEProblem(f,u0,tspan,p)
sol = solve(pr)
plot(sol,ylimit=(10,60))</code></pre><p>得到的结果是： <img src="../../assets/MTKMPC_17_40_08.png" alt="图 1"/>  </p><p>很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。<strong>我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80</strong>，就可以实现“温度迅速上升并最后稳定在58度”。</p><h3 id="优化求解"><a class="docs-heading-anchor" href="#优化求解">优化求解</a><a id="优化求解-1"></a><a class="docs-heading-anchor-permalink" href="#优化求解" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Symbolics,ModelingToolkit,GalacticOptim,Optim
N = 20
Tout = 18.0
T0 = 20.0
dt = 4/N
Loss = 0.0
T = T0
α = 0.2
β = 0.1
@variables u[1:N]
for i = 1:N
    global T = T + (α*(Tout - T) + β*u[i])*dt
    global Loss += (T - 58.0)^2
end</code></pre><p>u是符号量，离散的个数为N，上面选择离散为20个变量。通过一个for循环，就可以迭代求解20个点上的温度值并且构建Loss方程。<strong>这里的20个变量，就是控制的核心，通过改变这20个不同时间点上的控制量（加热功率）的值，使得被控量（温度）接近“更好、更快”地接近目标——58℃</strong>。</p><p>可以看到Loss方程的结果：</p><p><img src="../../assets/MTKMPC_17_53_09.png" alt="图 2"/>  </p><p>有些许复杂，但在情理之中。</p><pre><code class="language-julia hljs">@named sys = OptimizationSystem(Loss,[u[i] for i in 1:N],[],inequality_constraints=inequ)
u0 = [u[i] =&gt; 1.0 for i in 1:N]
lb = [0.0 for i in 1:N]
ub = [200.0 for i in 1:N]
prob = OptimizationProblem(sys,u0,[],lb = lb,ub = ub,grad=true,hess=true)
s = solve(prob,Optim.LBFGS())</code></pre><p>然后构建System和OptimizationProblem，给定上下限。这里功率上限设为200，最后求解！</p><p>结果为：</p><pre><code class="language-julia hljs">u: 20-element Vector{Float64}:
 199.99999999999997
 199.99999999999997
 199.99999999999997
 199.99999999999997
 199.99999999999997
 199.99999999999997
 199.99999999999997
 199.99999999999994
 199.99999999999991
 199.9999999999999
 199.99999999999957
 199.99999999996504
  82.18673442597857
  79.99995550035416
  80.0000502201614
  79.99991729083732
  80.00001272875645
  80.00004827285969
  79.99999940246633
  79.99997217751334</code></pre><p><img src="../../assets/MTKMPC_17_57_10.png" alt="图 3"/>  </p><p>应该说是非常理想的。和我们设想的一样。先以最大功率加热到58℃附近，然后迅速将到稳态维持58℃的功率80，这样2s就完成了控制过程，而之前以恒定功率80加热，耗费了20s!</p><hr/><p>从图中可以很容易看出局限性，加热功率先猛加，以最高限度200直接加热到58，然后功率在恒定在80维持恒温58摄氏度。这种直上直下的调节，很显然不那么让人满意。可以想象，假如不给变量设置上下限，那么优化的结果一定是：第一个离散的变量加热功率上万，相当于在<strong>一瞬间使用超大且精准的功率把温度加到58摄氏度</strong>。第二个往后的状态量为80——维持恒温58摄氏度的加热功率。</p><p>这在数学上是合理的，在实际中却没有意义。所以在控制中一般需要加一些约束，比如加热功率上下限、加热功率变化幅度。</p><p>所以，为了处理约束，可以<a href="../JuMPMPC/">使用JuMP来做MPC</a>。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../KalmanFiltering/">« 卡尔曼滤波理论与应用</a><a class="docs-footer-nextpage" href="../OptimControl/">最优控制理论与应用 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 July 2023 21:34">Sunday 2 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
